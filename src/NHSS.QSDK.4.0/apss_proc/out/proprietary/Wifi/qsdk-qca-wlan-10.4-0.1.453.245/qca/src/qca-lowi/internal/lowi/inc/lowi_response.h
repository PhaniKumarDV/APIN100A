#ifndef __LOWI_RESPONSE_H__
#define __LOWI_RESPONSE_H__

/*====*====*====*====*====*====*====*====*====*====*====*====*====*====*====*

        LOWI Response Interface Header file

GENERAL DESCRIPTION
  This file contains the structure definitions and function prototypes for
  LOWIResponse

Copyright (c) 2012 Qualcomm Atheros, Inc.
  All Rights Reserved.
  Qualcomm Atheros Confidential and Proprietary.

Copyright (c) 2016 Qualcomm Technologies, Inc.
 All Rights Reserved.
 Confidential and Proprietary - Qualcomm Technologies, Inc.
=============================================================================*/
#include <inc/lowi_const.h>
#include <inc/lowi_scan_measurement.h>


namespace qc_loc_fw
{

// Forward declaration
class LOWIRequest;

/**
 * Base class for Response
 */
class LOWIResponse
{
private:
  uint32 requestId;
public:
  /**
   * Log Tag
   */
  static const char * const TAG;

  /** Type of Response
   * When adding additional responses, update the following utility function:
   *  -- LOWIUtils::to_string(LOWIResponse::eResponseType a)
   *
   *  ADD NEW RESPONSES ONLY AT THE END OF THIS ENUM
   */
  enum eResponseType
  {
    /** Unknown response type */
    RESPONSE_TYPE_UNKNOWN = 0,
    /** Response carrying the results produced by a DISCOVERY_SCAN request */
    DISCOVERY_SCAN,
    /** Response carrying the results produced by a RANGING_SCAN request */
    RANGING_SCAN,
    /** List of capabilities supported by LOWI */
    CAPABILITY,
    /** Response to a RESET_CACHE request */
    RESET_CACHE,
    /** Response carrying asynchronous results produced by an
     *  ASYNC_DISCOVERY_SCAN_RESULTS request */
    ASYNC_DISCOVERY_SCAN_RESULTS,
    /** Status response */
    LOWI_STATUS,
  };

  /**
   * Defines status of the Scan Request.
   */
  enum eScanStatus
  {
    SCAN_STATUS_UNKNOWN = 0,
    /** Measurements were obtained successfully from the WLAN driver.
     * Note that SUCCESS does not guarantee that there is at least one
     * measurement in this packet. It is possible to have zero measurement
     * and a SUCCESS; if there are no APs in the vicinity.*/
    SCAN_STATUS_SUCCESS = 1,
    /** Indicates that the number of pending clients have reached the maximum*/
    SCAN_STATUS_BUSY = 2,
    /** Unable to initiate request to driver*/
    SCAN_STATUS_DRIVER_ERROR = 3,
    /** Unable to get response from driver*/
    SCAN_STATUS_DRIVER_TIMEOUT = 4,
    /** There is an internal error condition that causes
     * LOWI unable to provide any measurements*/
    SCAN_STATUS_INTERNAL_ERROR = 5,
    /** Invalid request*/
    SCAN_STATUS_INVALID_REQ = 6,
    /** Request not supported */
    SCAN_STATUS_NOT_SUPPORTED = 7,
    /** Wifi not enabled */
    SCAN_STATUS_NO_WIFI = 8,
    /** Too many instances of this request type */
    SCAN_STATUS_TOO_MANY_REQUESTS = 9,
    /** Out of memory condition */
    SCAN_STATUS_OUT_OF_MEMORY = 10
  };

  /**
   * Constructor
   * @param uint32 requestId generated by the client for request
   */
  LOWIResponse (uint32 requestId);
  /**
   * Destructor
   */
  virtual ~LOWIResponse () = 0;

  /**
   * Request id generated and provided in request by the client.
   * Echoed back in the response.
   * @return Corresponding Request id
   */
  uint32 getRequestId ();

  /**
   * Returns the response type
   * @return eResponseType Type of Response
   */
  virtual eResponseType getResponseType () = 0;
};

/**
 * This class defines the Capabilities of the WifiDriver
 */
class LOWICapabilities
{
public:
  /** true if Discovery scan is supported*/
  bool discoveryScanSupported;

  /** true if Ranging scan is supported*/
  bool rangingScanSupported;

  /** true if Active scan is supported*/
  bool activeScanSupported;

 /** true if single-sided ranging is supported */
  bool oneSidedRangingSupported;

  /** true if dual-sided ranging per 11v std is supported */
  bool dualSidedRangingSupported11v;

  /** true if dual-sided ranging per 11mc std is supported */
  bool dualSidedRangingSupported11mc;

  /** Highest bandwidth support for rtt requests */
  uint8 bwSupport;

  /** Bit mask representing preambles supported for rtt requests */
  uint8 preambleSupport;

  //driver static capability bit masks
  #define LOWI_NO_SCAN_SUPPORTED 0x00
  #define LOWI_DISCOVERY_SCAN_SUPPORTED 0x02
  #define LOWI_RANGING_SCAN_SUPPORTED 0x04

  /** Bit mask representing capability supported for the loaded driver
   * look for below bitmasks for the supported capablity.
   * LOWI_NO_SCAN_SUPPORTED,LOWI_LP_SCAN_SUPPORTED,
   * LOWI_DISCOVERY_SCAN_SUPPORTED,LOWI_RANGING_SCAN_SUPPORTED
   * LOWI_BG_SCAN_SUPPORTED */
  uint32 supportedCapablities;

public:
  /**
   * Constructor
   */
  LOWICapabilities ();
};

/**
 * Response to the Capability Request
 */
class LOWICapabilityResponse : public LOWIResponse
{
private:
  LOWICapabilities mCapabilities;
  bool             mStatus;
public:
  /**
   * Constructor
   * @param uint32 requestId generated by the client for request
   * @param LOWICapabilities Capabilities object
   * @param bool true for success, false to indicate failure
   */
  LOWICapabilityResponse (uint32 requestId, LOWICapabilities capabilities, bool status);
  /** Destructor*/
  virtual ~LOWICapabilityResponse ();

  /**
   * Returns the response type
   * @return eResponseType Type of Response
   */
  virtual eResponseType getResponseType ();

  /**
   * Return the capabilities
   * @return LOWICapabilities
   */
  LOWICapabilities getCapabilities ();

  /**
   * Returns the status of the Request
   * @return bool true for success, false otherwise
   */
  bool getStatus ();

};

/**
 * Response to the Cache reset Request
 */
class LOWICacheResetResponse : public LOWIResponse
{
private:
  bool mCacheResetStatus;
public:
  /**
   * Constructor
   * @param uint32 requestId generated by the client for request
   * @param bool true for success, false to indicate failure
   */
  LOWICacheResetResponse (uint32 requestId, bool status);
  /** Destructor*/
  virtual ~LOWICacheResetResponse ();

  /**
   * Returns the response type
   * @return eResponseType Type of Response
   */
  virtual eResponseType getResponseType ();

  /**
   * Returns the status of the Request
   * @return bool true for success, false otherwise
   */
  bool getStatus ();
};

/**
 * Response to the Discovery Scan Request
 */
class LOWIDiscoveryScanResponse : public LOWIResponse
{
public:
  /** Response type*/
  enum eScanTypeResponse
  {
    WLAN_SCAN_TYPE_UNKNOWN = 0,
    WLAN_SCAN_TYPE_PASSIVE,
    WLAN_SCAN_TYPE_ACTIVE
  };

  /** This may be different than the requested ScanType,
   * since user may request active scan, but if there’s an ongoing
   * passive scan results, LOWI may give back those results.*/
  eScanTypeResponse       scanTypeResponse;
  /** Status of the scan */
  eScanStatus             scanStatus;
  /** Time at the end of scan – should be equal to the timestamp of the
   * latest measurement in this packet. If there are zero measurements,
   * timestamp is the time when the response from the driver is received.
   * In msec, since January 1, 1970 UTC
   */
  uint64                   timestamp;
  /** Dynamic array containing received ScanMeasurement*/
  vector <LOWIScanMeasurement*> scanMeasurements;

  /**
   * Constructor
   * @param uint32 Corresponding Request Id generated by the client for request
   */
  LOWIDiscoveryScanResponse (uint32 requestId);
  /** Destructor*/
  virtual ~LOWIDiscoveryScanResponse ();

  /**
   * Returns the response type
   * @return eResponseType type of Response
   */
  virtual eResponseType getResponseType ();
};

/**
 * Response to the Ranging scan Request
 */
class LOWIRangingScanResponse: public LOWIResponse
{
public:
  /** Status of the scan */
  eScanStatus             scanStatus;
  /** Dynamic array containing received ScanMeasurement*/
  vector <LOWIScanMeasurement*> scanMeasurements;

  /**
   * Constructor
   * @param uint32 Request Id generated by the client for Request
   */
  LOWIRangingScanResponse (uint32 requestId);
  /** Destructor*/
  virtual ~LOWIRangingScanResponse ();

  /**
   * Returns the response type
   * @return eResponseType type of Response
   */
  virtual eResponseType getResponseType ();
};

class LOWIAsyncDiscoveryScanResultResponse :
  public LOWIDiscoveryScanResponse
{
public:
    /**
     * Constructor
     * @param uint32 Corresponding Request Id generated
     *               by the client for request
     */
    LOWIAsyncDiscoveryScanResultResponse (uint32 requestId);
    /** Destructor*/
    virtual ~LOWIAsyncDiscoveryScanResultResponse ();

    /**
     * Returns the response type
     * @return eResponseType type of Response
     */
    virtual eResponseType getResponseType ();
};

/** Status response from the wifi driver to a given
 *  background scan request (bgscan, hotlist, etc).
 */
class LOWIStatusResponse : public LOWIResponse
{
public:
  /** Status returned by lower layer */
  eScanStatus scanStatus;

  /** Request type for which this is a status response */
  LOWIRequest::eRequestType mRequestType;

  /**
   * Constructor
   * @param uint32 Corresponding Request Id generated
   *               by the client for request
   */
  LOWIStatusResponse(uint32 requestId);
  /** Destructor*/
  ~LOWIStatusResponse();

  /**
   * Returns the response type
   * @return eResponseType: type of response
   */
  virtual eResponseType getResponseType();
};

} // namespace qc_loc_fw

#endif //#ifndef __LOWI_RESPONSE_H__
