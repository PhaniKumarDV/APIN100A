From 47789b19d7646d1d9f4dab17e3339e1f07b8da37 Mon Sep 17 00:00:00 2001
From: Vinay Adella <vadella@qti.qualcomm.com>
Date: Sat, 12 Nov 2016 11:52:53 +0530
Subject: [PATCH] 10.4 Fulloffload Support.

Change-Id: I75a719c0436ed634fff4935d8c8bd0c6065dd37c
Signed-off-by: Vinay Adella <vadella@qti.qualcomm.com>
---
 apps/acfg/target/linux/Makefile                    |    6 +-
 apps/acfg/target/linux/acfgd_main.c                |    5 +-
 apps/bypass/host/linux/Makefile                    |    6 +-
 apps/bypass/host/linux/byp_lib.c                   |    3 +
 apps/bypass/target/linux/Makefile                  |    4 +-
 host/build/linux/Makefile                          |   31 +-
 host/build/linux/adf/Makefile                      |   23 +-
 host/build/linux/common.mk                         |   14 -
 host/build/linux/fw_loader/Makefile                |    1 +
 host/build/linux/fw_loader/gmac/Makefile           |   18 +-
 host/build/linux/fw_loader/mdio/Makefile           |   39 +
 host/build/linux/hif/gmac/Makefile                 |    4 +-
 host/build/linux/thin_driver/Makefile              |   18 +-
 host/fw_loader/gmac/fwd.c                          |   51 +-
 host/fw_loader/mdio/qca_mdio.c                     |   66 +
 host/hif/gmac/hif_gmac.c                           |   91 +-
 host/thin_driver/atd/atd_cfg.c                     | 1980 ++++++++-----------
 host/thin_driver/atd/atd_dev.c                     |  402 ++--
 host/thin_driver/atd/atd_internal.h                |   83 +-
 host/thin_driver/wmi/wmi.c                         |    2 +-
 include/atd_cmd.h                                  |  901 +--------
 include/atd_wsupp_msg.h                            |    1 +
 include/band_steering.h                            |  403 ----
 include/wmi.h                                      |    2 +-
 .../build/partner-platform/thin_driver/Makefile    |    3 -
 target/linux/build/wasp/Makefile                   |   13 +-
 target/linux/build/wasp/hif_gmac/Makefile          |    5 +-
 target/linux/build/wasp/misc/Makefile              |    2 +-
 target/linux/build/wasp/thin_driver/Makefile       |   27 +-
 target/linux/hif/gmac/hif_gmac.c                   |    8 +
 target/linux/thin_driver/atd/atd_appbr.c           |    4 +
 target/linux/thin_driver/atd/atd_byp.c             |    4 +
 target/linux/thin_driver/atd/atd_cfg.c             | 2027 +++++++++-----------
 target/linux/thin_driver/atd/atd_dev.c             |   35 +-
 target/linux/thin_driver/atd/atd_internal.h        |    4 +-
 target/linux/thin_driver/atd/atd_netlink.c         |    4 +
 target/linux/thin_driver/atd/atd_wsupp.c           |    4 +
 target/linux/thin_driver/htc/htc.c                 |    1 +
 38 files changed, 2312 insertions(+), 3983 deletions(-)
 mode change 100644 => 100755 host/build/linux/Makefile
 mode change 100644 => 100755 host/build/linux/fw_loader/Makefile
 mode change 100644 => 100755 host/build/linux/fw_loader/gmac/Makefile
 create mode 100755 host/build/linux/fw_loader/mdio/Makefile
 mode change 100644 => 100755 host/fw_loader/gmac/fwd.c
 create mode 100755 host/fw_loader/mdio/qca_mdio.c
 mode change 100644 => 100755 host/hif/gmac/hif_gmac.c
 delete mode 100644 include/band_steering.h

diff --git a/apps/acfg/target/linux/Makefile b/apps/acfg/target/linux/Makefile
index 3de3425..f673018 100644
--- a/apps/acfg/target/linux/Makefile
+++ b/apps/acfg/target/linux/Makefile
@@ -1,5 +1,5 @@
-CFLAGS += -I$(PWD)/../../../../../wlan_modules/include
 CFLAGS += -I$(PWD)/../../include
+CFLAGS += -I$(PWD)/../../../include
 CFLAGS += -I$(PWD)
 CFLAGS += -MMD
 CFLAGS += -Wall -g
@@ -20,9 +20,9 @@ export LIB_OUT ACFGD_BINARY
 
 all: clean build install
 
-build: $(OBJS)    
+build: $(OBJS)
 	$(CC) -Wall $(CFLAGS) $(FILES) -o $(ACFGD_BINARY) && \
-    $(AR) $(LIB_TYPE) $(LIB_OUT) $(OBJS) 
+    $(AR) $(LIB_TYPE) $(LIB_OUT) $(OBJS)
 
 install:
 	cp -f $(ACFGD_BINARY) $(DESTDIR)/sbin/.
diff --git a/apps/acfg/target/linux/acfgd_main.c b/apps/acfg/target/linux/acfgd_main.c
index 4c8400b..b6252db 100644
--- a/apps/acfg/target/linux/acfgd_main.c
+++ b/apps/acfg/target/linux/acfgd_main.c
@@ -15,9 +15,10 @@
  */
 #include <stdio.h>
 #include <stdlib.h>
-#include <acfg_api_types.h>
-#include <appbr_types.h>
+
+#include <sys/socket.h>
 #include <appbr_if.h>
+#include <appbr_types.h>
 #include <acfgd_rplay.h>
 
 a_uint8_t recv_cmd[ACFG_DL_MAX_CMDSZ];
diff --git a/apps/bypass/host/linux/Makefile b/apps/bypass/host/linux/Makefile
index 05bafe6..4c4a89a 100644
--- a/apps/bypass/host/linux/Makefile
+++ b/apps/bypass/host/linux/Makefile
@@ -1,5 +1,5 @@
 CFLAGS += -I$(PWD)/../../include
-CFLAGS += -I$(PWD)/../../../../../wlan_modules/include
+CFLAGS += -I$(PWD)/../../../include
 CFLAGS += -I$(PWD)
 CFLAGS += -MMD
 CFLAGS += -Wall -g
@@ -15,7 +15,7 @@ LIBRARY_PATH=$(PWD)/../../../../../../apps/acfg/src/
 
 FILES=$(shell ls *.c)
 OBJS=$(patsubst %.c,%.o,$(FILES))
-LIBOBJS=byp_lib.o 
+LIBOBJS=byp_lib.o
 
 %.o: %.c
 	$(CC) -c $(CFLAGS) $< -o $@
@@ -24,7 +24,7 @@ export LIB_OUT BYP_BINARY
 
 all: clean build install
 
-build: $(OBJS) lib   
+build: $(OBJS) lib
 	$(CC) $(CFLAGS) $(FILES) -o $(BYP_BINARY) -L$(LIBRARY_PATH) -l$(ACFG_LIB)
 
 lib: $(LIBOBJS)
diff --git a/apps/bypass/host/linux/byp_lib.c b/apps/bypass/host/linux/byp_lib.c
index 5ff914d..3642459 100644
--- a/apps/bypass/host/linux/byp_lib.c
+++ b/apps/bypass/host/linux/byp_lib.c
@@ -16,6 +16,9 @@
 
 #include <string.h> 
 
+#include <stdlib.h>
+#include <bypass_types.h>
+
 #include <appbr_if.h>
 #include <byp_lib.h>
 
diff --git a/apps/bypass/target/linux/Makefile b/apps/bypass/target/linux/Makefile
index 59a1073..2588422 100644
--- a/apps/bypass/target/linux/Makefile
+++ b/apps/bypass/target/linux/Makefile
@@ -1,5 +1,5 @@
-CFLAGS += -I$(PWD)/../../../../../wlan_modules/include
 CFLAGS += -I$(PWD)/../../include
+CFLAGS += -I$(PWD)/../../../include
 CFLAGS += -I$(PWD)
 CFLAGS += -MMD
 CFLAGS += -Wall -g
@@ -27,7 +27,7 @@ export LIB_OUT BYP_BINARY
 
 all: clean build install
 
-build: $(OBJS)    
+build: $(OBJS)
 	$(CC) -Wall $(CFLAGS) $(FILES) -L$(ACFG_LIB_PATH) -l$(ACFG_LIB) -o $(BYP_BINARY)
 
 install:
diff --git a/host/build/linux/Makefile b/host/build/linux/Makefile
old mode 100644
new mode 100755
index f0a87d7..3fe217b
--- a/host/build/linux/Makefile
+++ b/host/build/linux/Makefile
@@ -4,6 +4,8 @@
 # Qualcomm Atheros Confidential and Proprietary.
 #
 
+PWD             = $(shell pwd)
+
 ASF_DIR  = ../../../../asf
 HOST_PATH = ../../
 ADF_PATH = ../../../../adf/
@@ -17,8 +19,10 @@ ifeq ($(strip $(OFFLOAD_CFG)),)
 OFFLOAD_CFG=default
 endif
 
-include $(PWD)/Kbuild.$(OFFLOAD_CFG)
-
+obj-m  +=  adf/
+obj-m  +=  hif/
+obj-m  +=  thin_driver/
+obj-m  +=  fw_loader/
 
 define cleanup_files
 	@find $(1) -type f -name "*.ko" -exec rm -vf {} ';';
@@ -27,7 +31,7 @@ define cleanup_files
 	@find $(1) -type f -name "modules.order" -exec rm -vf {} ';';
 endef
 
-	
+
 EXTRA_CFLAGS	+= -I$(PWD)/$(ASF_DIR)/include/
 
 ifeq (${DRIVERS_WLAN_INC},)
@@ -37,26 +41,29 @@ EXTRA_CFLAGS 		+= -I$(DRIVERS_WLAN_INC)
 endif
 
 ifeq ($(KERNELRELEASE),)
-KERNELVER   ?= $(shell uname -r)
-ifeq ($(BUILD_X86),y)
-KERNELPATH  = /lib/modules/$(KERNELVER)/build/
-else
-KERNELPATH  ?= /lib/modules/$(KERNELVER)/build/
-endif
-PWD	     	?= $(shell pwd)
+
 OFFLOAD_MOD ?= $(DESTDIR)/lib/modules/$(KERNELVER)/offload/
 
 CC			= $(TOOLPREFIX)gcc 
 
+export AH_OFFLOAD_CALDATA_FROM_HOST=1
+export AH_OFFLOAD_RADIOS_AHB=1
+export AH_OFFLOAD_RADIOS_AHB_CALDATA_ADDR=0x83ff8000
+export AH_OFFLOAD_RADIOS_PCI=1
+export AH_OFFLOAD_RADIOS_PCI_CALDATA_ADDR=0x83ffc000
+export AH_OFFLOAD_CALDATA_LOCATION_ON_HOST=0x1000
+
+
 all:
-	$(MAKE) -C $(KERNELPATH) SUBDIRS=$(PWD) BOOT=rom HIF=$(BUS) AH_OFFLOAD_CALDATA_FROM_HOST=$(AH_OFFLOAD_CALDATA_FROM_HOST) AH_OFFLOAD_RADIOS_AHB=$(AH_OFFLOAD_RADIOS_AHB) AH_OFFLOAD_RADIOS_PCI=$(AH_OFFLOAD_RADIOS_PCI) AH_OFFLOAD_RADIOS_AHB_CALDATA_ADDR=$(AH_OFFLOAD_RADIOS_AHB_CALDATA_ADDR) AH_OFFLOAD_RADIOS_PCI_CALDATA_ADDR=$(AH_OFFLOAD_RADIOS_PCI_CALDATA_ADDR) AH_OFFLOAD_CALDATA_LOCATION_ON_HOST=$(AH_OFFLOAD_CALDATA_LOCATION_ON_HOST) AH_OFFLOAD_TGT_FIRMWARE_STATIC_LINK=$(AH_OFFLOAD_TGT_FIRMWARE_STATIC_LINK) modules 
+	$(MAKE) -C $(KERNELPATH) ARCH=$(ARCH) CROSS_COMPILE=$(TOOLPREFIX) SUBDIRS=$(PWD) BOOT=rom HIF=$(BUS) AH_OFFLOAD_CALDATA_FROM_HOST=$(AH_OFFLOAD_CALDATA_FROM_HOST) AH_OFFLOAD_RADIOS_AHB=$(AH_OFFLOAD_RADIOS_AHB) AH_OFFLOAD_RADIOS_PCI=$(AH_OFFLOAD_RADIOS_PCI) AH_OFFLOAD_RADIOS_AHB_CALDATA_ADDR=$(AH_OFFLOAD_RADIOS_AHB_CALDATA_ADDR) AH_OFFLOAD_RADIOS_PCI_CALDATA_ADDR=$(AH_OFFLOAD_RADIOS_PCI_CALDATA_ADDR) AH_OFFLOAD_CALDATA_MTDNUM_ON_HOST=$(AH_OFFLOAD_CALDATA_MTDNUM_ON_HOST) AH_OFFLOAD_CALDATA_LOCATION_ON_HOST=$(AH_OFFLOAD_CALDATA_LOCATION_ON_HOST) AH_OFFLOAD_TGT_FIRMWARE_STATIC_LINK=$(AH_OFFLOAD_TGT_FIRMWARE_STATIC_LINK) modules 
 
 clean:
 	$(MAKE) -C $(KERNELPATH) SUBDIRS=$(PWD) BOOT=rom HIF=$(BUS) clean
 	$(call cleanup_files,$(ADF_PATH))
 	$(call cleanup_files,$(HOST_PATH))
 flash:
-	$(MAKE) -C $(KERNELPATH) SUBDIRS=$(PWD) BOOT=flash HIF=$(BUS) modules
+	export WLAN_DRIVER_PATH=$(WLAN_DRIVER_PATH)
+	$(MAKE) -C $(KERNELPATH) ARCH=$(ARCH) CROSS_COMPILE=$(TOOLPREFIX) SUBDIRS=$(PWD) BOOT=flash HIF=$(BUS) modules
 
 flash_clean:
 	$(MAKE) -C $(KERNELPATH) SUBDIRS=$(PWD) BOOT=flash HIF=$(BUS) clean 
diff --git a/host/build/linux/adf/Makefile b/host/build/linux/adf/Makefile
index 7805d75..30c674b 100644
--- a/host/build/linux/adf/Makefile
+++ b/host/build/linux/adf/Makefile
@@ -1,5 +1,7 @@
-ROOT_DIR        =  ../../../../../../
-OFFLOAD_ADF_DIR = $(ROOT_DIR)/drivers/adf
+PWD = $(SUBDIRS)/adf
+
+ROOT_DIR        =  ../../../..
+OFFLOAD_ADF_DIR = $(ROOT_DIR)/adf
 
 
 OFFLOAD_ADF_INC     = ../../../../adf
@@ -16,14 +18,11 @@ EXTRA_CFLAGS    += -I$(PWD)/$(OFFLOAD_ADF_INC)/include/os
 EXTRA_CFLAGS    += -I$(PWD)/$(OFFLOAD_ADF_INC)/nbuf/linux
 EXTRA_CFLAGS    += -I$(PWD)/$(OFFLOAD_ADF_INC)/net/linux
 EXTRA_CFLAGS    += -I$(PWD)/$(OFFLOAD_ADF_INC)/os/linux
-EXTRA_CFLAGS	    += -I$(PWD)/$(ROOT_INC)/include
-EXTRA_CFLAGS	    += -I$(PWD)/$(ROOT_INC)/drivers/wlan_modules/include
+EXTRA_CFLAGS	+= -I$(PWD)/$(ROOT_INC)/include
+EXTRA_CFLAGS	+= -I$(WLAN_DRIVER_PATH)/include
+EXTRA_CFLAGS	+= -I$(WLAN_DRIVER_PATH)/os/linux/include
 
 EXTRA_CFLAGS+=        -Wno-unused-function
-#
-# Standard includes
-#
-include $(PWD)/common.mk
 
 #
 # ADF specific includes
@@ -55,10 +54,11 @@ adf$(MOD_SUFFIX)-objs	+=	$(OFFLOAD_ADF_DIR)/net/linux/adf_net.o
 adf$(MOD_SUFFIX)-objs	+=	$(OFFLOAD_ADF_DIR)/os/adf_os_lock.o
 adf$(MOD_SUFFIX)-objs	+=	$(OFFLOAD_ADF_DIR)/os/adf_os_mem.o
 adf$(MOD_SUFFIX)-objs	+=	$(OFFLOAD_ADF_DIR)/nbuf/linux/adf_nbuf.o
+adf$(MOD_SUFFIX)-objs	+=	$(OFFLOAD_ADF_DIR)/os/adf_os_fs.o
+adf$(MOD_SUFFIX)-objs	+=	$(OFFLOAD_ADF_DIR)/os/linux/adf_os_fs_pvt.o
 
 
-
-EXTRA_CFLAGS+= -DADF_NET_IOCTL_SUPPORT
+EXTRA_CFLAGS+= -DADF_NET_IOCTL_SUPPORT -DEXTERNAL_USE_ONLY -Wno-undef -D_BYTE_ORDER=BIG_ENDIAN -Wframe-larger-than=8192
 
 
 ###########################################
@@ -115,9 +115,6 @@ endif
 ifneq ($(strip ${ATH_SUPPORT_CFEND}),1)
 EXTRA_CFLAGS        += -DATH_SUPPORT_CFEND=0
 endif
-ifneq ($(strip ${UMAC_SUPPORT_VI_DBG}),1)
-EXTRA_CFLAGS        += -DUMAC_SUPPORT_VI_DBG=0
-endif
 ifneq ($(strip ${BIG_ENDIAN_HOST}),0)
 EXTRA_CFLAGS        += -DBIG_ENDIAN_HOST=1
 endif
diff --git a/host/build/linux/common.mk b/host/build/linux/common.mk
index 640291e..e69de29 100644
--- a/host/build/linux/common.mk
+++ b/host/build/linux/common.mk
@@ -1,14 +0,0 @@
-
-
-ifeq ($(strip $(ATH_SUPPORT_VOW_DCS)),1)
-EXTRA_CFLAGS    += -DATH_SUPPORT_VOW_DCS=1
-else
-EXTRA_CFLAGS    += -DATH_SUPPORT_VOW_DCS=0
-endif
-
-ifneq ($(strip ${LMAC_SUPPORT_POWERSAVE_QUEUE}),0)
-EXTRA_CFLAGS    += -DLMAC_SUPPORT_POWERSAVE_QUEUE=1
-else
-EXTRA_CFLAGS    += -DLMAC_SUPPORT_POWERSAVE_QUEUE=0
-endif
-
diff --git a/host/build/linux/fw_loader/Makefile b/host/build/linux/fw_loader/Makefile
old mode 100644
new mode 100755
index 9ceba8c..9c2f1fd
--- a/host/build/linux/fw_loader/Makefile
+++ b/host/build/linux/fw_loader/Makefile
@@ -1 +1,2 @@
 obj-m	+= $(HIF)/
+obj-m	+= mdio/
\ No newline at end of file
diff --git a/host/build/linux/fw_loader/gmac/Makefile b/host/build/linux/fw_loader/gmac/Makefile
old mode 100644
new mode 100755
index bece933..e7b4549
--- a/host/build/linux/fw_loader/gmac/Makefile
+++ b/host/build/linux/fw_loader/gmac/Makefile
@@ -1,19 +1,21 @@
+PWD = $(SUBDIRS)/fw_loader/gmac
+
 OFFLOAD_THIN	    =../../../thin_driver
 OFFLOAD_THIN_INC	=../../thin_driver
 OFFLOAD_FW_GMAC      =../../../../fw_loader/gmac
 
-OFFLOAD_ADF_INC     = ../../../../adf
+OFFLOAD_ADF_INC     = ../../../../../adf
 OFFLOAD_ASF_INC     = ../../../../../../asf
 OFFLOAD_STACK_INC   = ../../../../include
-OFFLOAD_DRV_INC     = ../../../include
+OFFLOAD_DRV_INC     = $(WLAN_DRIVER_PATH)/include
 OFFLOAD_HST_INC     = ../../include
-OFFLOAD_HIF_INC     = ../../hif/gmac
+OFFLOAD_HIF_INC     = ../../../../hif/gmac
 
 EXTRA_CFLAGS	    += -I$(PWD)/$(OFFLOAD_STACK_INC)
-EXTRA_CFLAGS	    += -I$(PWD)/$(OFFLOAD_DRV_INC)
+EXTRA_CFLAGS	    += -I$(OFFLOAD_DRV_INC)
 EXTRA_CFLAGS	    += -I$(PWD)/$(OFFLOAD_HST_INC)
 
-	
+
 EXTRA_CFLAGS    += -I$(PWD)/$(OFFLOAD_ADF_INC)/include/
 EXTRA_CFLAGS    += -I$(PWD)/$(OFFLOAD_ADF_INC)/include/nbuf
 EXTRA_CFLAGS    += -I$(PWD)/$(OFFLOAD_ADF_INC)/include/net
@@ -30,17 +32,19 @@ EXTRA_CFLAGS        += -I$(PWD)/$(OFFLOAD_THIN_INC)/atd/
 
 EXTRA_CFLAGS        += -I$(PWD)/$(OFFLOAD_HIF_INC)/linux
 
+
 obj-m				+= fwd.o
 fwd-objs	        := $(OFFLOAD_FW_GMAC)/fwd.o
 
 ifeq  ($(strip $(OFFLOAD_TGT_RECOVERY)),1)
-EXTRA_CFLAGS        += -DOFFLOAD_TGT_RECOVERY    
+EXTRA_CFLAGS        += -DOFFLOAD_TGT_RECOVERY
 endif
 
 ifeq ($(BOOT),rom)
-EXTRA_CFLAGS        += -DROM_MODE    
+EXTRA_CFLAGS        += -DROM_MODE
 
 ifeq  ($(strip $(AH_OFFLOAD_CALDATA_FROM_HOST)),1)
+EXTRA_CFLAGS += -DAH_OFFLOAD_CALDATA_MTDNUM_ON_HOST=$(AH_OFFLOAD_CALDATA_MTDNUM_ON_HOST)
 EXTRA_CFLAGS += -DAH_OFFLOAD_CALDATA_LOCATION_ON_HOST=$(AH_OFFLOAD_CALDATA_LOCATION_ON_HOST)
 EXTRA_CFLAGS += -DAH_OFFLOAD_CALDATA_FROM_HOST
 ifeq ($(strip $(AH_OFFLOAD_RADIOS_AHB)),1)
diff --git a/host/build/linux/fw_loader/mdio/Makefile b/host/build/linux/fw_loader/mdio/Makefile
new file mode 100755
index 0000000..6d4a00a
--- /dev/null
+++ b/host/build/linux/fw_loader/mdio/Makefile
@@ -0,0 +1,39 @@
+PWD = $(SUBDIRS)/fw_loader/mdio
+
+OFFLOAD_THIN	    =../../../thin_driver
+OFFLOAD_THIN_INC	=../../thin_driver
+OFFLOAD_FW_MDIO      =../../../../fw_loader/mdio
+
+OFFLOAD_ADF_INC     = ../../../../../adf
+OFFLOAD_ASF_INC     = ../../../../../../asf
+OFFLOAD_STACK_INC   = ../../../../include
+OFFLOAD_DRV_INC     = $(WLAN_DRIVER_PATH)/include
+OFFLOAD_HST_INC     = ../../include
+OFFLOAD_HIF_INC     = ../../../../hif/gmac
+
+EXTRA_CFLAGS	    += -I$(PWD)/$(OFFLOAD_STACK_INC)
+EXTRA_CFLAGS	    += -I$(OFFLOAD_DRV_INC)
+EXTRA_CFLAGS	    += -I$(PWD)/$(OFFLOAD_HST_INC)
+
+
+EXTRA_CFLAGS    += -I$(PWD)/$(OFFLOAD_ADF_INC)/include/
+EXTRA_CFLAGS    += -I$(PWD)/$(OFFLOAD_ADF_INC)/include/nbuf
+EXTRA_CFLAGS    += -I$(PWD)/$(OFFLOAD_ADF_INC)/include/net
+EXTRA_CFLAGS    += -I$(PWD)/$(OFFLOAD_ADF_INC)/include/os
+EXTRA_CFLAGS    += -I$(PWD)/$(OFFLOAD_ADF_INC)/nbuf/linux
+EXTRA_CFLAGS    += -I$(PWD)/$(OFFLOAD_ADF_INC)/net/linux
+EXTRA_CFLAGS    += -I$(PWD)/$(OFFLOAD_ADF_INC)/os/linux
+
+
+
+EXTRA_CFLAGS        += -I$(PWD)/$(OFFLOAD_THIN_INC)/wmi/
+EXTRA_CFLAGS        += -I$(PWD)/$(OFFLOAD_THIN_INC)/htc/
+EXTRA_CFLAGS        += -I$(PWD)/$(OFFLOAD_THIN_INC)/atd/
+
+EXTRA_CFLAGS        += -I$(PWD)/$(OFFLOAD_HIF_INC)/linux
+
+
+obj-m				+= mdio.o
+mdio-objs	        := $(OFFLOAD_FW_MDIO)/qca_mdio.o
+
+
diff --git a/host/build/linux/hif/gmac/Makefile b/host/build/linux/hif/gmac/Makefile
index 5eaf39a..a6517f5 100644
--- a/host/build/linux/hif/gmac/Makefile
+++ b/host/build/linux/hif/gmac/Makefile
@@ -1,8 +1,10 @@
+PWD = $(SUBDIRS)/hif/gmac
+
 OFFLOAD_GMAC	    = ../../../../hif/gmac
 
 OFFLOAD_ADF_INC     = ../../../../../../adf
 OFFLOAD_STACK_INC   = ../../../../include
-OFFLOAD_GMAC_INC    = ../../hif/gmac
+OFFLOAD_GMAC_INC    = ../../../../hif/gmac
 
 EXTRA_CFLAGS    += -I$(PWD)/$(OFFLOAD_STACK_INC)
 EXTRA_CFLAGS    += -I$(PWD)/$(OFFLOAD_ADF_INC)
diff --git a/host/build/linux/thin_driver/Makefile b/host/build/linux/thin_driver/Makefile
index 01411e1..8a77d49 100644
--- a/host/build/linux/thin_driver/Makefile
+++ b/host/build/linux/thin_driver/Makefile
@@ -1,16 +1,18 @@
+PWD = $(SUBDIRS)/thin_driver
+
 OFFLOAD_THIN	    =../../../thin_driver
-OFFLOAD_THIN_INC	=../../thin_driver
+OFFLOAD_THIN_INC    =../../../thin_driver
 
 FULL_OFFLOAD        = ../../../../full_offload
 OFFLOAD_ADF_INC     = ../../../../adf
 OFFLOAD_ASF_INC     = ../../../../asf
 OFFLOAD_STACK_INC   = ../../../../include
-OFFLOAD_DRV_INC     = ../../../include
+OFFLOAD_DRV_INC     = $(WLAN_DRIVER_PATH)/include
 OFFLOAD_HST_INC     = ../../include
-OFFLOAD_HIF_INC     = ../../hif/$(HIF)
+OFFLOAD_HIF_INC     = ../../../hif/$(HIF)
 
 EXTRA_CFLAGS	    += -I$(PWD)/$(OFFLOAD_STACK_INC)
-EXTRA_CFLAGS	    += -I$(PWD)/$(OFFLOAD_DRV_INC)
+EXTRA_CFLAGS	    += -I$(OFFLOAD_DRV_INC)
 EXTRA_CFLAGS	    += -I$(PWD)/$(OFFLOAD_HST_INC)
 
 EXTRA_CFLAGS        += -I$(PWD)/$(OFFLOAD_ASF_INC)
@@ -38,6 +40,7 @@ EXTRA_CFLAGS        += -I$(PWD)/$(OFFLOAD_HIF_INC)/linux
 EXTRA_CFLAGS        += -I$(PWD)/$(OFFLOAD_HIF_INC)
 
 EXTRA_CFLAGS        += -I$(PWD)/../../../../wlan_modules/include
+EXTRA_CFLAGS        += -I$(PWD)/../../../../wlan_modules/os/linux/include
 
 ifneq ($(strip ${ATH_SUPPORT_TxBF}),0)
 EXTRA_CFLAGS        += -DATH_SUPPORT_TxBF=1
@@ -54,9 +57,6 @@ endif
 ifneq ($(strip ${ATH_SUPPORT_CFEND}),1)
 EXTRA_CFLAGS        += -DATH_SUPPORT_CFEND=0
 endif
-ifneq ($(strip ${UMAC_SUPPORT_VI_DBG}),1)
-EXTRA_CFLAGS        += -DUMAC_SUPPORT_VI_DBG=0
-endif
 ifneq ($(strip ${BIG_ENDIAN_HOST}),0)
 EXTRA_CFLAGS        += -DBIG_ENDIAN_HOST=1
 endif
@@ -65,10 +65,12 @@ EXTRA_CFLAGS        += -DATH_RX_LOOPLIMIT_TIMER=0
 endif
 
 EXTRA_CFLAGS        += -DATD_DEBUG_ENABLE=1
-EXTRA_CFLAGS        += -Werror
+EXTRA_CFLAGS        += -Werror -Wno-undef -g
 
 EXTRA_CFLAGS        += -DWMI_RETRY=1
 
+EXTRA_CFLAGS        += -Wframe-larger-than=4096
+
 ifeq ($(MOD_SUFFIX),_offload)
 EXTRA_CFLAGS += -D'MODULE_SYMBOL_PREFIX="offload_"' 
 endif
diff --git a/host/fw_loader/gmac/fwd.c b/host/fw_loader/gmac/fwd.c
old mode 100644
new mode 100755
index 6603aff..09000ab
--- a/host/fw_loader/gmac/fwd.c
+++ b/host/fw_loader/gmac/fwd.c
@@ -25,6 +25,7 @@
 #include <adf_net_types.h>
 #include <adf_nbuf.h>
 #include <adf_os_io.h>
+#include <adf_os_fs.h>
 
 #include "fwd.h"
 
@@ -32,6 +33,8 @@
 #include <linux/firmware.h>
 #endif
 
+#define DEBUG_FW2_ADDR
+
 #ifdef ROM_MODE
 #define MDIO_BOOT_LOAD
 #endif
@@ -91,7 +94,7 @@ hif_gmac_params_t   fwd_params = {{0}};
 #define ACT_PHY                 2
 
 char           *mac_addr = NULL;
-char           *mii_type = "sgmii";
+char           *mii_type = "rgmii";
 a_uint8_t       link_speed = 0;
 a_uint8_t       chip_type  = 0;
 a_uint16_t      rgmii_delay = 0;
@@ -143,9 +146,16 @@ MODULE_PARM_DESC(tgt_if, "Interface used to connect target ");
 
 #define TGT_STAGE1_FW_LOCATION	            (0xbd004000)
 #define TGT_RGMII_STAGE1_FW_LOCATION	    (0xbd003000)
-#define TGT_STAGE2_FW_LOCATION              (0x81400000)
+#define TGT_STAGE2_FW_LOCATION              (0xa1400000)
+
 
-static a_uint32_t host_flash_mem_io_addr[2]= {0, 0}; /* save ioremap addresses for unmap when unloading */
+/*sometimes the exec address is not equal to link address*/
+#ifdef DEBUG_FW2_ADDR
+#define TGT_STAGE2_FW_EXEC_OFFSET 0
+#else
+#define TGT_STAGE2_FW_EXEC_OFFSET (0x00000000)
+#endif
+#define TGT_STAGE2_FW_EXEC_ADDR (TGT_STAGE2_FW_LOCATION + TGT_STAGE2_FW_EXEC_OFFSET)
 
 #ifdef AH_OFFLOAD_TGT_FIRMWARE_STATIC_LINK
 extern const unsigned long waspRomInitFw[]; 
@@ -160,14 +170,18 @@ const struct firmware *tgt_firmware;
 #endif
 
 #ifdef AH_OFFLOAD_CALDATA_FROM_HOST
+
 /* calculate the image checksum and send it to the target for verification */
 unsigned int calculate_image_cksum(unsigned int *image, unsigned int size)
 {
         unsigned int i, checksum = 0;
 
-        for (i = 0; i < size; i += 4, image++)
-                checksum = checksum ^ *image;
-
+        for (i = 0; i < size; i += 4, image++) {
+			checksum = checksum ^ *image;
+			//adf_os_print("(%08x):%08x\n", image, *image);
+		}
+		adf_os_print("checksum=%08x\n", checksum);
+	
 	return checksum;
 }
 
@@ -175,20 +189,14 @@ unsigned int calculate_image_cksum(unsigned int *image, unsigned int size)
  * this function assumes host perminent memory that contains caldata can be memory mapped.
  * validation of data depends on the validation method implemented. (could be checksum).
  */
-static int read_and_verify_caldata(unsigned int address, unsigned int *buffer, unsigned int size)
+static int read_and_verify_caldata(unsigned int address, unsigned int *buffer, unsigned int *size)
 {
-   unsigned char *io_addr = NULL;
-
-   io_addr = adf_os_ioremap(address, size);
-   if(io_addr == NULL) {
-       adf_os_print("can't map address 0x%x\n", (unsigned int)address);
-       return -1;
-   }
-
-   /* read data from flash */
-   adf_os_mem_copy(buffer, io_addr, size);
-
-   return 0; 
+    if(address==AH_OFFLOAD_CALDATA_LOCATION_ON_HOST) {
+        return adf_os_fs_read("/tmp/wifi0.caldata", 0, size, buffer);
+    } else {
+        return adf_os_fs_read("/tmp/wifi1.caldata", 0, size, buffer);
+    }
+    return 0;
 }
 #endif
 
@@ -479,7 +487,7 @@ a_status_t fwd_tgt_rf_calib_data_download(hif_handle_t hif, int card_num)
     adf_os_mem_set(caldata_buf, 0, caldata_size);
 
     caldata_address = AH_OFFLOAD_CALDATA_LOCATION_ON_HOST + (card_num * WLAN_CALDATA_SIZE_PER_CARD); 
-    if(read_and_verify_caldata(caldata_address, caldata_buf, caldata_size) < 0) {
+    if(read_and_verify_caldata(caldata_address, caldata_buf, &caldata_size) < 0) {
        adf_os_print(" Not able to read caldata from from flash\n");
        adf_os_mem_free(caldata_buf);
        adf_os_mem_free(sc);
@@ -584,7 +592,7 @@ a_status_t fwd_tgt_firmware_download(hif_handle_t hif)
 #endif
 
     sc->target_upload_addr = TGT_STAGE2_FW_LOCATION;
-    sc->target_image_exec_addr = TGT_STAGE2_FW_LOCATION;
+    sc->target_image_exec_addr = TGT_STAGE2_FW_EXEC_ADDR;
 
     fwd_cb.context = sc;
     fwd_cb.recv_buf = fwd_recv;
@@ -943,6 +951,7 @@ fwd_module_exit(void)
 adf_os_export_symbol(fwd_firmware_download);
 adf_os_export_symbol(fwd_bootfirmware_download);
 adf_os_virt_module_name(fwd);
+
 adf_os_virt_module_init(fwd_module_init);
 adf_os_virt_module_exit(fwd_module_exit);
 
diff --git a/host/fw_loader/mdio/qca_mdio.c b/host/fw_loader/mdio/qca_mdio.c
new file mode 100755
index 0000000..2e483ed
--- /dev/null
+++ b/host/fw_loader/mdio/qca_mdio.c
@@ -0,0 +1,66 @@
+#include <adf_os_types.h>
+#include <adf_os_module.h>
+#include <linux/device.h>
+
+extern struct bus_type platform_bus_type;
+extern int mdiobus_write(struct mii_bus *bus, int addr, u32 reg, u16 val);
+extern int mdiobus_read(struct mii_bus *bus, int addr, u32 reg);
+extern struct mii_bus *gmac_mii_get(int unit);
+static struct mii_bus *miibus = NULL;
+
+
+#define ATH_MDIO_PHY_ADDR       0x7
+#define MII_ADDR_SHIFT          8
+#define MII_ADDR_HI(reg)        ((((reg)|(ATH_MDIO_PHY_ADDR << MII_ADDR_SHIFT)) \
+                                                >>MII_ADDR_SHIFT)& 0xff)
+#define MII_ADDR_LO(reg)        ((reg)&0xff)
+
+int 
+mdio_reg_read (int unit, int reg) 
+{
+    return mdiobus_read(miibus, MII_ADDR_HI(reg), MII_ADDR_LO(reg));
+}
+
+int
+mdio_reg_write(int unit, int reg, int val) 
+{
+    return mdiobus_write(miibus, MII_ADDR_HI(reg), MII_ADDR_LO(reg), val);
+}
+
+int 
+mdio_boot_init(int unit) 
+{
+    if((miibus = gmac_mii_get(unit)) == NULL ){
+        printk("gmac_mii_get fail \n");
+        return -1;
+    }
+
+    mdio_reg_write(0, 0x700, 2);
+    printk("[%s]:ATH_MDIO_PHY_ADDR:%d mdio_reg_read(%x)= %x \n",\
+           __func__, ATH_MDIO_PHY_ADDR, 0x700, mdio_reg_read(0, 0x700));
+
+    return 0; 
+}
+
+EXPORT_SYMBOL(mdio_boot_init);
+EXPORT_SYMBOL(mdio_reg_read);
+EXPORT_SYMBOL(mdio_reg_write);
+
+
+int mdio_module_init(void)
+{
+    adf_os_print("mdio init\n");
+
+    return A_STATUS_OK;
+}
+
+void
+mdio_module_exit(void) 
+{
+    adf_os_print("mdio exit\n");
+}
+
+adf_os_virt_module_init(mdio_module_init);
+adf_os_virt_module_exit(mdio_module_exit);
+adf_os_virt_module_name(qca_mdio);
+
diff --git a/host/hif/gmac/hif_gmac.c b/host/hif/gmac/hif_gmac.c
old mode 100644
new mode 100755
index 89e67d6..34595af
--- a/host/hif/gmac/hif_gmac.c
+++ b/host/hif/gmac/hif_gmac.c
@@ -28,6 +28,8 @@
 
 #include <asm/byteorder.h>
 
+#define QCA_FLO 1
+
 #ifdef ROM_MODE
 #define MDIO_BOOT_LOAD
 #endif
@@ -46,14 +48,15 @@
 #define ATH_P_RESET             0x18
 #define ATH_P_DBGLOG            0x20 /*Debug Log Packet*/
 
-#define gmac_trc(x, y)          
+#define gmac_trc(x, y)
 #define dump_mac(x)             
 
 int gmac_dbg_mask = 0x0;
 a_uint32_t hif_tgt_pwrdown = 0x0;
 static char *tgt_if = "eth0";
-
 struct gmac_softc ;
+a_uint32_t rom_mode = 0x1;
+EXPORT_SYMBOL(rom_mode);
 
 int __gmac_dev_event(struct notifier_block *nb, unsigned long event, 
                      void *dev);
@@ -472,6 +475,9 @@ hif_status_t
 hif_cleanup(hif_handle_t  hif_handle)
 {
     gmac_softc_t *sc = (gmac_softc_t *)hif_handle;
+#ifdef QCA_FLO
+	gmac_node_t* node = &sc->node;
+#endif
 
     gmac_trc(GMAC_FUNCTRACE,("GMAC.Start"));
    
@@ -479,6 +485,20 @@ hif_cleanup(hif_handle_t  hif_handle)
     if(!hif_tgt_pwrdown)
         hif_target_reset(sc);
 
+#ifdef QCA_FLO
+	cancel_work_sync(&node->defer_work);
+    if (rom_mode) {
+#ifdef MDIO_BOOT_LOAD
+        cancel_work_sync(&node->disconnect_work);
+
+#ifdef OFFLOAD_TGT_RECOVERY
+        cancel_work_sync(&node->tgt_reset_work);
+#endif
+#endif
+       }
+#endif
+
+    if (rom_mode) {
 #ifdef MDIO_BOOT_LOAD
 #ifdef OFFLOAD_TGT_RECOVERY
     /* Don't remove gmac handles on cleanup. do it on module exit */
@@ -486,13 +506,14 @@ hif_cleanup(hif_handle_t  hif_handle)
     /* start a HIF Timer to start the download again */
     gmac_start_tgt_reboot_timer(sc); 
 #endif
-#else
-    dev_remove_pack(&__gmac_pkt);
-    unregister_netdevice_notifier(&__gmac_notifier);
-    if(sc != NULL)
-       kfree(sc);
-    glbl_hif_handle = NULL;
 #endif
+   } else {
+        dev_remove_pack(&__gmac_pkt);
+        unregister_netdevice_notifier(&__gmac_notifier);
+        if(sc != NULL)
+           kfree(sc);
+        glbl_hif_handle = NULL;
+   }
 
     gmac_trc(GMAC_FUNCTRACE,("GMAC.End"));
 
@@ -531,18 +552,20 @@ hif_start(hif_handle_t hif_handle)
 {
     hif_status_t status = HIF_STATUS_OK;
 
+    if (rom_mode) {
 #ifdef MDIO_BOOT_LOAD
-    gmac_softc_t *sc = (gmac_softc_t *) hif_handle;
-    gmac_node_t *node = &sc->node;
+        gmac_softc_t *sc = (gmac_softc_t *) hif_handle;
+        gmac_node_t *node = &sc->node;
 
-    INIT_WORK(&node->disconnect_work, gmac_defer_disconnect);
+        INIT_WORK(&node->disconnect_work, gmac_defer_disconnect);
 
 #ifdef OFFLOAD_TGT_RECOVERY
-    /*to take care of firmware download in case of target reboot*/
-    INIT_WORK(&node->tgt_reset_work, tgt_recovery_bootinit);
-    gmac_start_tgt_poll_timer(sc);
+        /*to take care of firmware download in case of target reboot*/
+        INIT_WORK(&node->tgt_reset_work, tgt_recovery_bootinit);
+        gmac_start_tgt_poll_timer(sc);
 #endif
 #endif
+    }
 
     return status;
 }
@@ -970,6 +993,44 @@ hif_send_dbglog(hif_handle_t hif_handle ,a_uint32_t pipeid , struct sk_buff * sk
     return HIF_STATUS_OK;
 }
 
+#ifdef QCA_FLO
+struct ag71xx_mdio {
+#define PHY_MAX_ADDR        32
+    struct mii_bus *mii_bus;
+    int mii_irq[PHY_MAX_ADDR];
+    void __iomem *mdio_base;
+};
+
+extern struct bus_type platform_bus_type;
+
+struct mii_bus *
+gmac_mii_get(int unit)
+{
+#define MII_BUS_ID_SIZE     (20 - 3)
+    struct ag71xx_mdio *am;
+    struct device *miidev;
+    char busid[MII_BUS_ID_SIZE];
+    struct mii_bus *miibus = NULL;
+
+    snprintf(busid, MII_BUS_ID_SIZE, "%s.%d", "ag71xx-mdio", unit);
+    miidev = bus_find_device_by_name(&platform_bus_type, NULL, busid);
+    if (!miidev) {
+        printk("cannot get mii bus\n");
+        return NULL;
+    }
+
+    am = dev_get_drvdata(miidev);
+    miibus = am->mii_bus;
+    if(!miibus){
+        printk("mdio bus '%s' get FAIL\n", busid);
+        return NULL;
+    }
+
+    return miibus;
+}
+EXPORT_SYMBOL(gmac_mii_get);
+#endif
+
 int gmac_module_init(void )
 {
     hif_os_callback_t oscb;
@@ -1024,7 +1085,9 @@ module_init(gmac_module_init);
 module_exit(gmac_module_exit);
 module_param(hif_tgt_pwrdown, uint, 0);
 module_param(tgt_if, charp, 0600);
+module_param(rom_mode, uint, 0);
 MODULE_PARM_DESC(tgt_if, "Interface used to connect target ");
+MODULE_PARM_DESC(rom_mode, "1 for bootrom mode and 0 for flash mode ");
 MODULE_PARM_DESC(hif_tgt_pwrdown, "If enabled, target reset command is not issued while unloading ");
 
 
diff --git a/host/thin_driver/atd/atd_cfg.c b/host/thin_driver/atd/atd_cfg.c
index 38dcaeb..0f8eee5 100644
--- a/host/thin_driver/atd/atd_cfg.c
+++ b/host/thin_driver/atd/atd_cfg.c
@@ -5,7 +5,7 @@
  * purpose with or without fee is hereby granted, provided that the above
  * copyright notice and this permission notice appear in all copies.
  *
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOSCLAIMS ALL WARRANTIES
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
  * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
@@ -15,32 +15,31 @@
  */
 
 #include "atd_internal.h"
-#include <band_steering.h>
 
 static a_status_t atd_cfg_set_ssid(adf_drv_handle_t hdl, acfg_ssid_t  *ssid);
 static a_status_t atd_cfg_get_ssid(adf_drv_handle_t hdl, acfg_ssid_t  *ssid);
-static a_status_t atd_cfg_set_testmode(adf_drv_handle_t hdl, 
+static a_status_t atd_cfg_set_testmode(adf_drv_handle_t hdl,
                                        acfg_testmode_t  *testmode);
-static a_status_t atd_cfg_get_testmode(adf_drv_handle_t hdl, 
+static a_status_t atd_cfg_get_testmode(adf_drv_handle_t hdl,
                                        acfg_testmode_t  *testmode);
 static a_status_t atd_cfg_get_rssi(adf_drv_handle_t hdl, acfg_rssi_t  *rssi);
 static a_status_t atd_cfg_get_custdata(adf_drv_handle_t hdl, acfg_custdata_t  *custdata);
 static a_status_t atd_cfg_delete_vap(adf_drv_handle_t  hdl );
-static a_status_t atd_cfg_set_vap_param(adf_drv_handle_t hdl, 
+static a_status_t atd_cfg_set_vap_param(adf_drv_handle_t hdl,
                                         a_uint32_t param,  a_uint32_t value);
-static a_status_t atd_cfg_get_vap_param(adf_drv_handle_t hdl, 
+static a_status_t atd_cfg_get_vap_param(adf_drv_handle_t hdl,
                                         a_uint32_t param,  a_uint32_t *value);
 static a_status_t atd_cfg_set_vap_vendor_param(adf_drv_handle_t hdl, acfg_vendor_param_req_t *req);
 static a_status_t atd_cfg_get_vap_vendor_param(adf_drv_handle_t hdl, acfg_vendor_param_req_t *req);
 
-static a_status_t atd_cfg_set_wifi_param(adf_drv_handle_t hdl, 
+static a_status_t atd_cfg_set_wifi_param(adf_drv_handle_t hdl,
                                          a_uint32_t param, a_uint32_t value);
-static a_status_t atd_cfg_get_wifi_param(adf_drv_handle_t hdl, 
+static a_status_t atd_cfg_get_wifi_param(adf_drv_handle_t hdl,
                                          a_uint32_t param, a_uint32_t *value);
 a_status_t atd_cfg_get_opmode(adf_drv_handle_t  hdl, acfg_opmode_t  *mode);
 a_status_t atd_cfg_set_chmode(adf_drv_handle_t  hdl, acfg_chmode_t  *mode);
 a_status_t atd_cfg_get_chmode(adf_drv_handle_t hdl, acfg_chmode_t  *mode);
-static a_status_t atd_cfg_get_wireless_name(adf_drv_handle_t hdl, 
+static a_status_t atd_cfg_get_wireless_name(adf_drv_handle_t hdl,
                                            u_int8_t *name,  a_uint32_t maxlen);
 static a_status_t atd_cfg_set_ap(adf_drv_handle_t hdl, acfg_macaddr_t *mac);
 static a_status_t atd_cfg_get_ap(adf_drv_handle_t hdl, acfg_macaddr_t *mac);
@@ -48,11 +47,11 @@ static a_status_t atd_cfg_get_rate(adf_drv_handle_t hdl, a_uint32_t *rate);
 static a_status_t atd_cfg_set_powmgmt(adf_drv_handle_t hdl, acfg_powmgmt_t *pm);
 static a_status_t atd_cfg_get_powmgmt(adf_drv_handle_t hdl, acfg_powmgmt_t *pm);
 static a_status_t atd_cfg_set_scan(adf_drv_handle_t hdl, acfg_set_scan_t *scan);
-static a_status_t atd_cfg_get_scan_results(adf_drv_handle_t hdl, 
+static a_status_t atd_cfg_get_scan_results(adf_drv_handle_t hdl,
                                            acfg_scan_t *scan);
-static a_status_t atd_cfg_get_ath_stats(adf_drv_handle_t hdl, 
+static a_status_t atd_cfg_get_ath_stats(adf_drv_handle_t hdl,
                                            acfg_ath_stats_t *ath_stats);
-static a_status_t atd_cfg_clr_ath_stats(adf_drv_handle_t hdl, 
+static a_status_t atd_cfg_clr_ath_stats(adf_drv_handle_t hdl,
                                            acfg_ath_stats_t *ath_stats);
 static a_status_t atd_cfg_get_range(adf_drv_handle_t hdl, acfg_range_t *range);
 
@@ -66,98 +65,98 @@ static a_status_t atd_cfg_get_frag(adf_drv_handle_t hdl, acfg_frag_t *frag);
 static a_status_t atd_cfg_set_frag(adf_drv_handle_t hdl, acfg_frag_t *frag);
 static a_status_t atd_cfg_set_txpow(adf_drv_handle_t hdl, acfg_txpow_t *txpow);
 static a_status_t atd_cfg_get_txpow(adf_drv_handle_t hdl, acfg_txpow_t *txpow);
-static a_status_t atd_cfg_set_encode(adf_drv_handle_t hdl, 
+static a_status_t atd_cfg_set_encode(adf_drv_handle_t hdl,
                                      acfg_encode_t  *encode);
-static a_status_t atd_cfg_get_encode(adf_drv_handle_t hdl, 
+static a_status_t atd_cfg_get_encode(adf_drv_handle_t hdl,
                                      acfg_encode_t  *encode);
 static a_status_t atd_cfg_set_rate(adf_drv_handle_t hdl, acfg_rate_t  *rate);
 static a_status_t atd_cfg_get_stats(adf_drv_handle_t hdl, acfg_stats_t  *stat);
 
 static a_status_t atd_cfg_set_opmode(adf_drv_handle_t hdl, acfg_opmode_t mode);
-static a_status_t atd_cfg_set_phymode(adf_drv_handle_t  hdl, 
+static a_status_t atd_cfg_set_phymode(adf_drv_handle_t  hdl,
                                       acfg_phymode_t  mode);
-static a_status_t atd_cfg_get_phymode(adf_drv_handle_t  hdl, 
+static a_status_t atd_cfg_get_phymode(adf_drv_handle_t  hdl,
                                       acfg_phymode_t  *mode);
-static a_status_t atd_cfg_get_stainfo(adf_drv_handle_t hdl, a_uint8_t *buff, 
+static a_status_t atd_cfg_get_stainfo(adf_drv_handle_t hdl, a_uint8_t *buff,
                                a_uint32_t buflen);
-static a_status_t atd_cfg_tx99tool(adf_drv_handle_t hdl, 
+static a_status_t atd_cfg_tx99tool(adf_drv_handle_t hdl,
                                    acfg_tx99_t *tx99_wcmd);
 
-static a_status_t atd_cfg_set_reg(adf_drv_handle_t hdl, 
+static a_status_t atd_cfg_set_reg(adf_drv_handle_t hdl,
                                      a_uint32_t offset, a_uint32_t  value);
-static a_status_t atd_cfg_get_reg(adf_drv_handle_t hdl, 
+static a_status_t atd_cfg_get_reg(adf_drv_handle_t hdl,
                                      a_uint32_t offset, a_uint32_t *value);
 static a_status_t atd_cfg_set_hwaddr(adf_drv_handle_t hdl, acfg_macaddr_t *mac);
 
-static a_status_t atd_cfg_set_vap_wmmparams(adf_drv_handle_t hdl, 
+static a_status_t atd_cfg_set_vap_wmmparams(adf_drv_handle_t hdl,
                                         a_uint32_t *param,  a_uint32_t value);
 
-static a_status_t atd_cfg_get_vap_wmmparams(adf_drv_handle_t hdl, 
+static a_status_t atd_cfg_get_vap_wmmparams(adf_drv_handle_t hdl,
                                         a_uint32_t *param,  a_uint32_t *value);
 
-static a_status_t atd_cfg_nawds_config(adf_drv_handle_t hdl, 
+static a_status_t atd_cfg_nawds_config(adf_drv_handle_t hdl,
                                         acfg_nawds_cfg_t *nawds_config);
 
-static a_status_t atd_cfg_doth_chsw(adf_drv_handle_t hdl, 
+static a_status_t atd_cfg_doth_chsw(adf_drv_handle_t hdl,
                                         acfg_doth_chsw_t *chsw);
 
-static a_status_t atd_cfg_addmac(adf_drv_handle_t hdl, 
+static a_status_t atd_cfg_addmac(adf_drv_handle_t hdl,
                                         acfg_macaddr_t *addr);
 
-static a_status_t atd_cfg_delmac(adf_drv_handle_t hdl, 
+static a_status_t atd_cfg_delmac(adf_drv_handle_t hdl,
                                         acfg_macaddr_t *addr);
 
-static a_status_t atd_cfg_kickmac(adf_drv_handle_t hdl, 
+static a_status_t atd_cfg_kickmac(adf_drv_handle_t hdl,
                                         acfg_macaddr_t *addr);
 
-static a_status_t atd_cfg_set_mlme(adf_drv_handle_t hdl, 
+static a_status_t atd_cfg_set_mlme(adf_drv_handle_t hdl,
                                         acfg_mlme_t *mlme);
 
-static a_status_t atd_cfg_send_mgmt(adf_drv_handle_t hdl, 
+static a_status_t atd_cfg_send_mgmt(adf_drv_handle_t hdl,
                                         acfg_mgmt_t *addr);
 
-static a_status_t atd_cfg_set_optie(adf_drv_handle_t hdl, 
+static a_status_t atd_cfg_set_optie(adf_drv_handle_t hdl,
                                         acfg_ie_t *ie);
 
-static a_status_t atd_cfg_set_filterframe(adf_drv_handle_t hdl, 
+static a_status_t atd_cfg_set_filterframe(adf_drv_handle_t hdl,
                                         acfg_filter_t *filterframe);
 
-static a_status_t atd_cfg_set_acparams(adf_drv_handle_t hdl, 
+static a_status_t atd_cfg_set_acparams(adf_drv_handle_t hdl,
                                         a_uint32_t *ac);
 
 static a_status_t atd_cfg_dbgreq(adf_drv_handle_t hdl,
                                         acfg_athdbg_req_t *dbgreq);
-static a_status_t atd_cfg_get_wpa_ie(adf_drv_handle_t hdl, a_uint8_t *buff, 
+static a_status_t atd_cfg_get_wpa_ie(adf_drv_handle_t hdl, a_uint8_t *buff,
                                a_uint32_t buflen);
-static a_status_t atd_cfg_set_appiebuf(adf_drv_handle_t hdl, 
+static a_status_t atd_cfg_set_appiebuf(adf_drv_handle_t hdl,
                                         acfg_appie_t *addr);
 
-static a_status_t atd_cfg_set_key(adf_drv_handle_t hdl, 
+static a_status_t atd_cfg_set_key(adf_drv_handle_t hdl,
                                         acfg_key_t *addr);
-static a_status_t atd_cfg_del_key(adf_drv_handle_t hdl, 
+static a_status_t atd_cfg_del_key(adf_drv_handle_t hdl,
                                         acfg_delkey_t *addr);
-static a_status_t atd_cfg_get_key(adf_drv_handle_t hdl, a_uint8_t *buff, 
+static a_status_t atd_cfg_get_key(adf_drv_handle_t hdl, a_uint8_t *buff,
                                a_uint32_t buflen);
-static a_status_t atd_cfg_get_sta_stats(adf_drv_handle_t hdl, a_uint8_t *buff, 
+static a_status_t atd_cfg_get_sta_stats(adf_drv_handle_t hdl, a_uint8_t *buff,
                                a_uint32_t buflen);
 
-static a_status_t atd_cfg_get_chan_info(adf_drv_handle_t hdl, 
+static a_status_t atd_cfg_get_chan_info(adf_drv_handle_t hdl,
                                         acfg_chan_info_t *chan_info);
-static a_status_t atd_cfg_get_chan_list(adf_drv_handle_t hdl, 
+static a_status_t atd_cfg_get_chan_list(adf_drv_handle_t hdl,
                                         acfg_opaque_t *chan_list);
-static a_status_t atd_cfg_get_mac_address(adf_drv_handle_t hdl, 
+static a_status_t atd_cfg_get_mac_address(adf_drv_handle_t hdl,
                                         acfg_macacl_t *mac_addr_list);
-static a_status_t atd_cfg_get_p2p_param(adf_drv_handle_t hdl, 
+static a_status_t atd_cfg_get_p2p_param(adf_drv_handle_t hdl,
                                         acfg_p2p_param_t *p2p_param);
-static a_status_t atd_cfg_set_p2p_param(adf_drv_handle_t hdl, 
+static a_status_t atd_cfg_set_p2p_param(adf_drv_handle_t hdl,
                                         acfg_p2p_param_t *p2p_param);
-static a_status_t atd_cfg_acl_setmac(adf_drv_handle_t hdl, 
+static a_status_t atd_cfg_acl_setmac(adf_drv_handle_t hdl,
                                         acfg_macaddr_t *mac,
 										a_uint8_t add);
 static a_status_t atd_cfg_acl_setmac_sec(adf_drv_handle_t hdl,
                                         acfg_macaddr_t *mac,
                                                                                 a_uint8_t add);
-static a_status_t atd_cfg_get_profile(adf_drv_handle_t hdl, 
+static a_status_t atd_cfg_get_profile(adf_drv_handle_t hdl,
 										acfg_radio_vap_info_t *profile);
 static a_status_t atd_cfg_phyerr(adf_drv_handle_t hdl, acfg_ath_diag_t *ath_diag);
 
@@ -174,19 +173,7 @@ static a_status_t atd_cfg_set_country(adf_drv_handle_t  hdl, acfg_set_country_t
     static a_status_t                                             \
     atd_cfg_##name(adf_drv_handle_t hdl, acfg_wsupp_info_t *wsupp);
 
-PROTO_WSUPP(wsupp_init);
-PROTO_WSUPP(wsupp_fini);
-PROTO_WSUPP(wsupp_if_add);
-PROTO_WSUPP(wsupp_if_remove);
-PROTO_WSUPP(wsupp_nw_create);
-PROTO_WSUPP(wsupp_nw_delete);
-PROTO_WSUPP(wsupp_nw_set);
-PROTO_WSUPP(wsupp_nw_get);
-PROTO_WSUPP(wsupp_nw_list);
-PROTO_WSUPP(wsupp_wps_req);
-PROTO_WSUPP(wsupp_set);
-
-/** 
+/**
  * @brief WIFI Config API(s)
  */
 atd_cfg_wifi_t     wifi_cfg = {
@@ -205,7 +192,7 @@ atd_cfg_wifi_t     wifi_cfg = {
 };
 
 
-/** 
+/**
  * @brief VAP Config API(s)
  */
 atd_cfg_vap_t      vap_cfg = {
@@ -240,7 +227,7 @@ atd_cfg_vap_t      vap_cfg = {
     .get_channel      = atd_cfg_get_chan,
     .set_phymode      = atd_cfg_set_phymode,
     .get_phymode      = atd_cfg_get_phymode,
-    .get_sta_info     = atd_cfg_get_stainfo, 
+    .get_sta_info     = atd_cfg_get_stainfo,
     .set_rts          = atd_cfg_set_rts,
     .get_rts          = atd_cfg_get_rts,
     .set_frag         = atd_cfg_set_frag,
@@ -255,19 +242,6 @@ atd_cfg_vap_t      vap_cfg = {
     .delmac           = atd_cfg_delmac,
     .kickmac          = atd_cfg_kickmac,
 
-    /* security cfgs */
-    .wsupp_init       = atd_cfg_wsupp_init,
-    .wsupp_fini       = atd_cfg_wsupp_fini,
-    .wsupp_if_add     = atd_cfg_wsupp_if_add,
-    .wsupp_if_remove  = atd_cfg_wsupp_if_remove,
-    .wsupp_nw_create  = atd_cfg_wsupp_nw_create,
-    .wsupp_nw_delete  = atd_cfg_wsupp_nw_delete,
-    .wsupp_nw_set     = atd_cfg_wsupp_nw_set,
-    .wsupp_nw_get     = atd_cfg_wsupp_nw_get,
-    .wsupp_nw_list    = atd_cfg_wsupp_nw_list,
-    .wsupp_wps_req    = atd_cfg_wsupp_wps_req,
-    .wsupp_set        = atd_cfg_wsupp_set,
-	
 	/* wmm cfgs */
 	.set_wmmparams    = atd_cfg_set_vap_wmmparams,
 	.get_wmmparams    = atd_cfg_get_vap_wmmparams,
@@ -275,21 +249,21 @@ atd_cfg_vap_t      vap_cfg = {
     /* nawds config */
     .config_nawds     = atd_cfg_nawds_config,
 
-    .set_mlme         = atd_cfg_set_mlme, 
+    .set_mlme         = atd_cfg_set_mlme,
     .set_optie        = atd_cfg_set_optie,
-    .set_filterframe  = atd_cfg_set_filterframe, 
+    .set_filterframe  = atd_cfg_set_filterframe,
     .set_acparams     = atd_cfg_set_acparams,
-    .get_wpa_ie       = atd_cfg_get_wpa_ie, 
+    .get_wpa_ie       = atd_cfg_get_wpa_ie,
     .set_appiebuf     = atd_cfg_set_appiebuf,
-    .set_key          = atd_cfg_set_key, 
-    .del_key          = atd_cfg_del_key, 
-    .get_key          = atd_cfg_get_key, 
-    .get_sta_stats    = atd_cfg_get_sta_stats, 
-    .get_chan_info    = atd_cfg_get_chan_info, 
-    .get_chan_list    = atd_cfg_get_chan_list, 
-    .get_mac_address  = atd_cfg_get_mac_address, 
-    .get_p2p_param    = atd_cfg_get_p2p_param, 
-    .set_p2p_param    = atd_cfg_set_p2p_param, 
+    .set_key          = atd_cfg_set_key,
+    .del_key          = atd_cfg_del_key,
+    .get_key          = atd_cfg_get_key,
+    .get_sta_stats    = atd_cfg_get_sta_stats,
+    .get_chan_info    = atd_cfg_get_chan_info,
+    .get_chan_list    = atd_cfg_get_chan_list,
+    .get_mac_address  = atd_cfg_get_mac_address,
+    .get_p2p_param    = atd_cfg_get_p2p_param,
+    .set_p2p_param    = atd_cfg_set_p2p_param,
     .dbgreq           = atd_cfg_dbgreq,
     .send_mgmt        = atd_cfg_send_mgmt,
     .acl_setmac	      = atd_cfg_acl_setmac,
@@ -452,7 +426,7 @@ fail:
 }
 
 
-static a_status_t 
+static a_status_t
 atd_cfg_tx99tool(adf_drv_handle_t hdl, acfg_tx99_t *tx99_wcmd)
 {
     atd_host_wifi_t     *wifi  = (atd_host_wifi_t * ) hdl;
@@ -469,7 +443,7 @@ atd_cfg_tx99tool(adf_drv_handle_t hdl, acfg_tx99_t *tx99_wcmd)
         status = A_STATUS_ENOMEM;
         goto fail ;
     }
-    
+
     hdrp                  =  (atd_hdr_t *)adf_nbuf_put_tail(nbuf, len);
     hdrp->wifi_index      =   wifi->wifi_index;
     hdrp->vap_index       =   -1;
@@ -496,12 +470,12 @@ fail:
     return status;
 }
 
-a_status_t 
+a_status_t
 atd_cfg_create_vap(adf_drv_handle_t       hdl,
                    a_uint8_t              icp_name[ACFG_MAX_IFNAME],
-                   acfg_opmode_t          icp_opmode,  
-                   a_int32_t              icp_vapid,  
-                   acfg_vapinfo_flags_t   icp_vapflags)
+                   acfg_opmode_t          icp_opmode,
+                   a_int32_t              icp_vapid,
+                   a_uint32_t             icp_vapflags)
 {
     atd_host_wifi_t         *sc  = (atd_host_wifi_t * ) hdl;
     adf_net_dev_info_t       info  = {{0}};
@@ -513,9 +487,9 @@ atd_cfg_create_vap(adf_drv_handle_t       hdl,
     wmi_handle_t             htch =  __wifi2htc(sc);
     a_uint32_t               len, unit, error,  status  = A_STATUS_OK;
     adf_nbuf_t               nbuf;
-    
+
     atd_trace((ATD_DEBUG_FUNCTRACE | ATD_DEBUG_CFG),
-              ("icp_name %s icp_opmode, %x icp_vapflags %x", 
+              ("icp_name %s icp_opmode, %x icp_vapflags %x",
                icp_name, icp_opmode, icp_vapflags));
 
     len = sizeof(atd_vap_create_cmd_t);
@@ -566,7 +540,7 @@ atd_cfg_create_vap(adf_drv_handle_t       hdl,
     cmd->icp_vapid   = adf_os_htonl(icp_vapid);
     cmd->wifi_index  = sc->wifi_index;
 
-    status  = wmi_cmd_send(wmih, WMI_CMD_VAP_CREATE, nbuf, 
+    status  = wmi_cmd_send(wmih, WMI_CMD_VAP_CREATE, nbuf,
                           (a_uint8_t *)&resp, sizeof(atd_vap_create_rsp_t));
 
     atd_trace(ATD_DEBUG_CFG,("WMI Status %x ",status));
@@ -574,7 +548,7 @@ atd_cfg_create_vap(adf_drv_handle_t       hdl,
         atd_trace(ATD_DEBUG_CFG, (" wmi cmd failure stat = %x\n", status));
         goto fail;
     }
-    
+
 
     /*
      * successful. Create local vap
@@ -593,7 +567,7 @@ atd_cfg_create_vap(adf_drv_handle_t       hdl,
     atd_spin_lock_bh(sc->dsc);      /* Lock */
 
     adf_os_assert(sc->vap_list[vap->vap_index] == NULL);
-    
+
     sc->vap_list[vap->vap_index] = vap;
 
     atd_spin_unlock_bh(sc->dsc);    /* Unlock */
@@ -619,10 +593,10 @@ atd_cfg_create_vap(adf_drv_handle_t       hdl,
     adf_os_str_ncopy(info.if_name, resp.name, adf_os_str_len(resp.name));
     adf_os_mem_copy(info.dev_addr, &resp.vap_bssid[0], ACFG_MACADDR_LEN);
 
-    info.header_len = sizeof(atd_tx_hdr_t) + 
+    info.header_len = sizeof(atd_tx_hdr_t) +
                       htc_get_reserveheadroom(htch);
 
-    
+
     dev_switch.drv_ioctl       = atd_vap_ioctl;
     dev_switch.drv_tx_timeout  = atd_vap_tx_timeout ;
     dev_switch.drv_open        = atd_vap_open;
@@ -637,7 +611,8 @@ atd_cfg_create_vap(adf_drv_handle_t       hdl,
         status = A_STATUS_EINVAL;
         goto fail;
     }
-    
+    vap->sys_index   = ADF_VAP_GET_IFINDEX(vap->nethandle);
+
     atd_trace(ATD_DEBUG_FUNCTRACE,("VAP created  _adf_net_ifname %s \n",
                  adf_net_ifname(vap->nethandle)));
 
@@ -656,18 +631,18 @@ fail_unit :
 
 
 
-/** 
+/**
  * @brief utility function for most wmi commands that use the common header
- * 
+ *
  * @param n
  * @param pldlen
  * @param w
  * @param v
- * 
- * @return 
+ *
+ * @return
  */
 static inline a_uint8_t*
-atd_prep_cfg_hdr(adf_nbuf_t n, a_uint32_t pldlen, atd_host_wifi_t *w, 
+atd_prep_cfg_hdr(adf_nbuf_t n, a_uint32_t pldlen, atd_host_wifi_t *w,
                  atd_host_vap_t *v)
 {
     atd_hdr_t  *hdrp;
@@ -682,7 +657,7 @@ atd_prep_cfg_hdr(adf_nbuf_t n, a_uint32_t pldlen, atd_host_wifi_t *w,
     return (a_uint8_t *)(hdrp + 1);
 }
 
-static a_status_t 
+static a_status_t
 atd_cfg_delete_vap(adf_drv_handle_t  hdl )
 {
     atd_host_vap_t    *vap    = (atd_host_vap_t * )hdl;
@@ -690,9 +665,9 @@ atd_cfg_delete_vap(adf_drv_handle_t  hdl )
     a_status_t         status = A_STATUS_OK;
     adf_nbuf_t         nbuf;
 
-    atd_trace((ATD_DEBUG_FUNCTRACE | ATD_DEBUG_CFG), ("delete vap 0x%p ", 
-               (vap->nethandle)));
-    adf_net_stop_queue(vap->nethandle); 
+    atd_trace((ATD_DEBUG_FUNCTRACE | ATD_DEBUG_CFG), ("delete vap 0x%p 0x%p ",
+                                                      vap, (vap->nethandle)));
+    adf_net_stop_queue(vap->nethandle);
 
     if ((nbuf = _atd_wmi_msg_alloc(__wifi2wmi(wifi))) == NULL) {
         atd_trace(ATD_DEBUG_CFG, ("Unable to allocate wmi buffer \n"));
@@ -707,7 +682,7 @@ atd_cfg_delete_vap(adf_drv_handle_t  hdl )
 
     /*Delete net device before sending delete vap cmd to target for ensuring
      vap deletion after net device deletion*/
-    adf_net_delete_dev(vap->nethandle); 
+    adf_net_delete_dev(vap->nethandle);
     vap->nethandle = NULL;
 
     status = wmi_cmd_send(__wifi2wmi(wifi), WMI_CMD_VAP_DELETE , nbuf,
@@ -717,16 +692,16 @@ atd_cfg_delete_vap(adf_drv_handle_t  hdl )
         atd_trace(ATD_DEBUG_CFG, (" wmi_cmd_send Failed stat = %x\n", status));
         goto fail;
     }
-    
-    
-fail:    
+
+
+fail:
 
     atd_trace((ATD_DEBUG_FUNCTRACE | ATD_DEBUG_CFG), ("End stat %x ",status ));
     return status;
 }
 
 
-a_status_t 
+a_status_t
 atd_cfg_set_ssid(adf_drv_handle_t hdl, acfg_ssid_t  *ssid)
 {
     atd_host_vap_t     *vap    = (atd_host_vap_t * )hdl;
@@ -736,7 +711,7 @@ atd_cfg_set_ssid(adf_drv_handle_t hdl, acfg_ssid_t  *ssid)
     adf_nbuf_t          nbuf;
 
     atd_trace((ATD_DEBUG_FUNCTRACE | ATD_DEBUG_CFG), ("ssid %s len %d ", \
-                ssid->name,  ssid->len));
+                ssid->ssid,  ssid->len));
 
     /*Error Check*/
     if(ssid->len > (ACFG_MAX_SSID_LEN + 1)){
@@ -751,11 +726,11 @@ atd_cfg_set_ssid(adf_drv_handle_t hdl, acfg_ssid_t  *ssid)
         goto fail ;
     }
 
-    pld       = (atd_ssid_t *)atd_prep_cfg_hdr(nbuf, sizeof(atd_ssid_t), 
+    pld       = (atd_ssid_t *)atd_prep_cfg_hdr(nbuf, sizeof(atd_ssid_t),
                                                  wifi, vap);
 
     pld->len = adf_os_htonl(ssid->len);
-    adf_os_mem_copy(pld->name, ssid->name, ssid->len);
+    adf_os_mem_copy(pld->name, ssid->ssid, ssid->len);
 
     status = wmi_cmd_send(__wifi2wmi(wifi), WMI_CMD_SSID_SET, nbuf,
                           NULL, 0);
@@ -765,7 +740,7 @@ fail:
     return status;
 }
 
-a_status_t 
+a_status_t
 atd_cfg_get_ssid(adf_drv_handle_t hdl, acfg_ssid_t  *ssid)
 {
     atd_host_vap_t     *vap    = (atd_host_vap_t * )hdl;
@@ -775,7 +750,7 @@ atd_cfg_get_ssid(adf_drv_handle_t hdl, acfg_ssid_t  *ssid)
     atd_ssid_t          ssid_resp = {0};
 
     atd_trace((ATD_DEBUG_FUNCTRACE | ATD_DEBUG_CFG), ("ssid %s len %d ", \
-                ssid->name, ssid->len));
+                ssid->ssid, ssid->len));
 
     if ((nbuf = _atd_wmi_msg_alloc(__wifi2wmi(wifi))) == NULL) {
         atd_trace(ATD_DEBUG_CFG, ("Unable to allocate wmi buffer \n"));
@@ -795,17 +770,17 @@ atd_cfg_get_ssid(adf_drv_handle_t hdl, acfg_ssid_t  *ssid)
     }
 
     ssid->len = adf_os_ntohl(ssid_resp.len);
-    adf_os_mem_copy(ssid->name, ssid_resp.name, (ACFG_MAX_SSID_LEN + 1));
+    adf_os_mem_copy(ssid->ssid, ssid_resp.name, (ACFG_MAX_SSID_LEN + 1));
 
-    atd_trace(ATD_DEBUG_CFG, ("ssid %s len %d ",ssid->name,ssid->len));
+    atd_trace(ATD_DEBUG_CFG, ("ssid %s len %d ",ssid->ssid,ssid->len));
 
-fail:    
+fail:
 
     atd_trace((ATD_DEBUG_FUNCTRACE | ATD_DEBUG_CFG), ("End stat %x ",status ));
     return status;
 }
 
-a_status_t 
+a_status_t
 atd_cfg_set_testmode(adf_drv_handle_t hdl, acfg_testmode_t  *testmode)
 {
     atd_host_vap_t     *vap    = (atd_host_vap_t * )hdl;
@@ -823,7 +798,7 @@ atd_cfg_set_testmode(adf_drv_handle_t hdl, acfg_testmode_t  *testmode)
         goto fail ;
     }
 
-    pld       = (atd_testmode_t *)atd_prep_cfg_hdr(nbuf, sizeof(atd_testmode_t), 
+    pld       = (atd_testmode_t *)atd_prep_cfg_hdr(nbuf, sizeof(atd_testmode_t),
                                                  wifi, vap);
 
     adf_os_mem_copy(pld->bssid, testmode->bssid, ACFG_MACADDR_LEN);
@@ -844,7 +819,7 @@ fail:
     return status;
 }
 
-a_status_t 
+a_status_t
 atd_cfg_get_testmode(adf_drv_handle_t hdl, acfg_testmode_t  *testmode)
 {
     atd_host_vap_t     *vap    = (atd_host_vap_t * )hdl;
@@ -861,7 +836,7 @@ atd_cfg_get_testmode(adf_drv_handle_t hdl, acfg_testmode_t  *testmode)
         goto fail ;
     }
 
-    pld       = (atd_testmode_t *)atd_prep_cfg_hdr(nbuf, sizeof(atd_testmode_t), 
+    pld       = (atd_testmode_t *)atd_prep_cfg_hdr(nbuf, sizeof(atd_testmode_t),
                                                  wifi, vap);
 
     adf_os_mem_copy(pld->bssid, testmode->bssid, ACFG_MACADDR_LEN);
@@ -893,13 +868,13 @@ atd_cfg_get_testmode(adf_drv_handle_t hdl, acfg_testmode_t  *testmode)
     testmode->rssi1 = adf_os_ntohl(result.rssi1);
     testmode->rssi2 = adf_os_ntohl(result.rssi2);
 
-fail:    
+fail:
 
     atd_trace((ATD_DEBUG_FUNCTRACE | ATD_DEBUG_CFG), ("End stat %x ",status ));
     return status;
 }
 
-a_status_t 
+a_status_t
 atd_cfg_get_rssi(adf_drv_handle_t hdl, acfg_rssi_t  *rssi)
 {
     atd_host_vap_t     *vap    = (atd_host_vap_t * )hdl;
@@ -926,13 +901,13 @@ atd_cfg_get_rssi(adf_drv_handle_t hdl, acfg_rssi_t  *rssi)
         goto fail;
     }
 
-fail:    
+fail:
 
     atd_trace((ATD_DEBUG_FUNCTRACE | ATD_DEBUG_CFG), ("End stat %x ",status ));
     return status;
 }
 
-a_status_t 
+a_status_t
 atd_cfg_get_custdata(adf_drv_handle_t hdl, acfg_custdata_t  *custdata)
 {
     atd_host_vap_t     *vap    = (atd_host_vap_t * )hdl;
@@ -959,13 +934,13 @@ atd_cfg_get_custdata(adf_drv_handle_t hdl, acfg_custdata_t  *custdata)
         goto fail;
     }
 
-fail:    
+fail:
 
     atd_trace((ATD_DEBUG_FUNCTRACE | ATD_DEBUG_CFG), ("End stat %x ",status ));
     return status;
 }
 
-static a_status_t 
+static a_status_t
 atd_cfg_set_vap_param(adf_drv_handle_t hdl, a_uint32_t param, a_uint32_t value)
 {
     atd_host_vap_t         *vap    = (atd_host_vap_t * )hdl;
@@ -984,7 +959,7 @@ atd_cfg_set_vap_param(adf_drv_handle_t hdl, a_uint32_t param, a_uint32_t value)
         goto fail ;
     }
 
-    vap_param     = (atd_param_t *)atd_prep_cfg_hdr(nbuf, sizeof(atd_param_t), 
+    vap_param     = (atd_param_t *)atd_prep_cfg_hdr(nbuf, sizeof(atd_param_t),
                                                  wifi, vap);
     vap_param->param     =   adf_os_htonl(param);
     vap_param->val       =   adf_os_htonl(value);
@@ -999,7 +974,7 @@ fail:
     return status;
 }
 
-static a_status_t 
+static a_status_t
 atd_cfg_get_vap_param(adf_drv_handle_t hdl, a_uint32_t param, a_uint32_t *value)
 {
     atd_host_vap_t    *vap    = (atd_host_vap_t * )hdl;
@@ -1018,7 +993,7 @@ atd_cfg_get_vap_param(adf_drv_handle_t hdl, a_uint32_t param, a_uint32_t *value)
         goto fail ;
     }
 
-    vap_param     = (atd_param_t *)atd_prep_cfg_hdr(nbuf, sizeof(atd_param_t), 
+    vap_param     = (atd_param_t *)atd_prep_cfg_hdr(nbuf, sizeof(atd_param_t),
                                                  wifi, vap);
     vap_param->param     =   adf_os_htonl(param);
     vap_param->val       =   0;
@@ -1039,7 +1014,7 @@ fail:
     return status;
 }
 
-static 
+static
 a_status_t atd_cfg_set_vap_vendor_param(adf_drv_handle_t hdl, acfg_vendor_param_req_t *req)
 {
     atd_host_vap_t         *vap    = (atd_host_vap_t * )hdl;
@@ -1110,13 +1085,13 @@ atd_cfg_get_vap_vendor_param(adf_drv_handle_t hdl, acfg_vendor_param_req_t *req)
         *(a_uint32_t *)&req->data = adf_os_ntohl(*(a_uint32_t *)&paramresult.data);
     else
         memcpy(&req->data, &paramresult.data, sizeof(acfg_vendor_param_data_t));
-    
+
 fail:
     atd_trace((ATD_DEBUG_FUNCTRACE | ATD_DEBUG_CFG), ("End stat %x ",status ));
     return status;
 }
 
-static a_status_t 
+static a_status_t
 atd_cfg_set_wifi_param(adf_drv_handle_t hdl, a_uint32_t param, a_uint32_t value)
 {
     atd_host_wifi_t     *wifi  = (atd_host_wifi_t * ) hdl;
@@ -1156,8 +1131,8 @@ fail:
     return status;
 }
 
-static a_status_t 
-atd_cfg_get_wifi_param(adf_drv_handle_t hdl, a_uint32_t param, 
+static a_status_t
+atd_cfg_get_wifi_param(adf_drv_handle_t hdl, a_uint32_t param,
                        a_uint32_t *value)
 {
     atd_host_wifi_t     *wifi  = (atd_host_wifi_t * ) hdl;
@@ -1202,7 +1177,7 @@ fail:
    return status;
 }
 
-a_status_t 
+a_status_t
 atd_cfg_set_opmode(adf_drv_handle_t hdl, acfg_opmode_t mode)
 {
     atd_host_vap_t    *vap    = (atd_host_vap_t * )hdl;
@@ -1214,18 +1189,18 @@ atd_cfg_set_opmode(adf_drv_handle_t hdl, acfg_opmode_t mode)
 
     atd_trace((ATD_DEBUG_FUNCTRACE | ATD_DEBUG_CFG), \
               (" opmode %d ", (a_uint32_t)mode));
-	
+
     if ((nbuf = _atd_wmi_msg_alloc(__wifi2wmi(wifi))) == NULL) {
         atd_trace(ATD_DEBUG_CFG, ("Unable to allocate wmi buffer \n"));
         status = A_STATUS_ENOMEM;
         goto fail ;
     }
 
-    pmode = (acfg_opmode_t *)atd_prep_cfg_hdr(nbuf, sizeof(acfg_opmode_t), 
+    pmode = (acfg_opmode_t *)atd_prep_cfg_hdr(nbuf, sizeof(acfg_opmode_t),
                                                  wifi, vap);
 
     *(a_uint32_t *)pmode = adf_os_htonl(mode);
-	
+
     status = wmi_cmd_send(__wifi2wmi(wifi), WMI_CMD_OPMODE_SET, nbuf,
                           (a_uint8_t *)&resp, sizeof(a_int32_t));
 
@@ -1244,7 +1219,7 @@ fail:
     return status;
 }
 
-a_status_t 
+a_status_t
 atd_cfg_get_opmode(adf_drv_handle_t  hdl, acfg_opmode_t  *mode)
 {
     atd_host_vap_t    *vap    = (atd_host_vap_t * )hdl;
@@ -1278,7 +1253,7 @@ fail:
 }
 
 
-a_status_t 
+a_status_t
 atd_cfg_set_chmode(adf_drv_handle_t hdl, acfg_chmode_t  *mode)
 {
     atd_host_vap_t     *vap    = (atd_host_vap_t * )hdl;
@@ -1308,7 +1283,7 @@ atd_cfg_set_chmode(adf_drv_handle_t hdl, acfg_chmode_t  *mode)
         goto fail ;
     }
 
-    pmode       = (atd_chmode_t *)atd_prep_cfg_hdr(nbuf, sizeof(atd_chmode_t), 
+    pmode       = (atd_chmode_t *)atd_prep_cfg_hdr(nbuf, sizeof(atd_chmode_t),
                                                  wifi, vap);
 
     pmode->len  = adf_os_htonl(mode->len);
@@ -1324,7 +1299,7 @@ fail:
 }
 
 
-a_status_t 
+a_status_t
 atd_cfg_get_chmode(adf_drv_handle_t hdl, acfg_chmode_t *mode)
 {
     atd_host_vap_t     *vap    = (atd_host_vap_t * )hdl;
@@ -1332,7 +1307,7 @@ atd_cfg_get_chmode(adf_drv_handle_t hdl, acfg_chmode_t *mode)
     a_status_t          status = A_STATUS_OK;
     adf_nbuf_t          nbuf;
 
-    atd_chmode_t    atd_mode = {0};      
+    atd_chmode_t    atd_mode = {0};
 
     if ((nbuf = _atd_wmi_msg_alloc(__wifi2wmi(wifi))) == NULL) {
         atd_trace(ATD_DEBUG_CFG, ("Unable to allocate wmi buffer \n"));
@@ -1355,10 +1330,10 @@ fail:
 
 
 
-static a_status_t 
-atd_cfg_get_wireless_name(adf_drv_handle_t hdl, u_int8_t * name, 
+static a_status_t
+atd_cfg_get_wireless_name(adf_drv_handle_t hdl, u_int8_t * name,
                            a_uint32_t maxlen)
-                          
+
 {
     atd_host_vap_t    *vap    = (atd_host_vap_t * )hdl;
     atd_host_wifi_t     *wifi   = vap->wifisc;
@@ -1380,15 +1355,15 @@ atd_cfg_get_wireless_name(adf_drv_handle_t hdl, u_int8_t * name,
     status = wmi_cmd_send(__wifi2wmi(wifi), WMI_CMD_WIRELESS_NAME_GET, nbuf,
             (a_uint8_t *) name ,maxlen);
 
-    
+
     atd_trace(ATD_DEBUG_CFG, (" RESULT name %s \n",name));
 
-fail:    
+fail:
     atd_trace( (ATD_DEBUG_FUNCTRACE|ATD_DEBUG_CFG), (" End ... \n"));
     return status;
 }
 
-a_status_t 
+a_status_t
 atd_cfg_set_ap(adf_drv_handle_t  hdl, acfg_macaddr_t *mac)
 {
     atd_host_vap_t    *vap = (atd_host_vap_t *)hdl;
@@ -1399,14 +1374,14 @@ atd_cfg_set_ap(adf_drv_handle_t  hdl, acfg_macaddr_t *mac)
     a_int32_t          resp;
 
     atd_trace((ATD_DEBUG_FUNCTRACE | ATD_DEBUG_CFG), ("Start"));
-	
+
     if ((nbuf = _atd_wmi_msg_alloc(__wifi2wmi(wifi))) == NULL) {
         atd_trace(ATD_DEBUG_CFG, ("Unable to allocate wmi buffer \n"));
         status = A_STATUS_ENOMEM;
         goto fail ;
     }
 
-    pmac = (acfg_macaddr_t *)atd_prep_cfg_hdr(nbuf, sizeof(acfg_macaddr_t), 
+    pmac = (acfg_macaddr_t *)atd_prep_cfg_hdr(nbuf, sizeof(acfg_macaddr_t),
                                               wifi, vap);
 
     memcpy(pmac->addr, mac->addr, ACFG_MACADDR_LEN);
@@ -1414,8 +1389,8 @@ atd_cfg_set_ap(adf_drv_handle_t  hdl, acfg_macaddr_t *mac)
     atd_trace(ATD_DEBUG_CFG, (" ap mac addr %02x:%02x:%02x:%02x:%02x:%02x", \
                 pmac->addr[0], pmac->addr[1], pmac->addr[2], pmac->addr[3], \
                 pmac->addr[4], pmac->addr[5]));
-	
-    status = wmi_cmd_send(__wifi2wmi(wifi), WMI_CMD_AP_SET, nbuf, 
+
+    status = wmi_cmd_send(__wifi2wmi(wifi), WMI_CMD_AP_SET, nbuf,
             (a_uint8_t *)&resp, sizeof(a_int32_t));
 
     if (status != A_STATUS_OK) {
@@ -1433,7 +1408,7 @@ fail:
     return status;
 }
 
-static a_status_t 
+static a_status_t
 atd_cfg_get_ap(adf_drv_handle_t hdl, acfg_macaddr_t *mac)
 {
     atd_host_vap_t    *vap    = (atd_host_vap_t * )hdl;
@@ -1455,17 +1430,17 @@ atd_cfg_get_ap(adf_drv_handle_t hdl, acfg_macaddr_t *mac)
     status = wmi_cmd_send(__wifi2wmi(wifi), WMI_CMD_AP_GET, nbuf,
             (a_uint8_t *)mac->addr , ACFG_MACADDR_LEN);
 
-    
+
     atd_trace(ATD_DEBUG_CFG, (" ap mac addr %x:%x:%x:%x:%x:%x", \
                 mac->addr[0], mac->addr[1], mac->addr[2], mac->addr[3], \
                 mac->addr[4], mac->addr[5]));
 
-fail:    
+fail:
     atd_trace( (ATD_DEBUG_FUNCTRACE|ATD_DEBUG_CFG), (" End ... \n"));
     return status;
 }
 
-a_status_t 
+a_status_t
 atd_cfg_set_rate(adf_drv_handle_t hdl, acfg_rate_t *rate)
 {
     atd_host_vap_t    *vap    = (atd_host_vap_t * )hdl;
@@ -1483,16 +1458,15 @@ atd_cfg_set_rate(adf_drv_handle_t hdl, acfg_rate_t *rate)
         goto fail ;
     }
 
-    prate = (atd_rate_t *)atd_prep_cfg_hdr(nbuf, sizeof(atd_rate_t), 
+    prate = (atd_rate_t *)atd_prep_cfg_hdr(nbuf, sizeof(atd_rate_t),
                                             wifi, vap);
 
-    prate->fixed = rate->fixed;
-    prate->value = adf_os_htonl(rate->value);
+    prate->value = adf_os_htonl(rate);
 
     atd_trace(ATD_DEBUG_CFG, ("SET value %d , fixed %d", prate->value, \
               prate->fixed));
 
-    status = wmi_cmd_send(__wifi2wmi(wifi), WMI_CMD_RATE_SET, nbuf, 
+    status = wmi_cmd_send(__wifi2wmi(wifi), WMI_CMD_RATE_SET, nbuf,
             (a_uint8_t *)&resp, sizeof(a_int32_t));
 
     if (status != A_STATUS_OK) {
@@ -1509,7 +1483,7 @@ fail:
     return status;
 }
 
-static a_status_t 
+static a_status_t
 atd_cfg_get_rate(adf_drv_handle_t hdl, a_uint32_t *rate)
 {
     atd_host_vap_t    *vap    = (atd_host_vap_t * )hdl;
@@ -1535,15 +1509,15 @@ atd_cfg_get_rate(adf_drv_handle_t hdl, a_uint32_t *rate)
         status =  A_STATUS_EINVAL;
     }
     rate[0] = adf_os_ntohl(rate[0]);
- 
+
     atd_trace(ATD_DEBUG_CFG, (" RESULT rate %d",rate[0]));
 
-fail:    
+fail:
     atd_trace( (ATD_DEBUG_FUNCTRACE|ATD_DEBUG_CFG), (" End ... \n"));
     return status;
 }
 
-a_status_t 
+a_status_t
 atd_cfg_set_powmgmt(adf_drv_handle_t  hdl, acfg_powmgmt_t *pm)
 {
     atd_host_vap_t *vap = (atd_host_vap_t *)hdl;
@@ -1554,21 +1528,21 @@ atd_cfg_set_powmgmt(adf_drv_handle_t  hdl, acfg_powmgmt_t *pm)
     a_int32_t resp;
 
     atd_trace( (ATD_DEBUG_FUNCTRACE|ATD_DEBUG_CFG), ("Start"));
-	
+
     if ((nbuf = _atd_wmi_msg_alloc(__wifi2wmi(wifi))) == NULL) {
         atd_trace(ATD_DEBUG_CFG, ("Unable to allocate wmi buffer \n"));
         status = A_STATUS_ENOMEM;
         goto fail ;
     }
 
-    mgmt = (atd_powmgmt_t *)atd_prep_cfg_hdr(nbuf, sizeof(atd_powmgmt_t), 
+    mgmt = (atd_powmgmt_t *)atd_prep_cfg_hdr(nbuf, sizeof(atd_powmgmt_t),
                                               wifi, vap);
-	
+
     mgmt->disabled = pm->disabled;
     mgmt->flags = adf_os_htons(pm->flags);
     mgmt->val = adf_os_htonl(pm->val);
 
-    status = wmi_cmd_send(__wifi2wmi(wifi), WMI_CMD_POWMGMT_SET, nbuf, 
+    status = wmi_cmd_send(__wifi2wmi(wifi), WMI_CMD_POWMGMT_SET, nbuf,
             (a_uint8_t *)&resp, sizeof(a_int32_t));
 
     if (status != A_STATUS_OK) {
@@ -1586,7 +1560,7 @@ fail:
     return status;
 }
 
-static a_status_t 
+static a_status_t
 atd_cfg_get_powmgmt(adf_drv_handle_t hdl, acfg_powmgmt_t *pm)
 {
     atd_host_vap_t    *vap    = (atd_host_vap_t * )hdl;
@@ -1613,13 +1587,13 @@ atd_cfg_get_powmgmt(adf_drv_handle_t hdl, acfg_powmgmt_t *pm)
         status =  A_STATUS_EINVAL;
         goto fail;
     }
-	
+
     pm->val = adf_os_ntohl(powmgmt.val);
     pm->flags = adf_os_ntohs(powmgmt.flags);
     pm->disabled = powmgmt.disabled;
- 
+
     atd_trace(ATD_DEBUG_CFG, \
-             ("RESULT pm.val %d pm.flags 0x%04x pm.disabled %d", 
+             ("RESULT pm.val %d pm.flags 0x%04x pm.disabled %d",
 		     pm->val, pm->flags, pm->disabled));
 
 fail:
@@ -1627,12 +1601,12 @@ fail:
     return status;
 }
 
-/** 
- * @brief Get ath stats from target 
- * 
+/**
+ * @brief Get ath stats from target
+ *
  * @param hdl
  * @param scan
- * 
+ *
  * @return status
  */
 a_status_t
@@ -1688,13 +1662,12 @@ atd_cfg_get_ath_stats(adf_drv_handle_t hdl, acfg_ath_stats_t *athstats_wcmd)
     athstats_param = (atd_ath_stats_t *)resp;
     len = adf_os_ntohl(athstats_param->size);
     athstats_wcmd->offload_if = adf_os_ntohl(athstats_param->offload_if);
-
     if (athstats_wcmd->offload_if == 1) {
         a_uint32_t i;
         acfg_ath_stats_11ac_t *ac_stats = (acfg_ath_stats_11ac_t *)(athstats_wcmd->address);
         atd_ath_stats_11ac_t *stats = (atd_ath_stats_11ac_t *)((a_uint8_t *)resp + sizeof(atd_ath_stats_t));
         athstats_wcmd->size = sizeof(acfg_ath_stats_11ac_t);
-
+        memcpy(ac_stats, stats, athstats_wcmd->size);
         ac_stats->txrx_stats_level = adf_os_ntohl(stats->txrx_stats_level);
         ac_stats->txrx_stats.tx.from_stack.pkts = adf_os_be64_to_cpu(stats->txrx_stats.tx.from_stack.pkts);
         ac_stats->txrx_stats.tx.from_stack.bytes = adf_os_be64_to_cpu(stats->txrx_stats.tx.from_stack.bytes);
@@ -1730,7 +1703,7 @@ atd_cfg_get_ath_stats(adf_drv_handle_t hdl, acfg_ath_stats_t *athstats_wcmd)
         ac_stats->stats.tx.underrun = adf_os_ntohl(stats->stats.tx.underrun);
         ac_stats->stats.tx.tx_abort = adf_os_ntohl(stats->stats.tx.tx_abort);
         ac_stats->stats.tx.mpdus_requed = adf_os_ntohl(stats->stats.tx.mpdus_requed);
-        ac_stats->stats.tx.tx_xretry = adf_os_ntohl(stats->stats.tx.tx_ko);
+        ac_stats->stats.tx.tx_xretry = adf_os_ntohl(stats->stats.tx.tx_xretry);
         ac_stats->stats.tx.data_rc = adf_os_ntohl(stats->stats.tx.data_rc);
         ac_stats->stats.tx.self_triggers = adf_os_ntohl(stats->stats.tx.self_triggers);
         ac_stats->stats.tx.sw_retry_failure = adf_os_ntohl(stats->stats.tx.sw_retry_failure);
@@ -1746,7 +1719,6 @@ atd_cfg_get_ath_stats(adf_drv_handle_t hdl, acfg_ath_stats_t *athstats_wcmd)
         ac_stats->stats.rx.r0_frags = adf_os_ntohl(stats->stats.rx.r0_frags);
         ac_stats->stats.rx.r1_frags = adf_os_ntohl(stats->stats.rx.r1_frags);
         ac_stats->stats.rx.r2_frags = adf_os_ntohl(stats->stats.rx.r2_frags);
-        ac_stats->stats.rx.r3_frags = adf_os_ntohl(stats->stats.rx.r3_frags);
         ac_stats->stats.rx.htt_msdus = adf_os_ntohl(stats->stats.rx.htt_msdus);
         ac_stats->stats.rx.htt_mpdus = adf_os_ntohl(stats->stats.rx.htt_mpdus);
         ac_stats->stats.rx.loc_msdus = adf_os_ntohl(stats->stats.rx.loc_msdus);
@@ -1755,9 +1727,8 @@ atd_cfg_get_ath_stats(adf_drv_handle_t hdl, acfg_ath_stats_t *athstats_wcmd)
         ac_stats->stats.rx.phy_errs = adf_os_ntohl(stats->stats.rx.phy_errs);
         ac_stats->stats.rx.phy_err_drop = adf_os_ntohl(stats->stats.rx.phy_err_drop);
         ac_stats->stats.rx.mpdu_errs = adf_os_ntohl(stats->stats.rx.mpdu_errs);
-        ac_stats->stats.mem.dram_free_size = adf_os_ntohl(stats->stats.mem.dram_remain);
-        ac_stats->stats.mem.iram_free_size = adf_os_ntohl(stats->stats.mem.iram_remain);
-        ac_stats->stats.peer.dummy = adf_os_ntohl(stats->stats.peer.dummy);
+        ac_stats->stats.mem.dram_free_size = adf_os_ntohl(stats->stats.mem.dram_free_size);
+        ac_stats->stats.mem.iram_free_size = adf_os_ntohl(stats->stats.mem.iram_free_size);
         ac_stats->interface_stats.tx_beacon = adf_os_be64_to_cpu(stats->interface_stats.tx_beacon);
         ac_stats->interface_stats.be_nobuf = adf_os_ntohl(stats->interface_stats.be_nobuf);
         ac_stats->interface_stats.tx_buf_count = adf_os_ntohl(stats->interface_stats.tx_buf_count);
@@ -1816,7 +1787,7 @@ atd_cfg_get_ath_stats(adf_drv_handle_t hdl, acfg_ath_stats_t *athstats_wcmd)
         acfg_ath_stats_11n_t *n_stats = (acfg_ath_stats_11n_t *)(athstats_wcmd->address);
         atd_ath_stats_11n_t *stats = (atd_ath_stats_11n_t *)((a_uint8_t *)resp + sizeof(atd_ath_stats_t));
         athstats_wcmd->size = sizeof(acfg_ath_stats_11n_t);
-
+        memcpy(n_stats, stats, athstats_wcmd->size);
         n_stats->ast_watchdog = adf_os_ntohl(stats->ast_watchdog);
         n_stats->ast_resetOnError = adf_os_ntohl(stats->ast_resetOnError);
         n_stats->ast_mat_ucast_encrypted = adf_os_ntohl(stats->ast_mat_ucast_encrypted);
@@ -2184,7 +2155,6 @@ atd_cfg_get_ath_stats(adf_drv_handle_t hdl, acfg_ath_stats_t *athstats_wcmd)
             n_stats->ast_bb_panic[i].src = adf_os_ntohl(stats->ast_bb_panic[i].src);
         }
     }
-
 fail:
     if (resp)
         adf_os_mem_free(resp);
@@ -2193,12 +2163,12 @@ fail:
     return status;
 }
 
-/** 
- * @brief Clear ath stats from target 
- * 
+/**
+ * @brief Clear ath stats from target
+ *
  * @param hdl
  * @param scan
- * 
+ *
  * @return status
  */
 a_status_t
@@ -2231,15 +2201,15 @@ fail:
     return status;
 }
 
-/** 
- * @brief Get Scan results from Target 
- * 
+/**
+ * @brief Get Scan results from Target
+ *
  * @param hdl
  * @param scan
- * 
+ *
  * @return status
  */
-a_status_t 
+a_status_t
 atd_cfg_get_scan_results(adf_drv_handle_t hdl, acfg_scan_t *scan)
 {
     atd_host_vap_t    *vap    = (atd_host_vap_t * )hdl;
@@ -2262,14 +2232,13 @@ atd_cfg_get_scan_results(adf_drv_handle_t hdl, acfg_scan_t *scan)
         goto fail ;
     }
 
-    pld = (atd_scan_t *)atd_prep_cfg_hdr(nbuf, sizeof(a_uint32_t), 
+    pld = (atd_scan_t *)atd_prep_cfg_hdr(nbuf, sizeof(a_uint32_t),
             wifi, vap);
 
     status = wmi_cmd_send(__wifi2wmi(wifi), WMI_CMD_SCAN_SPACE_GET, nbuf,
                          (a_uint8_t* )&rlen, sizeof(a_uint32_t));
 
-
-    rlen =  adf_os_ntohl(rlen);
+    rlen = adf_os_ntohl(rlen);
 
     if( rlen > scan->len )
     {
@@ -2290,17 +2259,16 @@ atd_cfg_get_scan_results(adf_drv_handle_t hdl, acfg_scan_t *scan)
         goto fail_free ;
     }
 
-    pld = (atd_scan_t *)atd_prep_cfg_hdr(nbuf, sizeof(a_uint32_t), 
+    pld = (atd_scan_t *)atd_prep_cfg_hdr(nbuf, sizeof(a_uint32_t),
                                          wifi, vap);
 
     pld->len = adf_os_htonl(scan->len);
 
     status = wmi_cmd_send(__wifi2wmi(wifi), WMI_CMD_SCAN_RESULTS_GET, nbuf,
                           results, rlen);
-    
 
-    /* Length of valid scan data 
-     * for use by upper layers. 
+    /* Length of valid scan data
+     * for use by upper layers.
     */
     scan->len = rlen ;
 
@@ -2310,13 +2278,13 @@ atd_cfg_get_scan_results(adf_drv_handle_t hdl, acfg_scan_t *scan)
     while (pos + sizeof(atd_scan_result_t) <= end) {
         atd_scan_result_t *sr;
         a_uint8_t *next;
-        
+
         sr = (atd_scan_result_t *) pos;
         next = (pos + sizeof(*sr) + adf_os_ntohs(sr->isr_len));
         if (next > end)
             break;
 
-        if (count + sizeof(*sl) + 
+        if (count + sizeof(*sl) +
             adf_os_ntohs(sr->isr_len) > rlen)
             break;
 
@@ -2334,38 +2302,37 @@ atd_cfg_get_scan_results(adf_drv_handle_t hdl, acfg_scan_t *scan)
         for (i = 0; i < 36; i++)
             sl->isr_rates[i] = sr->isr_rates[i];
         sl->isr_ssid_len = sr->isr_ssid_len;
-        sl->isr_ie_len = adf_os_ntohs(sr->isr_ie_len);    
+        sl->isr_ie_len = adf_os_ntohs(sr->isr_ie_len);
         memcpy(sl + 1, sr + 1, adf_os_ntohs(sr->isr_len));
 
         count += sizeof(*sl) + adf_os_ntohs(sr->isr_len);
-        sl = (acfg_scanresult_t *)((a_uint8_t *)(sl + 1) + 
+        sl = (acfg_scanresult_t *)((a_uint8_t *)(sl + 1) +
                                   (adf_os_ntohs(sr->isr_len)));
         pos = next;
     }
-
     adf_os_mem_free(results);
- 
+
     atd_trace(ATD_DEBUG_FUNCTRACE, ("End."));
     return status;
 
 fail_free:
     adf_os_mem_free(results);
 
-fail:    
+fail:
     atd_trace(ATD_DEBUG_FUNCTRACE, ("Failed... End."));
     return status;
 
 }
 
-/** 
- * @brief set scan request 
- * 
+/**
+ * @brief set scan request
+ *
  * @param hdl
  * @param scan
- * 
- * @return 
+ *
+ * @return
  */
-a_status_t 
+a_status_t
 atd_cfg_set_scan(adf_drv_handle_t hdl, acfg_set_scan_t *scan)
 {
     atd_host_vap_t    *vap    = (atd_host_vap_t * )hdl;
@@ -2384,7 +2351,7 @@ atd_cfg_set_scan(adf_drv_handle_t hdl, acfg_set_scan_t *scan)
         goto fail ;
     }
 
-    pld = (atd_set_scan_t *)atd_prep_cfg_hdr(nbuf, sizeof(atd_set_scan_t), 
+    pld = (atd_set_scan_t *)atd_prep_cfg_hdr(nbuf, sizeof(atd_set_scan_t),
             wifi, vap);
 
     pld->point_flags =  adf_os_htons(scan->point_flags);
@@ -2419,12 +2386,12 @@ atd_cfg_set_scan(adf_drv_handle_t hdl, acfg_set_scan_t *scan)
     return status;
 
 
-fail:    
+fail:
     atd_trace(ATD_DEBUG_FUNCTRACE, ("Failed End Status %d.",status));
     return status;
 }
 
-static a_status_t 
+static a_status_t
 atd_cfg_get_range(adf_drv_handle_t hdl, acfg_range_t *range)
 {
     atd_host_vap_t    *vap    = (atd_host_vap_t * )hdl;
@@ -2523,19 +2490,19 @@ atd_cfg_get_range(adf_drv_handle_t hdl, acfg_range_t *range)
     atd_trace(ATD_DEBUG_CFG, (" RESULT "));
     return status;
 
-fail:    
+fail:
     atd_trace( (ATD_DEBUG_FUNCTRACE|ATD_DEBUG_CFG), (" End ... \n"));
     return status;
 }
 
 
-/** 
+/**
  * @brief Set Phymode
- * 
+ *
  * @param hdl
  * @param mode
- * 
- * @return 
+ *
+ * @return
  */
 static a_status_t
 atd_cfg_set_phymode(adf_drv_handle_t  hdl, acfg_phymode_t  mode)
@@ -2615,16 +2582,16 @@ fail:
     return status;
 }
 
-/** 
+/**
  * @brief Get info on associated stations.
- * 
+ *
  * @param hdl
  * @param buff
  * @param buflen
- * 
- * @return 
+ *
+ * @return
  */
-static a_status_t 
+static a_status_t
 atd_cfg_get_stainfo(adf_drv_handle_t hdl, a_uint8_t *buff, a_uint32_t buflen)
 {
     atd_host_vap_t  *vap    = (atd_host_vap_t * )hdl;
@@ -2716,7 +2683,7 @@ atd_cfg_get_stainfo(adf_drv_handle_t hdl, a_uint8_t *buff, a_uint32_t buflen)
         memcpy(resp + 1, si + 1, adf_os_ntohs(si->isi_len));
 
         count += sizeof(*resp) + adf_os_ntohs(si->isi_len);
-        resp = (acfg_stainfo_t *)((a_uint8_t *)(resp + 1) + 
+        resp = (acfg_stainfo_t *)((a_uint8_t *)(resp + 1) +
                                   (adf_os_ntohs(si->isi_len)));
         pos = next;
     }
@@ -2733,15 +2700,15 @@ fail:
 }
 
 
-/** 
+/**
  * @brief Set MLME
- * 
+ *
  * @param hdl
  * @param mode
- * 
- * @return 
+ *
+ * @return
  */
-a_status_t 
+a_status_t
 atd_cfg_set_mlme(adf_drv_handle_t hdl, acfg_mlme_t  *mlme)
 {
     atd_host_vap_t     *vap    = (atd_host_vap_t * )hdl;
@@ -2760,14 +2727,16 @@ atd_cfg_set_mlme(adf_drv_handle_t hdl, acfg_mlme_t  *mlme)
 
     pld  = (atd_mlme_t *)atd_prep_cfg_hdr(nbuf, sizeof(atd_mlme_t), wifi, vap);
 
-    pld->op = mlme->op;
-    pld->ssid_len = mlme->ssid_len;
-    pld->reason = adf_os_htons(mlme->reason);
-    pld->seq = adf_os_htons(mlme->seq);
-    adf_os_mem_copy(pld->macaddr, mlme->macaddr, ACFG_MACADDR_LEN);
-    adf_os_mem_copy(pld->ssid, mlme->ssid, ACFG_MAX_SSID_LEN);
-    adf_os_mem_copy(pld->optie, mlme->optie, ACFG_MAX_IELEN * 2);
-    pld->optie_len = adf_os_htons(mlme->optie_len);
+    memcpy(pld, mlme, sizeof(*pld));
+
+    pld->im_op = mlme->im_op;
+    pld->im_ssid_len = mlme->im_ssid_len;
+    pld->im_reason = adf_os_htons(mlme->im_reason);
+    pld->im_seq = adf_os_htons(mlme->im_seq);
+    adf_os_mem_copy(pld->im_macaddr, mlme->im_macaddr, ACFG_MACADDR_LEN);
+    adf_os_mem_copy(pld->im_ssid, mlme->im_ssid, ACFG_MAX_SSID_LEN);
+    adf_os_mem_copy(pld->im_optie, mlme->im_optie, ACFG_MAX_IELEN * 2);
+    pld->im_optie_len = adf_os_htons(mlme->im_optie_len);
 
     status = wmi_cmd_send(__wifi2wmi(wifi), WMI_CMD_MLME_SET, nbuf,
                           NULL, 0);
@@ -2779,15 +2748,15 @@ fail:
 
 
 
-/** 
+/**
  * @brief Send MGMT frame
- * 
+ *
  * @param hdl
  * @param mode
- * 
- * @return 
+ *
+ * @return
  */
-a_status_t 
+a_status_t
 atd_cfg_send_mgmt(adf_drv_handle_t hdl, acfg_mgmt_t  *mgmt)
 {
     atd_host_vap_t     *vap    = (atd_host_vap_t * )hdl;
@@ -2809,7 +2778,7 @@ atd_cfg_send_mgmt(adf_drv_handle_t hdl, acfg_mgmt_t  *mgmt)
         goto fail ;
     }
 
-    pld = (atd_mgmt_t *)atd_prep_cfg_hdr(nbuf, 
+    pld = (atd_mgmt_t *)atd_prep_cfg_hdr(nbuf,
                         sizeof(atd_mgmt_t) + mgmt->buflen, wifi, vap);
     if (pld == NULL) {
         status = A_STATUS_ENOMEM;
@@ -2829,15 +2798,15 @@ fail:
 
 
 
-/** 
+/**
  * @brief Set Opt IE
- * 
+ *
  * @param hdl
  * @param mode
- * 
- * @return 
+ *
+ * @return
  */
-a_status_t 
+a_status_t
 atd_cfg_set_optie(adf_drv_handle_t hdl, acfg_ie_t  *ie)
 {
     atd_host_vap_t     *vap    = (atd_host_vap_t * )hdl;
@@ -2859,7 +2828,7 @@ atd_cfg_set_optie(adf_drv_handle_t hdl, acfg_ie_t  *ie)
         goto fail ;
     }
 
-    atd_trace((ATD_DEBUG_FUNCTRACE | ATD_DEBUG_CFG), 
+    atd_trace((ATD_DEBUG_FUNCTRACE | ATD_DEBUG_CFG),
                                 ("IE len - %d ",ie->len));
 
     pie  = atd_prep_cfg_hdr(nbuf, ie->len + sizeof(a_uint32_t),
@@ -2879,14 +2848,14 @@ fail:
 
 
 
-/** 
+/**
  * @brief Get wpa ie about associating station
- * 
+ *
  * @param hdl
  * @param buff
  * @param buflen
- * 
- * @return 
+ *
+ * @return
  */
 static a_status_t
 atd_cfg_get_wpa_ie(adf_drv_handle_t hdl, a_uint8_t *buff, a_uint32_t buflen)
@@ -2926,15 +2895,15 @@ fail:
 }
 
 
-/** 
+/**
  * @brief Set AC Params
- * 
+ *
  * @param hdl
  * @param filterframe
- * 
- * @return 
+ *
+ * @return
  */
-a_status_t 
+a_status_t
 atd_cfg_set_acparams(adf_drv_handle_t hdl, a_uint32_t *ac)
 {
     atd_host_vap_t     *vap    = (atd_host_vap_t * )hdl;
@@ -2955,7 +2924,7 @@ atd_cfg_set_acparams(adf_drv_handle_t hdl, a_uint32_t *ac)
 
     for(i=0; i < ACFG_MAX_ACPARAMS; i++)
         pac[i] = adf_os_htonl(ac[i]) ;
-    
+
     status = wmi_cmd_send(__wifi2wmi(wifi), WMI_CMD_ACPARAMS_SET, nbuf,
                           NULL, 0);
 
@@ -2965,15 +2934,15 @@ fail:
 }
 
 
-/** 
+/**
  * @brief Set Filterframe
- * 
+ *
  * @param hdl
  * @param filterframe
- * 
- * @return 
+ *
+ * @return
  */
-a_status_t 
+a_status_t
 atd_cfg_set_filterframe(adf_drv_handle_t hdl, acfg_filter_t  *filterframe)
 {
     atd_host_vap_t     *vap    = (atd_host_vap_t * )hdl;
@@ -3032,15 +3001,15 @@ atd_cfg_dbgreq(adf_drv_handle_t hdl, acfg_athdbg_req_t  *dbgreq)
     atd_trace((ATD_DEBUG_FUNCTRACE | ATD_DEBUG_CFG), ("dbgreq frame "));
 
     switch (dbgreq->cmd) {
-        case ACFG_DBGREQ_GETRRMSTATS:
+        case IEEE80211_DBGREQ_GETRRMSTATS:
             len += sizeof(atd_rrmstats_t);
             resp_len += sizeof(atd_rrmstats_t);
             break;
-        case ACFG_DBGREQ_GETBCNRPT:
+        case IEEE80211_DBGREQ_GETBCNRPT:
             len += sizeof(atd_bcnrpt_t);
             resp_len += sizeof(atd_bcnrpt_t);
             break;
-        case ACFG_DBGREQ_GETACSREPORT:
+        case IEEE80211_DBGREQ_GETACSREPORT:
             len += sizeof(atd_acs_dbg_t);
             resp_len += sizeof(atd_acs_dbg_t);
             break;
@@ -3065,17 +3034,17 @@ atd_cfg_dbgreq(adf_drv_handle_t hdl, acfg_athdbg_req_t  *dbgreq)
     pld->cmd = dbgreq->cmd;
     adf_os_mem_copy(pld->dstmac, dbgreq->dstmac, ACFG_MACADDR_LEN);
     switch (dbgreq->cmd) {
-        case ACFG_DBGREQ_SENDADDBA:
-        case ACFG_DBGREQ_SENDDELBA:
-        case ACFG_DBGREQ_SETADDBARESP:
-        case ACFG_DBGREQ_GETADDBASTATS:
-        case ACFG_DBGREQ_SENDSINGLEAMSDU:
+        case IEEE80211_DBGREQ_SENDADDBA:
+        case IEEE80211_DBGREQ_SENDDELBA:
+        case IEEE80211_DBGREQ_SETADDBARESP:
+        case IEEE80211_DBGREQ_GETADDBASTATS:
+        case IEEE80211_DBGREQ_SENDSINGLEAMSDU:
             pld->data.param[0] = adf_os_htonl(dbgreq->data.param[0]);
             pld->data.param[1] = adf_os_htonl(dbgreq->data.param[1]);
             pld->data.param[2] = adf_os_htonl(dbgreq->data.param[2]);
             pld->data.param[3] = adf_os_htonl(dbgreq->data.param[3]);
             break;
-        case ACFG_DBGREQ_SENDBCNRPT:
+        case IEEE80211_DBGREQ_SENDBCNRPT:
             pld->data.bcnrpt.num_rpt = adf_os_htons(dbgreq->data.bcnrpt.num_rpt);
             pld->data.bcnrpt.regclass = dbgreq->data.bcnrpt.regclass;
             pld->data.bcnrpt.channum = dbgreq->data.bcnrpt.channum;
@@ -3098,7 +3067,7 @@ atd_cfg_dbgreq(adf_drv_handle_t hdl, acfg_athdbg_req_t  *dbgreq)
                     pld->data.bcnrpt.apchanrep[i].channum[j] = dbgreq->data.bcnrpt.apchanrep[i].channum[j];
             }
             break;
-        case ACFG_DBGREQ_SENDTSMRPT:
+        case IEEE80211_DBGREQ_SENDTSMRPT:
             pld->data.tsmrpt.num_rpt = adf_os_htons(dbgreq->data.tsmrpt.num_rpt);
             pld->data.tsmrpt.rand_ivl = adf_os_htons(dbgreq->data.tsmrpt.rand_ivl);
             pld->data.tsmrpt.meas_dur = adf_os_htons(dbgreq->data.tsmrpt.meas_dur);
@@ -3114,21 +3083,21 @@ atd_cfg_dbgreq(adf_drv_handle_t hdl, acfg_athdbg_req_t  *dbgreq)
             pld->data.tsmrpt.meas_count = dbgreq->data.tsmrpt.meas_count;
             pld->data.tsmrpt.trig_timeout = dbgreq->data.tsmrpt.trig_timeout;
             break;
-        case ACFG_DBGREQ_SENDNEIGRPT:
+        case IEEE80211_DBGREQ_SENDNEIGRPT:
             pld->data.neigrpt.dialogtoken = dbgreq->data.neigrpt.dialogtoken;
             adf_os_mem_copy(pld->data.neigrpt.ssid, dbgreq->data.neigrpt.ssid, 32);
             pld->data.neigrpt.ssid_len = dbgreq->data.neigrpt.ssid_len;
             break;
-        case ACFG_DBGREQ_SENDLMREQ:
+        case IEEE80211_DBGREQ_SENDLMREQ:
             break;
-        case ACFG_DBGREQ_SENDBSTMREQ:
+        case IEEE80211_DBGREQ_SENDBSTMREQ:
             pld->data.bstmreq.dialogtoken = dbgreq->data.bstmreq.dialogtoken;
             pld->data.bstmreq.candidate_list = dbgreq->data.bstmreq.candidate_list;
             pld->data.bstmreq.disassoc = dbgreq->data.bstmreq.disassoc;
             pld->data.bstmreq.disassoc_timer = adf_os_htons(dbgreq->data.bstmreq.disassoc_timer);
             pld->data.bstmreq.validity_itvl = dbgreq->data.bstmreq.validity_itvl;
             break;
-        case ACFG_DBGREQ_SENDCHLOADREQ:
+        case IEEE80211_DBGREQ_SENDCHLOADREQ:
             adf_os_mem_copy(pld->data.chloadrpt.dstmac, dbgreq->data.chloadrpt.dstmac, 6);
             pld->data.chloadrpt.num_rpts = adf_os_htons(dbgreq->data.chloadrpt.num_rpts);
             pld->data.chloadrpt.regclass = dbgreq->data.chloadrpt.regclass;
@@ -3138,14 +3107,14 @@ atd_cfg_dbgreq(adf_drv_handle_t hdl, acfg_athdbg_req_t  *dbgreq)
             pld->data.chloadrpt.cond = dbgreq->data.chloadrpt.cond;
             pld->data.chloadrpt.c_val = dbgreq->data.chloadrpt.c_val;
             break;
-        case ACFG_DBGREQ_SENDSTASTATSREQ:
+        case IEEE80211_DBGREQ_SENDSTASTATSREQ:
             adf_os_mem_copy(pld->data.stastats.dstmac, dbgreq->data.stastats.dstmac, 6);
             pld->data.stastats.num_rpts = adf_os_htons(dbgreq->data.stastats.num_rpts);
             pld->data.stastats.m_dur = adf_os_htons(dbgreq->data.stastats.m_dur);
             pld->data.stastats.r_invl = adf_os_htons(dbgreq->data.stastats.r_invl);
             pld->data.stastats.gid = dbgreq->data.stastats.gid;
             break;
-        case ACFG_DBGREQ_SENDNHIST:
+        case IEEE80211_DBGREQ_SENDNHIST:
             pld->data.nhist.num_rpts = adf_os_htons(dbgreq->data.nhist.num_rpts);
             adf_os_mem_copy(pld->data.nhist.dstmac, dbgreq->data.nhist.dstmac, 6);
             pld->data.nhist.regclass = dbgreq->data.nhist.regclass;
@@ -3155,10 +3124,10 @@ atd_cfg_dbgreq(adf_drv_handle_t hdl, acfg_athdbg_req_t  *dbgreq)
             pld->data.nhist.cond = dbgreq->data.nhist.cond;
             pld->data.nhist.c_val = dbgreq->data.nhist.c_val;
             break;
-        case ACFG_DBGREQ_SENDDELTS:
+        case IEEE80211_DBGREQ_SENDDELTS:
             pld->data.param[0] = adf_os_htonl(dbgreq->data.param[0]);
             break;
-        case ACFG_DBGREQ_SENDADDTSREQ:
+        case IEEE80211_DBGREQ_SENDADDTSREQ:
             pld->data.tsinfo.traffic_type = dbgreq->data.tsinfo.traffic_type;
             pld->data.tsinfo.direction = dbgreq->data.tsinfo.direction;
             pld->data.tsinfo.dot1Dtag = dbgreq->data.tsinfo.dot1Dtag;
@@ -3184,7 +3153,7 @@ atd_cfg_dbgreq(adf_drv_handle_t hdl, acfg_athdbg_req_t  *dbgreq)
             pld->data.tsinfo.surplus_bw = adf_os_htons(dbgreq->data.tsinfo.surplus_bw);
             pld->data.tsinfo.medium_time = adf_os_htons(dbgreq->data.tsinfo.medium_time);
             break;
-        case ACFG_DBGREQ_SENDLCIREQ:
+        case IEEE80211_DBGREQ_SENDLCIREQ:
             adf_os_mem_copy(pld->data.lci_req.dstmac, dbgreq->data.lci_req.dstmac, 6);
             pld->data.lci_req.num_rpts = adf_os_htons(dbgreq->data.lci_req.num_rpts);
             pld->data.lci_req.location = dbgreq->data.lci_req.location;
@@ -3194,7 +3163,7 @@ atd_cfg_dbgreq(adf_drv_handle_t hdl, acfg_athdbg_req_t  *dbgreq)
             pld->data.lci_req.azi_res = dbgreq->data.lci_req.azi_res;
             pld->data.lci_req.azi_type = dbgreq->data.lci_req.azi_type;
             break;
-        case ACFG_DBGREQ_GETRRMSTATS:
+        case IEEE80211_DBGREQ_GETRRMSTATS:
             pld->data.rrmstats_req.index = adf_os_htonl(dbgreq->data.rrmstats_req.index);
             pld->data.rrmstats_req.data_size = adf_os_htonl(dbgreq->data.rrmstats_req.data_size);
             rrm_stats = (atd_rrmstats_t *)(pld + 1);
@@ -3301,14 +3270,14 @@ atd_cfg_dbgreq(adf_drv_handle_t hdl, acfg_athdbg_req_t  *dbgreq)
             rrm_stats->ni_rrm_stats.ni_vap_lciinfo.long_frac = adf_os_htonl(rrmstats->ni_rrm_stats.ni_vap_lciinfo.long_frac);
             rrm_stats->ni_rrm_stats.ni_vap_lciinfo.alt_integ = adf_os_htonl(rrmstats->ni_rrm_stats.ni_vap_lciinfo.alt_integ);
             break;
-        case ACFG_DBGREQ_SENDFRMREQ:
+        case IEEE80211_DBGREQ_SENDFRMREQ:
             adf_os_mem_copy(pld->data.frm_req.dstmac, dbgreq->data.frm_req.dstmac, 6);
             adf_os_mem_copy(pld->data.frm_req.peermac, dbgreq->data.frm_req.peermac, 6);
             pld->data.frm_req.num_rpts = adf_os_htons(dbgreq->data.frm_req.num_rpts);
             pld->data.frm_req.regclass = dbgreq->data.frm_req.regclass;
             pld->data.frm_req.chnum = dbgreq->data.frm_req.chnum;
             break;
-        case ACFG_DBGREQ_GETBCNRPT:
+        case IEEE80211_DBGREQ_GETBCNRPT:
             pld->data.rrmstats_req.index = adf_os_htonl(dbgreq->data.rrmstats_req.index);
             pld->data.rrmstats_req.data_size = adf_os_htonl(dbgreq->data.rrmstats_req.data_size);
             bcn_rpt = (atd_bcnrpt_t *)(pld + 1);
@@ -3319,9 +3288,9 @@ atd_cfg_dbgreq(adf_drv_handle_t hdl, acfg_athdbg_req_t  *dbgreq)
             bcn_rpt->chnum = bcnrpt->chnum;
             bcn_rpt->more = bcnrpt->more;
             break;
-        case ACFG_DBGREQ_GETRRSSI:
+        case IEEE80211_DBGREQ_GETRRSSI:
             break;
-        case ACFG_DBGREQ_GETACSREPORT:
+        case IEEE80211_DBGREQ_GETACSREPORT:
             pld->data.acs_rep.index = adf_os_htonl(dbgreq->data.acs_rep.index);
             pld->data.acs_rep.data_size = adf_os_htonl(dbgreq->data.acs_rep.data_size);
             acs_dbg = (atd_acs_dbg_t *)(pld + 1);
@@ -3338,37 +3307,49 @@ atd_cfg_dbgreq(adf_drv_handle_t hdl, acfg_athdbg_req_t  *dbgreq)
             acs_dbg->chan_load = adf_os_htonl(acsdbg->chan_load);
             acs_dbg->sec_chan = acsdbg->sec_chan;
             break;
-#if 0
-        case ACFG_DBGREQ_BSTEERING_SET_PARAMS:
-            pld->data.bst.inactivity_timeout_normal = adf_os_htonl(dbgreq->data.bst.inactivity_timeout_normal);
-            pld->data.bst.inactivity_timeout_overload = adf_os_htonl(dbgreq->data.bst.inactivity_timeout_overload);
-            pld->data.bst.inactivity_check_period = adf_os_htonl(dbgreq->data.bst.inactivity_check_period);
-            pld->data.bst.utilization_sample_period = adf_os_htonl(dbgreq->data.bst.utilization_sample_period);
-            pld->data.bst.utilization_average_num_samples = adf_os_htonl(dbgreq->data.bst.utilization_average_num_samples);
-            pld->data.bst.inactive_rssi_crossing_threshold = adf_os_htonl(dbgreq->data.bst.inactive_rssi_crossing_threshold);
-            pld->data.bst.low_rssi_crossing_threshold = adf_os_htonl(dbgreq->data.bst.low_rssi_crossing_threshold);
+
+        case IEEE80211_DBGREQ_BSTEERING_SET_PARAMS:
+	    memcpy(&pld->data.bsteering_param, &dbgreq->data.bsteering_param, sizeof(dbgreq->data.bsteering_param));
+            pld->data.bsteering_param.inactivity_timeout_normal = adf_os_htonl(dbgreq->data.bsteering_param.inactivity_timeout_normal);
+            pld->data.bsteering_param.inactivity_timeout_overload = adf_os_htonl(dbgreq->data.bsteering_param.inactivity_timeout_overload);
+            pld->data.bsteering_param.inactivity_check_period = adf_os_htonl(dbgreq->data.bsteering_param.inactivity_check_period);
+            pld->data.bsteering_param.utilization_sample_period = adf_os_htonl(dbgreq->data.bsteering_param.utilization_sample_period);
+            pld->data.bsteering_param.utilization_average_num_samples = adf_os_htonl(dbgreq->data.bsteering_param.utilization_average_num_samples);
+            pld->data.bsteering_param.inactive_rssi_xing_high_threshold = adf_os_htonl(dbgreq->data.bsteering_param.inactive_rssi_xing_high_threshold);
+            pld->data.bsteering_param.inactive_rssi_xing_low_threshold = adf_os_htonl(dbgreq->data.bsteering_param.inactive_rssi_xing_low_threshold);
+            pld->data.bsteering_param.low_rssi_crossing_threshold = adf_os_htonl(dbgreq->data.bsteering_param.low_rssi_crossing_threshold);
             break;
-        case ACFG_DBGREQ_BSTEERING_GET_PARAMS:
+        case IEEE80211_DBGREQ_BSTEERING_GET_PARAMS:
             break;
-        case ACFG_DBGREQ_BSTEERING_SET_DBG_PARAMS:
-            pld->data.bst_dbg.raw_log_enable = dbgreq->data.bst_dbg.raw_log_enable;
+        case IEEE80211_DBGREQ_BSTEERING_SET_DBG_PARAMS:
+            pld->data.bsteering_dbg_param.raw_chan_util_log_enable = dbgreq->data.bsteering_dbg_param.raw_chan_util_log_enable;
+            pld->data.bsteering_dbg_param.raw_rssi_log_enable = dbgreq->data.bsteering_dbg_param.raw_rssi_log_enable;
             break;
-        case ACFG_DBGREQ_BSTEERING_GET_DBG_PARAMS:
+        case IEEE80211_DBGREQ_BSTEERING_GET_DBG_PARAMS:
             break;
-        case ACFG_DBGREQ_BSTEERING_ENABLE:
+        case IEEE80211_DBGREQ_BSTEERING_ENABLE:
+        case IEEE80211_DBGREQ_BSTEERING_ENABLE_EVENTS: // Notice Fall through
             pld->data.bsteering_enable = dbgreq->data.bsteering_enable;
             break;
-        case ACFG_DBGREQ_BSTEERING_SET_OVERLOAD:
+        case IEEE80211_DBGREQ_BSTEERING_SET_OVERLOAD:
             pld->data.bsteering_overload = dbgreq->data.bsteering_overload;
             break;
-        case ACFG_DBGREQ_BSTEERING_GET_OVERLOAD:
+        case IEEE80211_DBGREQ_BSTEERING_GET_OVERLOAD:
             break;
-        case ACFG_DBGREQ_BSTEERING_GET_RSSI:
+        case IEEE80211_DBGREQ_BSTEERING_GET_RSSI:
             break;
-        case ACFG_DBGREQ_BSTEERING_SET_PROBE_RESP_WH:
+        case IEEE80211_DBGREQ_BSTEERING_SET_PROBE_RESP_WH:
             pld->data.bsteering_probe_resp_wh = dbgreq->data.bsteering_probe_resp_wh;
             break;
-#endif            
+        case IEEE80211_DBGREQ_BSTEERING_GET_DATARATE_INFO:
+            pld->data.bsteering_datarate_info.max_chwidth =  dbgreq->data.bsteering_datarate_info.max_chwidth;
+            pld->data.bsteering_datarate_info.num_streams =  dbgreq->data.bsteering_datarate_info.num_streams;
+            pld->data.bsteering_datarate_info.phymode =  dbgreq->data.bsteering_datarate_info.phymode;
+            pld->data.bsteering_datarate_info.max_MCS =  dbgreq->data.bsteering_datarate_info.max_MCS;
+            pld->data.bsteering_datarate_info.max_txpower =  dbgreq->data.bsteering_datarate_info.max_txpower;
+            pld->data.bsteering_datarate_info.is_static_smps =  dbgreq->data.bsteering_datarate_info.is_static_smps;
+            pld->data.bsteering_datarate_info.is_mu_mimo_supported =  dbgreq->data.bsteering_datarate_info.is_mu_mimo_supported;
+            break;
         default:
             break;
     }
@@ -3383,17 +3364,17 @@ atd_cfg_dbgreq(adf_drv_handle_t hdl, acfg_athdbg_req_t  *dbgreq)
     dbgreq->cmd = resp_buf->cmd;
     adf_os_mem_copy(dbgreq->dstmac, resp_buf->dstmac, ACFG_MACADDR_LEN);
     switch (dbgreq->cmd) {
-        case ACFG_DBGREQ_SENDADDBA:
-        case ACFG_DBGREQ_SENDDELBA:
-        case ACFG_DBGREQ_SETADDBARESP:
-        case ACFG_DBGREQ_GETADDBASTATS:
-        case ACFG_DBGREQ_SENDSINGLEAMSDU:
+        case IEEE80211_DBGREQ_SENDADDBA:
+        case IEEE80211_DBGREQ_SENDDELBA:
+        case IEEE80211_DBGREQ_SETADDBARESP:
+        case IEEE80211_DBGREQ_GETADDBASTATS:
+        case IEEE80211_DBGREQ_SENDSINGLEAMSDU:
             dbgreq->data.param[0] = adf_os_ntohl(resp_buf->data.param[0]);
             dbgreq->data.param[1] = adf_os_ntohl(resp_buf->data.param[1]);
             dbgreq->data.param[2] = adf_os_ntohl(resp_buf->data.param[2]);
             dbgreq->data.param[3] = adf_os_ntohl(resp_buf->data.param[3]);
             break;
-        case ACFG_DBGREQ_SENDBCNRPT:
+        case IEEE80211_DBGREQ_SENDBCNRPT:
             dbgreq->data.bcnrpt.num_rpt = adf_os_ntohs(resp_buf->data.bcnrpt.num_rpt);
             dbgreq->data.bcnrpt.regclass = resp_buf->data.bcnrpt.regclass;
             dbgreq->data.bcnrpt.channum = resp_buf->data.bcnrpt.channum;
@@ -3416,7 +3397,7 @@ atd_cfg_dbgreq(adf_drv_handle_t hdl, acfg_athdbg_req_t  *dbgreq)
                     dbgreq->data.bcnrpt.apchanrep[i].channum[j] = resp_buf->data.bcnrpt.apchanrep[i].channum[j];
             }
             break;
-        case ACFG_DBGREQ_SENDTSMRPT:
+        case IEEE80211_DBGREQ_SENDTSMRPT:
             dbgreq->data.tsmrpt.num_rpt = adf_os_ntohs(resp_buf->data.tsmrpt.num_rpt);
             dbgreq->data.tsmrpt.rand_ivl = adf_os_ntohs(resp_buf->data.tsmrpt.rand_ivl);
             dbgreq->data.tsmrpt.meas_dur = adf_os_ntohs(resp_buf->data.tsmrpt.meas_dur);
@@ -3432,21 +3413,21 @@ atd_cfg_dbgreq(adf_drv_handle_t hdl, acfg_athdbg_req_t  *dbgreq)
             dbgreq->data.tsmrpt.meas_count = resp_buf->data.tsmrpt.meas_count;
             dbgreq->data.tsmrpt.trig_timeout = resp_buf->data.tsmrpt.trig_timeout;
             break;
-        case ACFG_DBGREQ_SENDNEIGRPT:
+        case IEEE80211_DBGREQ_SENDNEIGRPT:
             dbgreq->data.neigrpt.dialogtoken = resp_buf->data.neigrpt.dialogtoken;
             adf_os_mem_copy(dbgreq->data.neigrpt.ssid, resp_buf->data.neigrpt.ssid, 32);
             dbgreq->data.neigrpt.ssid_len = resp_buf->data.neigrpt.ssid_len;
             break;
-        case ACFG_DBGREQ_SENDLMREQ:
+        case IEEE80211_DBGREQ_SENDLMREQ:
             break;
-        case ACFG_DBGREQ_SENDBSTMREQ:
+        case IEEE80211_DBGREQ_SENDBSTMREQ:
             dbgreq->data.bstmreq.dialogtoken = resp_buf->data.bstmreq.dialogtoken;
             dbgreq->data.bstmreq.candidate_list = resp_buf->data.bstmreq.candidate_list;
             dbgreq->data.bstmreq.disassoc = resp_buf->data.bstmreq.disassoc;
             dbgreq->data.bstmreq.disassoc_timer = adf_os_ntohs(resp_buf->data.bstmreq.disassoc_timer);
             dbgreq->data.bstmreq.validity_itvl = resp_buf->data.bstmreq.validity_itvl;
             break;
-        case ACFG_DBGREQ_SENDCHLOADREQ:
+        case IEEE80211_DBGREQ_SENDCHLOADREQ:
             adf_os_mem_copy(dbgreq->data.chloadrpt.dstmac, resp_buf->data.chloadrpt.dstmac, 6);
             dbgreq->data.chloadrpt.num_rpts = adf_os_ntohs(resp_buf->data.chloadrpt.num_rpts);
             dbgreq->data.chloadrpt.regclass = resp_buf->data.chloadrpt.regclass;
@@ -3456,14 +3437,14 @@ atd_cfg_dbgreq(adf_drv_handle_t hdl, acfg_athdbg_req_t  *dbgreq)
             dbgreq->data.chloadrpt.cond = resp_buf->data.chloadrpt.cond;
             dbgreq->data.chloadrpt.c_val = resp_buf->data.chloadrpt.c_val;
             break;
-        case ACFG_DBGREQ_SENDSTASTATSREQ:
+        case IEEE80211_DBGREQ_SENDSTASTATSREQ:
             adf_os_mem_copy(dbgreq->data.stastats.dstmac, resp_buf->data.stastats.dstmac, 6);
             dbgreq->data.stastats.num_rpts = adf_os_ntohs(resp_buf->data.stastats.num_rpts);
             dbgreq->data.stastats.m_dur = adf_os_ntohs(resp_buf->data.stastats.m_dur);
             dbgreq->data.stastats.r_invl = adf_os_ntohs(resp_buf->data.stastats.r_invl);
             dbgreq->data.stastats.gid = resp_buf->data.stastats.gid;
             break;
-        case ACFG_DBGREQ_SENDNHIST:
+        case IEEE80211_DBGREQ_SENDNHIST:
             dbgreq->data.nhist.num_rpts = adf_os_ntohs(resp_buf->data.nhist.num_rpts);
             adf_os_mem_copy(dbgreq->data.nhist.dstmac, resp_buf->data.nhist.dstmac, 6);
             dbgreq->data.nhist.regclass = resp_buf->data.nhist.regclass;
@@ -3473,10 +3454,10 @@ atd_cfg_dbgreq(adf_drv_handle_t hdl, acfg_athdbg_req_t  *dbgreq)
             dbgreq->data.nhist.cond = resp_buf->data.nhist.cond;
             dbgreq->data.nhist.c_val = resp_buf->data.nhist.c_val;
             break;
-        case ACFG_DBGREQ_SENDDELTS:
+        case IEEE80211_DBGREQ_SENDDELTS:
             dbgreq->data.param[0] = adf_os_ntohl(resp_buf->data.param[0]);
             break;
-        case ACFG_DBGREQ_SENDADDTSREQ:
+        case IEEE80211_DBGREQ_SENDADDTSREQ:
             dbgreq->data.tsinfo.traffic_type = resp_buf->data.tsinfo.traffic_type;
             dbgreq->data.tsinfo.direction = resp_buf->data.tsinfo.direction;
             dbgreq->data.tsinfo.dot1Dtag = resp_buf->data.tsinfo.dot1Dtag;
@@ -3502,7 +3483,7 @@ atd_cfg_dbgreq(adf_drv_handle_t hdl, acfg_athdbg_req_t  *dbgreq)
             dbgreq->data.tsinfo.surplus_bw = adf_os_ntohs(resp_buf->data.tsinfo.surplus_bw);
             dbgreq->data.tsinfo.medium_time = adf_os_ntohs(resp_buf->data.tsinfo.medium_time);
             break;
-        case ACFG_DBGREQ_SENDLCIREQ:
+        case IEEE80211_DBGREQ_SENDLCIREQ:
             adf_os_mem_copy(dbgreq->data.lci_req.dstmac, resp_buf->data.lci_req.dstmac, 6);
             dbgreq->data.lci_req.num_rpts = adf_os_ntohs(resp_buf->data.lci_req.num_rpts);
             dbgreq->data.lci_req.location = resp_buf->data.lci_req.location;
@@ -3512,7 +3493,7 @@ atd_cfg_dbgreq(adf_drv_handle_t hdl, acfg_athdbg_req_t  *dbgreq)
             dbgreq->data.lci_req.azi_res = resp_buf->data.lci_req.azi_res;
             dbgreq->data.lci_req.azi_type = resp_buf->data.lci_req.azi_type;
             break;
-        case ACFG_DBGREQ_GETRRMSTATS:
+        case IEEE80211_DBGREQ_GETRRMSTATS:
             dbgreq->data.rrmstats_req.index = adf_os_ntohl(resp_buf->data.rrmstats_req.index);
             dbgreq->data.rrmstats_req.data_size = adf_os_ntohl(resp_buf->data.rrmstats_req.data_size);
             rrm_stats = (atd_rrmstats_t *)(resp_buf + 1);
@@ -3619,14 +3600,14 @@ atd_cfg_dbgreq(adf_drv_handle_t hdl, acfg_athdbg_req_t  *dbgreq)
             rrmstats->ni_rrm_stats.ni_vap_lciinfo.long_frac = adf_os_ntohl(rrm_stats->ni_rrm_stats.ni_vap_lciinfo.long_frac);
             rrmstats->ni_rrm_stats.ni_vap_lciinfo.alt_integ = adf_os_ntohl(rrm_stats->ni_rrm_stats.ni_vap_lciinfo.alt_integ);
             break;
-        case ACFG_DBGREQ_SENDFRMREQ:
+        case IEEE80211_DBGREQ_SENDFRMREQ:
             adf_os_mem_copy(dbgreq->data.frm_req.dstmac, resp_buf->data.frm_req.dstmac, 6);
             adf_os_mem_copy(dbgreq->data.frm_req.peermac, resp_buf->data.frm_req.peermac, 6);
             dbgreq->data.frm_req.num_rpts = adf_os_ntohs(resp_buf->data.frm_req.num_rpts);
             dbgreq->data.frm_req.regclass = resp_buf->data.frm_req.regclass;
             dbgreq->data.frm_req.chnum = resp_buf->data.frm_req.chnum;
             break;
-        case ACFG_DBGREQ_GETBCNRPT:
+        case IEEE80211_DBGREQ_GETBCNRPT:
             dbgreq->data.rrmstats_req.index = adf_os_ntohl(resp_buf->data.rrmstats_req.index);
             dbgreq->data.rrmstats_req.data_size = adf_os_ntohl(resp_buf->data.rrmstats_req.data_size);
             bcn_rpt = (atd_bcnrpt_t *)(resp_buf + 1);
@@ -3637,9 +3618,9 @@ atd_cfg_dbgreq(adf_drv_handle_t hdl, acfg_athdbg_req_t  *dbgreq)
             bcnrpt->chnum = bcn_rpt->chnum;
             bcnrpt->more = bcn_rpt->more;
             break;
-        case ACFG_DBGREQ_GETRRSSI:
+        case IEEE80211_DBGREQ_GETRRSSI:
             break;
-        case ACFG_DBGREQ_GETACSREPORT:
+        case IEEE80211_DBGREQ_GETACSREPORT:
             dbgreq->data.acs_rep.index = adf_os_ntohl(resp_buf->data.acs_rep.index);
             dbgreq->data.acs_rep.data_size = adf_os_ntohl(resp_buf->data.acs_rep.data_size);
             acs_dbg = (atd_acs_dbg_t *)(resp_buf + 1);
@@ -3656,37 +3637,48 @@ atd_cfg_dbgreq(adf_drv_handle_t hdl, acfg_athdbg_req_t  *dbgreq)
             acsdbg->chan_load = adf_os_ntohl(acs_dbg->chan_load);
             acsdbg->sec_chan = acs_dbg->sec_chan;
             break;
-#if 0
-        case ACFG_DBGREQ_BSTEERING_SET_PARAMS:
+        case IEEE80211_DBGREQ_BSTEERING_SET_PARAMS:
             break;
-        case ACFG_DBGREQ_BSTEERING_GET_PARAMS:
-            dbgreq->data.bst.inactivity_timeout_normal = adf_os_ntohl(resp_buf->data.bst.inactivity_timeout_normal);
-            dbgreq->data.bst.inactivity_timeout_overload = adf_os_ntohl(resp_buf->data.bst.inactivity_timeout_overload);
-            dbgreq->data.bst.inactivity_check_period = adf_os_ntohl(resp_buf->data.bst.inactivity_check_period);
-            dbgreq->data.bst.utilization_sample_period = adf_os_ntohl(resp_buf->data.bst.utilization_sample_period);
-            dbgreq->data.bst.utilization_average_num_samples = adf_os_ntohl(resp_buf->data.bst.utilization_average_num_samples);
-            dbgreq->data.bst.inactive_rssi_crossing_threshold = adf_os_ntohl(resp_buf->data.bst.inactive_rssi_crossing_threshold);
-            dbgreq->data.bst.low_rssi_crossing_threshold = adf_os_ntohl(resp_buf->data.bst.low_rssi_crossing_threshold);
+        case IEEE80211_DBGREQ_BSTEERING_GET_PARAMS:
+	    memcpy(&dbgreq->data.bsteering_param, &resp_buf->data.bsteering_param, sizeof(dbgreq->data.bsteering_param));
+            dbgreq->data.bsteering_param.inactivity_timeout_normal = adf_os_ntohl(resp_buf->data.bsteering_param.inactivity_timeout_normal);
+            dbgreq->data.bsteering_param.inactivity_timeout_overload = adf_os_ntohl(resp_buf->data.bsteering_param.inactivity_timeout_overload);
+            dbgreq->data.bsteering_param.inactivity_check_period = adf_os_ntohl(resp_buf->data.bsteering_param.inactivity_check_period);
+            dbgreq->data.bsteering_param.utilization_sample_period = adf_os_ntohl(resp_buf->data.bsteering_param.utilization_sample_period);
+            dbgreq->data.bsteering_param.utilization_average_num_samples = adf_os_ntohl(resp_buf->data.bsteering_param.utilization_average_num_samples);
+            dbgreq->data.bsteering_param.inactive_rssi_xing_high_threshold = adf_os_ntohl(resp_buf->data.bsteering_param.inactive_rssi_xing_high_threshold);
+            dbgreq->data.bsteering_param.inactive_rssi_xing_low_threshold = adf_os_ntohl(resp_buf->data.bsteering_param.inactive_rssi_xing_low_threshold);
+            dbgreq->data.bsteering_param.low_rssi_crossing_threshold = adf_os_ntohl(resp_buf->data.bsteering_param.low_rssi_crossing_threshold);
             break;
-        case ACFG_DBGREQ_BSTEERING_SET_DBG_PARAMS:
+        case IEEE80211_DBGREQ_BSTEERING_SET_DBG_PARAMS:
             break;
-        case ACFG_DBGREQ_BSTEERING_GET_DBG_PARAMS:
-            dbgreq->data.bst_dbg.raw_log_enable = resp_buf->data.bst_dbg.raw_log_enable;
+        case IEEE80211_DBGREQ_BSTEERING_GET_DBG_PARAMS:
+            dbgreq->data.bsteering_dbg_param.raw_chan_util_log_enable = resp_buf->data.bsteering_dbg_param.raw_chan_util_log_enable;
+            dbgreq->data.bsteering_dbg_param.raw_rssi_log_enable = resp_buf->data.bsteering_dbg_param.raw_rssi_log_enable;
             break;
-        case ACFG_DBGREQ_BSTEERING_ENABLE:
+        case IEEE80211_DBGREQ_BSTEERING_ENABLE:
+        case IEEE80211_DBGREQ_BSTEERING_ENABLE_EVENTS: // Notice Fall through
             break;
-        case ACFG_DBGREQ_BSTEERING_SET_OVERLOAD:
+        case IEEE80211_DBGREQ_BSTEERING_SET_OVERLOAD:
             break;
-        case ACFG_DBGREQ_BSTEERING_GET_OVERLOAD:
+        case IEEE80211_DBGREQ_BSTEERING_GET_OVERLOAD:
             dbgreq->data.bsteering_overload = resp_buf->data.bsteering_overload;
             break;
-        case ACFG_DBGREQ_BSTEERING_GET_RSSI:
-            adf_os_mem_copy(dbgreq->data.bst_rssi_req.sender_addr, resp_buf->data.bst_rssi_req.sender_addr, 6);
-            dbgreq->data.bst_rssi_req.num_measurements = adf_os_ntohs(resp_buf->data.bst_rssi_req.num_measurements);
+        case IEEE80211_DBGREQ_BSTEERING_GET_RSSI:
+            adf_os_mem_copy(dbgreq->data.bsteering_rssi_req.sender_addr, resp_buf->data.bsteering_rssi_req.sender_addr, 6);
+            dbgreq->data.bsteering_rssi_req.num_measurements = adf_os_ntohs(resp_buf->data.bsteering_rssi_req.num_measurements);
             break;
-        case ACFG_DBGREQ_BSTEERING_SET_PROBE_RESP_WH:
+        case IEEE80211_DBGREQ_BSTEERING_SET_PROBE_RESP_WH:
+            break;
+        case IEEE80211_DBGREQ_BSTEERING_GET_DATARATE_INFO:
+            dbgreq->data.bsteering_datarate_info.max_chwidth = resp_buf->data.bsteering_datarate_info.max_chwidth;
+            dbgreq->data.bsteering_datarate_info.num_streams =  resp_buf->data.bsteering_datarate_info.num_streams;
+            dbgreq->data.bsteering_datarate_info.phymode =  resp_buf->data.bsteering_datarate_info.phymode;
+            dbgreq->data.bsteering_datarate_info.max_MCS =  resp_buf->data.bsteering_datarate_info.max_MCS;
+            dbgreq->data.bsteering_datarate_info.max_txpower =  resp_buf->data.bsteering_datarate_info.max_txpower;
+            dbgreq->data.bsteering_datarate_info.is_static_smps =  resp_buf->data.bsteering_datarate_info.is_static_smps;
+            dbgreq->data.bsteering_datarate_info.is_mu_mimo_supported =  resp_buf->data.bsteering_datarate_info.is_mu_mimo_supported;
             break;
-#endif
         default:
             break;
     }
@@ -3699,15 +3691,15 @@ fail:
     return status;
 }
 
-/** 
+/**
  * @brief Set Appiebuf
- * 
+ *
  * @param hdl
  * @param appiebuf
- * 
- * @return 
+ *
+ * @return
  */
-a_status_t 
+a_status_t
 atd_cfg_set_appiebuf(adf_drv_handle_t hdl, acfg_appie_t  *appiebuf)
 {
     atd_host_vap_t     *vap    = (atd_host_vap_t * )hdl;
@@ -3725,12 +3717,12 @@ atd_cfg_set_appiebuf(adf_drv_handle_t hdl, acfg_appie_t  *appiebuf)
         goto fail ;
     }
 
-    pld = (atd_appie_t *)atd_prep_cfg_hdr(nbuf, sizeof(atd_appie_t) + 
-                                          appiebuf->buflen, wifi, vap);
+    pld = (atd_appie_t *)atd_prep_cfg_hdr(nbuf, sizeof(atd_appie_t) +
+                                          appiebuf->app_buflen, wifi, vap);
 
-    pld->frmtype = adf_os_htonl(appiebuf->frmtype);
-    pld->buflen = adf_os_htonl(appiebuf->buflen);
-    adf_os_mem_copy(pld->buf, appiebuf->buf, appiebuf->buflen);
+    pld->app_frmtype = adf_os_htonl(appiebuf->app_frmtype);
+    pld->app_buflen = adf_os_htonl(appiebuf->app_buflen);
+    adf_os_mem_copy(pld->app_buf, appiebuf->app_buf, appiebuf->app_buflen);
 
     status = wmi_cmd_send(__wifi2wmi(wifi), WMI_CMD_APPIEBUF_SET, nbuf,
             NULL, 0);
@@ -3741,15 +3733,15 @@ fail:
 }
 
 
-/** 
+/**
  * @brief  Set Key
- * 
+ *
  * @param hdl
  * @param setkey
- * 
- * @return 
+ *
+ * @return
  */
-a_status_t 
+a_status_t
 atd_cfg_set_key(adf_drv_handle_t hdl, acfg_key_t  *setkey)
 {
     atd_host_vap_t     *vap    = (atd_host_vap_t * )hdl;
@@ -3768,15 +3760,17 @@ atd_cfg_set_key(adf_drv_handle_t hdl, acfg_key_t  *setkey)
 
     pld = (atd_key_t *)atd_prep_cfg_hdr(nbuf, sizeof(atd_key_t), wifi, vap);
 
-    pld->type = setkey->type;
-    pld->pad = setkey->pad;
-    pld->keyix = adf_os_htons(setkey->keyix);
-    pld->keylen = setkey->keylen;
-    pld->flags = setkey->flags;
-    adf_os_mem_copy(pld->macaddr, setkey->macaddr, ACFG_MACADDR_LEN);
-    pld->keyrsc = adf_os_cpu_to_be64(setkey->keyrsc);
-    pld->keytsc = adf_os_cpu_to_be64(setkey->keytsc);
-    adf_os_mem_copy(pld->keydata, setkey->keydata, ACFG_KEYDATA_LEN);
+    memcpy(pld, setkey, sizeof(*pld));
+
+    pld->ik_type = setkey->ik_type;
+    pld->ik_pad = setkey->ik_pad;
+    pld->ik_keyix = adf_os_htons(setkey->ik_keyix);
+    pld->ik_keylen = setkey->ik_keylen;
+    pld->ik_flags = setkey->ik_flags;
+    adf_os_mem_copy(pld->ik_macaddr, setkey->ik_macaddr, ACFG_MACADDR_LEN);
+    pld->ik_keyrsc = adf_os_cpu_to_be64(setkey->ik_keyrsc);
+    pld->ik_keytsc = adf_os_cpu_to_be64(setkey->ik_keytsc);
+    adf_os_mem_copy(pld->ik_keydata, setkey->ik_keydata, ACFG_KEYDATA_LEN);
 
     status = wmi_cmd_send(__wifi2wmi(wifi), WMI_CMD_SET_KEY, nbuf,
                           NULL, 0);
@@ -3788,15 +3782,15 @@ fail:
 
 
 
-/** 
+/**
  * @brief del key
- * 
+ *
  * @param hdl
  * @param delkey
- * 
- * @return 
+ *
+ * @return
  */
-a_status_t 
+a_status_t
 atd_cfg_del_key(adf_drv_handle_t hdl, acfg_delkey_t  *delkey)
 {
     atd_host_vap_t     *vap    = (atd_host_vap_t * )hdl;
@@ -3817,7 +3811,7 @@ atd_cfg_del_key(adf_drv_handle_t hdl, acfg_delkey_t  *delkey)
 
     pld->idx = delkey->idx;
     adf_os_mem_copy(pld->addr, delkey->addr, ACFG_MACADDR_LEN);
-    
+
     status = wmi_cmd_send(__wifi2wmi(wifi), WMI_CMD_DEL_KEY, nbuf,
                           NULL, 0);
 
@@ -3830,14 +3824,14 @@ fail:
 
 
 
-/** 
+/**
  * @brief Get Key
- * 
+ *
  * @param hdl
  * @param buff
  * @param buflen
- * 
- * @return 
+ *
+ * @return
  */
 static a_status_t
 atd_cfg_get_key(adf_drv_handle_t hdl, a_uint8_t *buff, a_uint32_t buflen)
@@ -3853,7 +3847,7 @@ atd_cfg_get_key(adf_drv_handle_t hdl, a_uint8_t *buff, a_uint32_t buflen)
     atd_trace((ATD_DEBUG_FUNCTRACE | ATD_DEBUG_CFG), ("get key = %p", buff ));
 
     if (buflen != sizeof(acfg_key_t)) {
-        atd_trace(ATD_DEBUG_CFG, ("Keylen invalid %d, expected %d \n", 
+        atd_trace(ATD_DEBUG_CFG, ("Keylen invalid %d, expected %d \n",
                   buflen, sizeof(acfg_key_t)));
         status = A_STATUS_EINVAL;
         goto fail ;
@@ -3872,28 +3866,32 @@ atd_cfg_get_key(adf_drv_handle_t hdl, a_uint8_t *buff, a_uint32_t buflen)
 
     atd_trace(ATD_DEBUG_CFG, ("User sent buflen = %d\n",buflen));
 
-    pld->type = getkey->type;
-    pld->pad = getkey->pad;
-    pld->keyix = adf_os_htons(getkey->keyix);
-    pld->keylen = getkey->keylen;
-    pld->flags = getkey->flags;
-    adf_os_mem_copy(pld->macaddr, getkey->macaddr, ACFG_MACADDR_LEN);
-    pld->keyrsc = adf_os_cpu_to_be64(getkey->keyrsc);
-    pld->keytsc = adf_os_cpu_to_be64(getkey->keytsc);
-    adf_os_mem_copy(pld->keydata, getkey->keydata, ACFG_KEYDATA_LEN);
+    memcpy(pld, getkey, sizeof (*pld));
+
+    pld->ik_type = getkey->ik_type;
+    pld->ik_pad = getkey->ik_pad;
+    pld->ik_keyix = adf_os_htons(getkey->ik_keyix);
+    pld->ik_keylen = getkey->ik_keylen;
+    pld->ik_flags = getkey->ik_flags;
+    adf_os_mem_copy(pld->ik_macaddr, getkey->ik_macaddr, ACFG_MACADDR_LEN);
+    pld->ik_keyrsc = adf_os_cpu_to_be64(getkey->ik_keyrsc);
+    pld->ik_keytsc = adf_os_cpu_to_be64(getkey->ik_keytsc);
+    adf_os_mem_copy(pld->ik_keydata, getkey->ik_keydata, ACFG_KEYDATA_LEN);
 
     status      = wmi_cmd_send(__wifi2wmi(wifi), WMI_CMD_GET_KEY, nbuf,
                           (a_uint8_t *)(&result), sizeof(atd_key_t));
 
-    getkey->type = result.type;
-    getkey->pad = result.pad;
-    getkey->keyix = adf_os_ntohs(result.keyix);
-    getkey->keylen = result.keylen;
-    getkey->flags = result.flags;
-    adf_os_mem_copy(getkey->macaddr, result.macaddr, ACFG_MACADDR_LEN);
-    getkey->keyrsc = adf_os_be64_to_cpu(result.keyrsc);
-    getkey->keytsc = adf_os_be64_to_cpu(result.keytsc);
-    adf_os_mem_copy(getkey->keydata, result.keydata, ACFG_KEYDATA_LEN);
+    memcpy(getkey, &result, sizeof (*getkey));
+
+    getkey->ik_type = result.ik_type;
+    getkey->ik_pad = result.ik_pad;
+    getkey->ik_keyix = adf_os_ntohs(result.ik_keyix);
+    getkey->ik_keylen = result.ik_keylen;
+    getkey->ik_flags = result.ik_flags;
+    adf_os_mem_copy(getkey->ik_macaddr, result.ik_macaddr, ACFG_MACADDR_LEN);
+    getkey->ik_keyrsc = adf_os_be64_to_cpu(result.ik_keyrsc);
+    getkey->ik_keytsc = adf_os_be64_to_cpu(result.ik_keytsc);
+    adf_os_mem_copy(getkey->ik_keydata, result.ik_keydata, ACFG_KEYDATA_LEN);
 
     atd_trace((ATD_DEBUG_FUNCTRACE | ATD_DEBUG_CFG), ("key   %p ", buff));
 
@@ -3903,14 +3901,14 @@ fail:
 }
 
 
-/** 
+/**
  * @brief Get STA Stats
- * 
+ *
  * @param hdl
  * @param buff
  * @param buflen
- * 
- * @return 
+ *
+ * @return
  */
 static a_status_t
 atd_cfg_get_sta_stats(adf_drv_handle_t hdl, a_uint8_t *buff, a_uint32_t buflen)
@@ -3949,7 +3947,7 @@ fail:
 }
 
 
-/** 
+/**
  * WMI Events
  */
 
@@ -3974,7 +3972,7 @@ PROTO_EVENT(if_running_sta);
 PROTO_EVENT(if_not_running_sta);
 PROTO_EVENT(leave_ap);
 PROTO_EVENT(gen_ie);
-//PROTO_EVENT(assoc_req_ie);
+PROTO_EVENT(assoc_req_ie);
 PROTO_EVENT(create_vap);
 PROTO_EVENT(delete_vap);
 PROTO_EVENT(restore_wifi);
@@ -4026,7 +4024,7 @@ const __atd_event_fn_t     atd_events[] = {
     EVENT_IDX(IF_NOT_RUNNING_STA) = atd_event_if_not_running_sta,
     EVENT_IDX(LEAVE_AP)       = atd_event_leave_ap,
     EVENT_IDX(GEN_IE)         = atd_event_gen_ie,
-    //EVENT_IDX(ASSOC_REQ_IE)   = atd_event_assoc_req_ie,
+    EVENT_IDX(ASSOC_REQ_IE)   = atd_event_assoc_req_ie,
     EVENT_IDX(IW_CUSTOM)      = atd_event_iw_custom,
     EVENT_IDX(IW_ASSOCREQIE)  = atd_event_iw_assocreqie,
 
@@ -4058,7 +4056,7 @@ const __atd_event_fn_t     atd_events[] = {
     /* LAN Bypass event */
     EVENT_IDX(BYP_VAP_LANEN)    = atd_event_byp_vap_lanen,
     EVENT_IDX(BYP_VAP_LANDIS)   = atd_event_byp_vap_landis,
-    
+
     EVENT_IDX(PROXYARP_SEND)    = atd_event_proxyarp_send,
 
     /* Spectral sample message */
@@ -4070,15 +4068,15 @@ const __atd_event_fn_t     atd_events[] = {
 #define max_event_num   \
     ((sizeof(atd_events)/sizeof(atd_events[0])) + WMI_EVENT_START)
 
-/** 
+/**
  * @brief ATD Event runner
- * 
+ *
  * @param dev_sc
  * @param id
  * @param buf
  */
 void
-atd_event_run(struct atd_host_dev *dev_sc, wmi_id_t   event, 
+atd_event_run(struct atd_host_dev *dev_sc, wmi_id_t   event,
               adf_nbuf_t  buf)
 {
     atd_hdr_t          *hdr;
@@ -4090,21 +4088,21 @@ atd_event_run(struct atd_host_dev *dev_sc, wmi_id_t   event,
 
     adf_nbuf_peek_header(buf, (a_uint8_t **)&hdr, &len);
     adf_nbuf_pull_head(buf, sizeof(struct atd_hdr));
-    
+
     wifi = dev_sc->wifi_list[hdr->wifi_index];
 
     if (hdr->vap_index < 0xFF)
         vap = wifi->vap_list[hdr->vap_index];
-    
+
     adf_os_assert(event < max_event_num);
-    
+
     if ((event == WMI_EVENT_CREATE_VAP) && (vap != NULL))
         event = WMI_EVENT_START;
-    
-    if (event > max_event_num) event = WMI_EVENT_START; 
+
+    if (event > max_event_num) event = WMI_EVENT_START;
 
     atd_events[EVENT_NUM(event)](wifi, vap, event, buf);
-  
+
     atd_trace(ATD_DEBUG_CFG, ("Freeing the event"));
 
     /* Freeing the event */
@@ -4114,40 +4112,38 @@ atd_event_run(struct atd_host_dev *dev_sc, wmi_id_t   event,
 }
 
 
-/** 
- * @brief 
- * 
+/**
+ * @brief
+ *
  * @param wifi
  * @param vap
  * @param wmi
  * @param buf
  */
-void  
-atd_event_none(atd_host_wifi_t  *wifi, atd_host_vap_t  *vap, 
+void
+atd_event_none(atd_host_wifi_t  *wifi, atd_host_vap_t  *vap,
                 wmi_id_t wmi, adf_nbuf_t  buf)
 {
     atd_trace(ATD_DEBUG_FUNCTRACE,("%s:unhandled event \n",adf_os_function));
 }
 
-/** 
- * @brief 
- * 
+/**
+ * @brief
+ *
  * @param wifi
  * @param vap
  * @param wmi
  * @param buf
  */
 void
-atd_event_iw_custom(atd_host_wifi_t   *wifi, atd_host_vap_t   *vap, 
+atd_event_iw_custom(atd_host_wifi_t   *wifi, atd_host_vap_t   *vap,
                     wmi_id_t wmi, adf_nbuf_t buf)
 {
     a_uint32_t          len     = 0;
     acfg_os_event_t     event   = {.id = ACFG_EV_MIC_FAIL};
-    acfg_wsupp_custom_message_t *data    = NULL; 
+    acfg_wsupp_custom_message_t *data    = NULL;
     acfg_wsupp_custom_message_t  *mic    = (void *)&event.data;
 
-    adf_os_assert(vap);
-
     atd_trace(ATD_DEBUG_FUNCTRACE, (" .START "));
 
     if (vap == NULL)
@@ -4163,16 +4159,16 @@ atd_event_iw_custom(atd_host_wifi_t   *wifi, atd_host_vap_t   *vap,
     atd_trace(ATD_DEBUG_FUNCTRACE, (" .END "));
 }
 
-/** 
- * @brief 
- * 
+/**
+ * @brief
+ *
  * @param wifi
  * @param vap
  * @param wmi
  * @param buf
  */
 void
-atd_event_iw_assocreqie(atd_host_wifi_t   *wifi, atd_host_vap_t   *vap, 
+atd_event_iw_assocreqie(atd_host_wifi_t   *wifi, atd_host_vap_t   *vap,
                     wmi_id_t wmi, adf_nbuf_t buf)
 {
     a_uint32_t          len      = 0;
@@ -4180,8 +4176,6 @@ atd_event_iw_assocreqie(atd_host_wifi_t   *wifi, atd_host_vap_t   *vap,
     acfg_os_event_t     event    = {.id = ACFG_EV_PROBE_REQ};
     acfg_probe_req_t   *pr_req   = (void *)&event.data;
 
-    adf_os_assert(vap);
-
     atd_trace(ATD_DEBUG_FUNCTRACE, (" .START "));
 
     if (vap == NULL)
@@ -4206,16 +4200,14 @@ done:
 }
 
 void
-atd_event_iw_auth_comp_ap(atd_host_wifi_t   *wifi, atd_host_vap_t   *vap, 
+atd_event_iw_auth_comp_ap(atd_host_wifi_t   *wifi, atd_host_vap_t   *vap,
                     wmi_id_t wmi, adf_nbuf_t buf)
 {
     a_uint32_t          len     = 0;
     acfg_os_event_t     event   = {.id = ACFG_EV_AUTH_AP};
-    atd_auth_t *data    = NULL; 
+    atd_auth_t *data    = NULL;
     acfg_auth_t  *auth    = (void *)&event.data;
 
-    adf_os_assert(vap);
-
     atd_trace(ATD_DEBUG_FUNCTRACE, (" .START "));
 
     if (vap == NULL)
@@ -4226,7 +4218,7 @@ atd_event_iw_auth_comp_ap(atd_host_wifi_t   *wifi, atd_host_vap_t   *vap,
 
 	auth->status  = adf_os_ntohl(data->status);
 	auth->frame_send  = data->frame_send;
-	
+
     adf_net_indicate_event(vap->nethandle, &event);
 
     atd_trace(ATD_DEBUG_FUNCTRACE, (" .END "));
@@ -4234,16 +4226,14 @@ atd_event_iw_auth_comp_ap(atd_host_wifi_t   *wifi, atd_host_vap_t   *vap,
 
 
 void
-atd_event_iw_assoc_comp_ap(atd_host_wifi_t   *wifi, atd_host_vap_t   *vap, 
+atd_event_iw_assoc_comp_ap(atd_host_wifi_t   *wifi, atd_host_vap_t   *vap,
                     wmi_id_t wmi, adf_nbuf_t buf)
 {
     a_uint32_t          len     = 0;
     acfg_os_event_t     event   = {.id = ACFG_EV_ASSOC_AP};
-    atd_assoc_t *data    = NULL; 
+    atd_assoc_t *data    = NULL;
     acfg_assoc_t  *assoc   = (void *)&event.data;
 
-    adf_os_assert(vap);
-
     atd_trace(ATD_DEBUG_FUNCTRACE, (" .START "));
 
     if (vap == NULL)
@@ -4254,23 +4244,21 @@ atd_event_iw_assoc_comp_ap(atd_host_wifi_t   *wifi, atd_host_vap_t   *vap,
 
 	assoc->status  = adf_os_ntohl(data->status);
 	assoc->frame_send  = data->frame_send;
-	
+
     adf_net_indicate_event(vap->nethandle, &event);
 
     atd_trace(ATD_DEBUG_FUNCTRACE, (" .END "));
 }
 
 void
-atd_event_iw_deauth_comp_ap(atd_host_wifi_t   *wifi, atd_host_vap_t   *vap, 
+atd_event_iw_deauth_comp_ap(atd_host_wifi_t   *wifi, atd_host_vap_t   *vap,
                     wmi_id_t wmi, adf_nbuf_t buf)
 {
     a_uint32_t          len     = 0;
     acfg_os_event_t     event   = {.id = ACFG_EV_DEAUTH_AP};
-    atd_dauth_t *data    = NULL; 
+    atd_dauth_t *data    = NULL;
     acfg_dauth_t  *deauth   = (void *)&event.data;
 
-    adf_os_assert(vap);
-
     atd_trace(ATD_DEBUG_FUNCTRACE, (" .START "));
 
     if (vap == NULL)
@@ -4282,7 +4270,7 @@ atd_event_iw_deauth_comp_ap(atd_host_wifi_t   *wifi, atd_host_vap_t   *vap,
 	deauth->status  = adf_os_ntohl(data->status);
 	deauth->frame_send  = data->frame_send;
     adf_os_mem_copy(deauth->macaddr, data->macaddr, ACFG_MACADDR_LEN);
-	
+
     adf_net_indicate_event(vap->nethandle, &event);
 
     atd_trace(ATD_DEBUG_FUNCTRACE, (" .END "));
@@ -4290,16 +4278,14 @@ atd_event_iw_deauth_comp_ap(atd_host_wifi_t   *wifi, atd_host_vap_t   *vap,
 
 
 void
-atd_event_iw_auth_ind_ap(atd_host_wifi_t   *wifi, atd_host_vap_t   *vap, 
+atd_event_iw_auth_ind_ap(atd_host_wifi_t   *wifi, atd_host_vap_t   *vap,
                     wmi_id_t wmi, adf_nbuf_t buf)
 {
     a_uint32_t          len     = 0;
     acfg_os_event_t     event   = {.id = ACFG_EV_AUTH_AP};
-    atd_auth_t *data    = NULL; 
+    atd_auth_t *data    = NULL;
     acfg_auth_t  *auth   = (void *)&event.data;
 
-    adf_os_assert(vap);
-
     atd_trace(ATD_DEBUG_FUNCTRACE, (" .START "));
 
     if (vap == NULL)
@@ -4311,23 +4297,21 @@ atd_event_iw_auth_ind_ap(atd_host_wifi_t   *wifi, atd_host_vap_t   *vap,
 	auth->status  = adf_os_ntohl(data->status);
 	auth->frame_send  = data->frame_send;
     adf_os_mem_copy(auth->macaddr, data->macaddr, ACFG_MACADDR_LEN);
-	
+
     adf_net_indicate_event(vap->nethandle, &event);
 
     atd_trace(ATD_DEBUG_FUNCTRACE, (" .END "));
 }
 
 void
-atd_event_iw_auth_comp_sta(atd_host_wifi_t   *wifi, atd_host_vap_t   *vap, 
+atd_event_iw_auth_comp_sta(atd_host_wifi_t   *wifi, atd_host_vap_t   *vap,
                     wmi_id_t wmi, adf_nbuf_t buf)
 {
     a_uint32_t          len     = 0;
     acfg_os_event_t     event   = {.id = ACFG_EV_AUTH_STA};
-    atd_auth_t *data    = NULL; 
+    atd_auth_t *data    = NULL;
     acfg_auth_t  *auth   = (void *)&event.data;
 
-    adf_os_assert(vap);
-
     atd_trace(ATD_DEBUG_FUNCTRACE, (" .START "));
 
     if (vap == NULL)
@@ -4338,23 +4322,21 @@ atd_event_iw_auth_comp_sta(atd_host_wifi_t   *wifi, atd_host_vap_t   *vap,
 
 	auth->status  = adf_os_ntohl(data->status);
 	auth->frame_send  = data->frame_send;
-	
+
     adf_net_indicate_event(vap->nethandle, &event);
 
     atd_trace(ATD_DEBUG_FUNCTRACE, (" .END "));
 }
 
 void
-atd_event_iw_assoc_comp_sta(atd_host_wifi_t   *wifi, atd_host_vap_t   *vap, 
+atd_event_iw_assoc_comp_sta(atd_host_wifi_t   *wifi, atd_host_vap_t   *vap,
                     wmi_id_t wmi, adf_nbuf_t buf)
 {
     a_uint32_t          len     = 0;
     acfg_os_event_t     event   = {.id = ACFG_EV_ASSOC_STA};
-    atd_assoc_t *data    = NULL; 
+    atd_assoc_t *data    = NULL;
     acfg_assoc_t  *assoc   = (void *)&event.data;
 
-    adf_os_assert(vap);
-
     atd_trace(ATD_DEBUG_FUNCTRACE, (" .START "));
 
     if (vap == NULL)
@@ -4365,7 +4347,7 @@ atd_event_iw_assoc_comp_sta(atd_host_wifi_t   *wifi, atd_host_vap_t   *vap,
 
 	assoc->status  = adf_os_ntohl(data->status);
 	assoc->frame_send  = data->frame_send;
-	
+
     adf_net_indicate_event(vap->nethandle, &event);
 
     atd_trace(ATD_DEBUG_FUNCTRACE, (" .END "));
@@ -4373,16 +4355,14 @@ atd_event_iw_assoc_comp_sta(atd_host_wifi_t   *wifi, atd_host_vap_t   *vap,
 
 
 void
-atd_event_iw_deauth_comp_sta(atd_host_wifi_t   *wifi, atd_host_vap_t   *vap, 
+atd_event_iw_deauth_comp_sta(atd_host_wifi_t   *wifi, atd_host_vap_t   *vap,
                     wmi_id_t wmi, adf_nbuf_t buf)
 {
     a_uint32_t          len     = 0;
     acfg_os_event_t     event   = {.id = ACFG_EV_DEAUTH_STA};
-    atd_dauth_t *data    = NULL; 
+    atd_dauth_t *data    = NULL;
     acfg_dauth_t  *auth   = (void *)&event.data;
 
-    adf_os_assert(vap);
-
     atd_trace(ATD_DEBUG_FUNCTRACE, (" .START "));
 
     if (vap == NULL)
@@ -4394,7 +4374,7 @@ atd_event_iw_deauth_comp_sta(atd_host_wifi_t   *wifi, atd_host_vap_t   *vap,
 	auth->status  = adf_os_ntohl(data->status);
 	auth->frame_send  = data->frame_send;
     adf_os_mem_copy(auth->macaddr, data->macaddr, ACFG_MACADDR_LEN);
-	
+
     adf_net_indicate_event(vap->nethandle, &event);
 
     atd_trace(ATD_DEBUG_FUNCTRACE, (" .END "));
@@ -4402,16 +4382,14 @@ atd_event_iw_deauth_comp_sta(atd_host_wifi_t   *wifi, atd_host_vap_t   *vap,
 
 
 void
-atd_event_iw_disassoc_comp_sta(atd_host_wifi_t   *wifi, atd_host_vap_t   *vap, 
+atd_event_iw_disassoc_comp_sta(atd_host_wifi_t   *wifi, atd_host_vap_t   *vap,
                     wmi_id_t wmi, adf_nbuf_t buf)
 {
     a_uint32_t          len     = 0;
     acfg_os_event_t     event   = {.id = ACFG_EV_DISASSOC_STA};
-    atd_disassoc_t *data    = NULL; 
+    atd_disassoc_t *data    = NULL;
     acfg_disassoc_t  *disassoc   = (void *)&event.data;
 
-    adf_os_assert(vap);
-
     atd_trace(ATD_DEBUG_FUNCTRACE, (" .START "));
 
     if (vap == NULL)
@@ -4424,23 +4402,21 @@ atd_event_iw_disassoc_comp_sta(atd_host_wifi_t   *wifi, atd_host_vap_t   *vap,
 	disassoc->reason  = adf_os_ntohl(data->reason);
 	disassoc->frame_send  = data->frame_send;
     adf_os_mem_copy(disassoc->macaddr, data->macaddr, ACFG_MACADDR_LEN);
-	
+
     adf_net_indicate_event(vap->nethandle, &event);
 
     atd_trace(ATD_DEBUG_FUNCTRACE, (" .END "));
 }
 
 void
-atd_event_iw_auth_ind_sta(atd_host_wifi_t   *wifi, atd_host_vap_t   *vap, 
+atd_event_iw_auth_ind_sta(atd_host_wifi_t   *wifi, atd_host_vap_t   *vap,
                     wmi_id_t wmi, adf_nbuf_t buf)
 {
     a_uint32_t          len     = 0;
     acfg_os_event_t     event   = {.id = ACFG_EV_AUTH_STA};
-    atd_auth_t *data    = NULL; 
+    atd_auth_t *data    = NULL;
     acfg_auth_t  *auth   = (void *)&event.data;
 
-    adf_os_assert(vap);
-
     atd_trace(ATD_DEBUG_FUNCTRACE, (" .START "));
 
     if (vap == NULL)
@@ -4452,23 +4428,21 @@ atd_event_iw_auth_ind_sta(atd_host_wifi_t   *wifi, atd_host_vap_t   *vap,
 	auth->status  = adf_os_ntohl(data->status);
 	auth->frame_send  = data->frame_send;
     adf_os_mem_copy(auth->macaddr, data->macaddr, ACFG_MACADDR_LEN);
-	
+
     adf_net_indicate_event(vap->nethandle, &event);
 
     atd_trace(ATD_DEBUG_FUNCTRACE, (" .END "));
 }
 
 void
-atd_event_iw_deauth_ind_sta(atd_host_wifi_t   *wifi, atd_host_vap_t   *vap, 
+atd_event_iw_deauth_ind_sta(atd_host_wifi_t   *wifi, atd_host_vap_t   *vap,
                     wmi_id_t wmi, adf_nbuf_t buf)
 {
     a_uint32_t          len     = 0;
     acfg_os_event_t     event   = {.id = ACFG_EV_DEAUTH_STA};
-    atd_dauth_t *data    = NULL; 
+    atd_dauth_t *data    = NULL;
     acfg_dauth_t  *deauth   = (void *)&event.data;
 
-    adf_os_assert(vap);
-
     atd_trace(ATD_DEBUG_FUNCTRACE, (" .START "));
 
     if (vap == NULL)
@@ -4480,23 +4454,21 @@ atd_event_iw_deauth_ind_sta(atd_host_wifi_t   *wifi, atd_host_vap_t   *vap,
 	deauth->reason  = adf_os_ntohl(data->reason);
 	deauth->frame_send  = data->frame_send;
     adf_os_mem_copy(deauth->macaddr, data->macaddr, ACFG_MACADDR_LEN);
-	
+
     adf_net_indicate_event(vap->nethandle, &event);
 
     atd_trace(ATD_DEBUG_FUNCTRACE, (" .END "));
 }
 
 void
-atd_event_iw_assoc_ind_sta(atd_host_wifi_t   *wifi, atd_host_vap_t   *vap, 
+atd_event_iw_assoc_ind_sta(atd_host_wifi_t   *wifi, atd_host_vap_t   *vap,
                     wmi_id_t wmi, adf_nbuf_t buf)
 {
     a_uint32_t          len     = 0;
     acfg_os_event_t     event   = {.id = ACFG_EV_ASSOC_STA};
-    atd_assoc_t *data    = NULL; 
+    atd_assoc_t *data    = NULL;
     acfg_assoc_t  *assoc   = (void *)&event.data;
 
-    adf_os_assert(vap);
-
     atd_trace(ATD_DEBUG_FUNCTRACE, (" .START "));
 
     if (vap == NULL)
@@ -4508,7 +4480,7 @@ atd_event_iw_assoc_ind_sta(atd_host_wifi_t   *wifi, atd_host_vap_t   *vap,
 	assoc->status  = adf_os_ntohl(data->status);
 	assoc->frame_send  = data->frame_send;
     adf_os_mem_copy(assoc->bssid, data->bssid, ACFG_MACADDR_LEN);
-	
+
     adf_net_indicate_event(vap->nethandle, &event);
 
     atd_trace(ATD_DEBUG_FUNCTRACE, (" .END "));
@@ -4516,16 +4488,14 @@ atd_event_iw_assoc_ind_sta(atd_host_wifi_t   *wifi, atd_host_vap_t   *vap,
 
 
 void
-atd_event_iw_disassoc_ind_sta(atd_host_wifi_t   *wifi, atd_host_vap_t   *vap, 
+atd_event_iw_disassoc_ind_sta(atd_host_wifi_t   *wifi, atd_host_vap_t   *vap,
                     wmi_id_t wmi, adf_nbuf_t buf)
 {
     a_uint32_t          len     = 0;
     acfg_os_event_t     event   = {.id = ACFG_EV_DISASSOC_STA};
-    atd_disassoc_t *data    = NULL; 
+    atd_disassoc_t *data    = NULL;
     acfg_disassoc_t  *disassoc   = (void *)&event.data;
 
-    adf_os_assert(vap);
-
     atd_trace(ATD_DEBUG_FUNCTRACE, (" .START "));
 
     if (vap == NULL)
@@ -4537,23 +4507,21 @@ atd_event_iw_disassoc_ind_sta(atd_host_wifi_t   *wifi, atd_host_vap_t   *vap,
 	disassoc->reason  = adf_os_ntohl(data->reason);
 	disassoc->frame_send  = data->frame_send;
     adf_os_mem_copy(disassoc->macaddr, data->macaddr, ACFG_MACADDR_LEN);
-	
+
     adf_net_indicate_event(vap->nethandle, &event);
 
     atd_trace(ATD_DEBUG_FUNCTRACE, (" .END "));
 }
 
 void
-atd_event_iw_deauth_ind_ap(atd_host_wifi_t   *wifi, atd_host_vap_t   *vap, 
+atd_event_iw_deauth_ind_ap(atd_host_wifi_t   *wifi, atd_host_vap_t   *vap,
                     wmi_id_t wmi, adf_nbuf_t buf)
 {
     a_uint32_t          len     = 0;
     acfg_os_event_t     event   = {.id = ACFG_EV_DEAUTH_AP};
-    atd_dauth_t *data    = NULL; 
+    atd_dauth_t *data    = NULL;
     acfg_dauth_t  *deauth   = (void *)&event.data;
 
-    adf_os_assert(vap);
-
     atd_trace(ATD_DEBUG_FUNCTRACE, (" .START "));
 
     if (vap == NULL)
@@ -4565,23 +4533,21 @@ atd_event_iw_deauth_ind_ap(atd_host_wifi_t   *wifi, atd_host_vap_t   *vap,
 	deauth->reason  = adf_os_ntohl(data->reason);
 	deauth->frame_send  = data->frame_send;
     adf_os_mem_copy(deauth->macaddr, data->macaddr, ACFG_MACADDR_LEN);
-	
+
     adf_net_indicate_event(vap->nethandle, &event);
 
     atd_trace(ATD_DEBUG_FUNCTRACE, (" .END "));
 }
 
 void
-atd_event_iw_disassoc_ind_ap(atd_host_wifi_t   *wifi, atd_host_vap_t   *vap, 
+atd_event_iw_disassoc_ind_ap(atd_host_wifi_t   *wifi, atd_host_vap_t   *vap,
                     wmi_id_t wmi, adf_nbuf_t buf)
 {
     a_uint32_t          len     = 0;
     acfg_os_event_t     event   = {.id = ACFG_EV_DISASSOC_AP};
-    atd_disassoc_t *data    = NULL; 
+    atd_disassoc_t *data    = NULL;
     acfg_disassoc_t  *disassoc   = (void *)&event.data;
 
-    adf_os_assert(vap);
-
     atd_trace(ATD_DEBUG_FUNCTRACE, (" .START "));
 
     if (vap == NULL)
@@ -4593,31 +4559,29 @@ atd_event_iw_disassoc_ind_ap(atd_host_wifi_t   *wifi, atd_host_vap_t   *vap,
 	disassoc->reason  = adf_os_ntohl(data->reason);
 	disassoc->frame_send  = data->frame_send;
     adf_os_mem_copy(disassoc->macaddr, data->macaddr, ACFG_MACADDR_LEN);
-	
+
     adf_net_indicate_event(vap->nethandle, &event);
 
     atd_trace(ATD_DEBUG_FUNCTRACE, (" .END "));
 }
 
-/** 
- * @brief 
- * 
+/**
+ * @brief
+ *
  * @param wifi
  * @param vap
  * @param wmi
  * @param buf
  */
 void
-atd_event_iw_wapi(atd_host_wifi_t   *wifi, atd_host_vap_t   *vap, 
+atd_event_iw_wapi(atd_host_wifi_t   *wifi, atd_host_vap_t   *vap,
                     wmi_id_t wmi, adf_nbuf_t buf)
 {
     a_uint32_t          len     = 0;
     acfg_os_event_t     event   = {.id = ACFG_EV_WAPI};
-    acfg_wsupp_custom_message_t *data    = NULL; 
+    acfg_wsupp_custom_message_t *data    = NULL;
     acfg_wsupp_custom_message_t  *wapi    = (void *)&event.data;
 
-    adf_os_assert(vap);
-
     atd_trace(ATD_DEBUG_FUNCTRACE, (" .START "));
 
     if (vap == NULL)
@@ -4634,25 +4598,23 @@ atd_event_iw_wapi(atd_host_wifi_t   *wifi, atd_host_vap_t   *vap,
 }
 
 
-/** 
- * @brief 
- * 
+/**
+ * @brief
+ *
  * @param wifi
  * @param vap
  * @param wmi
  * @param buf
  */
 void
-atd_event_scan_done(atd_host_wifi_t   *wifi, atd_host_vap_t   *vap, 
+atd_event_scan_done(atd_host_wifi_t   *wifi, atd_host_vap_t   *vap,
                     wmi_id_t wmi, adf_nbuf_t buf)
 {
     a_uint32_t          len     = 0;
     acfg_os_event_t     event   = {.id = ACFG_EV_SCAN_DONE};
-    atd_scan_done_t    *data    = NULL; 
+    atd_scan_done_t    *data    = NULL;
     acfg_scan_done_t   *scan    = (void *)&event.data;
 
-    adf_os_assert(vap);
-
     atd_trace(ATD_DEBUG_FUNCTRACE, (" .START "));
 
     if (vap == NULL)
@@ -4668,24 +4630,22 @@ atd_event_scan_done(atd_host_wifi_t   *wifi, atd_host_vap_t   *vap,
     atd_trace(ATD_DEBUG_FUNCTRACE, (" .END "));
 }
 
-/** 
+/**
  * @brief Send Station Join event to the Application
- * 
+ *
  * @param wifi
  * @param vap
  * @param wmi
  * @param buf
  */
 void
-atd_event_assoc_ap(atd_host_wifi_t   *wifi, atd_host_vap_t   *vap, 
+atd_event_assoc_ap(atd_host_wifi_t   *wifi, atd_host_vap_t   *vap,
                   wmi_id_t wmi, adf_nbuf_t buf)
 {
     a_uint32_t          len         = 0;
     acfg_os_event_t     event       = {.id = ACFG_EV_ASSOC_AP};
-    atd_assoc_ap_t     *data        = NULL; 
+    atd_assoc_ap_t     *data        = NULL;
     acfg_assoc_t    *assoc_ap    = (void *)&event.data;
-    
-    adf_os_assert(vap);
 
     atd_trace(ATD_DEBUG_FUNCTRACE, (" .START "));
 
@@ -4703,24 +4663,22 @@ atd_event_assoc_ap(atd_host_wifi_t   *wifi, atd_host_vap_t   *vap,
     atd_trace(ATD_DEBUG_FUNCTRACE, (" .END "));
 }
 
-/** 
+/**
  * @brief Send a Associated to an AP event to the application
- * 
+ *
  * @param wifi
  * @param vap
  * @param wmi
  * @param buf
  */
 void
-atd_event_assoc_sta(atd_host_wifi_t   *wifi, atd_host_vap_t   *vap, 
+atd_event_assoc_sta(atd_host_wifi_t   *wifi, atd_host_vap_t   *vap,
                     wmi_id_t wmi, adf_nbuf_t buf)
 {
     a_uint32_t          len         = 0;
     acfg_os_event_t     event       = {.id = ACFG_EV_ASSOC_STA};
-    atd_assoc_sta_t    *data       = NULL; 
+    atd_assoc_sta_t    *data       = NULL;
     acfg_assoc_t   *assoc_sta  = (void *)&event.data;
-    
-    adf_os_assert(vap);
 
     atd_trace(ATD_DEBUG_FUNCTRACE, (" .START "));
 
@@ -4732,7 +4690,7 @@ atd_event_assoc_sta(atd_host_wifi_t   *wifi, atd_host_vap_t   *vap,
 
     assoc_sta->status  = adf_os_ntohl(data->status);
     adf_os_mem_copy(assoc_sta->bssid, data->bssid, ACFG_MACADDR_LEN);
-        
+
     adf_net_indicate_event(vap->nethandle, &event);
 
     atd_trace(ATD_DEBUG_FUNCTRACE, (" .END "));
@@ -4740,25 +4698,23 @@ atd_event_assoc_sta(atd_host_wifi_t   *wifi, atd_host_vap_t   *vap,
     return;
 }
 
-/** 
+/**
  * @brief Radio On Channel Event
- * 
+ *
  * @param wifi
  * @param vap
  * @param wmi
  * @param buf
  */
 void
-atd_event_chan_start(atd_host_wifi_t   *wifi, atd_host_vap_t   *vap, 
+atd_event_chan_start(atd_host_wifi_t   *wifi, atd_host_vap_t   *vap,
                   wmi_id_t wmi, adf_nbuf_t buf)
 {
     a_uint32_t          len         = 0;
-    void               *data        = NULL; 
+    void               *data        = NULL;
     acfg_os_event_t     event       = {.id = ACFG_EV_CHAN_START};
     atd_chan_start_t   *payload;
     acfg_chan_start_t  *chan_start  = (void *)&event.data;
-    
-    adf_os_assert(vap);
 
     atd_trace(ATD_DEBUG_FUNCTRACE, (" .START "));
 
@@ -4779,26 +4735,24 @@ atd_event_chan_start(atd_host_wifi_t   *wifi, atd_host_vap_t   *vap,
     atd_trace(ATD_DEBUG_FUNCTRACE, (" .END "));
 }
 
-/** 
+/**
  * @brief Radio Off Channel Event
- * 
+ *
  * @param wifi
  * @param vap
  * @param wmi
  * @param buf
  */
 void
-atd_event_chan_end(atd_host_wifi_t   *wifi, atd_host_vap_t   *vap, 
+atd_event_chan_end(atd_host_wifi_t   *wifi, atd_host_vap_t   *vap,
                   wmi_id_t wmi, adf_nbuf_t buf)
 {
     a_uint32_t          len         = 0;
-    void               *data        = NULL; 
+    void               *data        = NULL;
     acfg_os_event_t     event       = {.id = ACFG_EV_CHAN_END};
     atd_chan_end_t     *payload;
     acfg_chan_end_t    *chan_end    = (void *)&event.data;
 
-    adf_os_assert(vap);
-
     atd_trace(ATD_DEBUG_FUNCTRACE, (" .START "));
 
     if (vap == NULL)
@@ -4819,21 +4773,19 @@ atd_event_chan_end(atd_host_wifi_t   *wifi, atd_host_vap_t   *vap,
     atd_trace(ATD_DEBUG_FUNCTRACE, (" .END "));
 }
 
-/** 
+/**
  * @brief Received Management Frame Event
- * 
+ *
  * @param wifi
  * @param vap
  * @param wmi
  * @param buf
  */
 void
-atd_event_rx_mgmt(atd_host_wifi_t   *wifi, atd_host_vap_t   *vap, 
+atd_event_rx_mgmt(atd_host_wifi_t   *wifi, atd_host_vap_t   *vap,
                   wmi_id_t wmi, adf_nbuf_t buf)
 {
     acfg_os_event_t     event       = {.id = ACFG_EV_RX_MGMT};
-    
-    adf_os_assert(vap);
 
     atd_trace(ATD_DEBUG_FUNCTRACE, (" .START "));
 
@@ -4845,21 +4797,19 @@ atd_event_rx_mgmt(atd_host_wifi_t   *wifi, atd_host_vap_t   *vap,
     atd_trace(ATD_DEBUG_FUNCTRACE, (" .END "));
 }
 
-/** 
+/**
  * @brief Sent Action Frame Event
- * 
+ *
  * @param wifi
  * @param vap
  * @param wmi
  * @param buf
  */
 void
-atd_event_sent_action(atd_host_wifi_t   *wifi, atd_host_vap_t   *vap, 
+atd_event_sent_action(atd_host_wifi_t   *wifi, atd_host_vap_t   *vap,
                   wmi_id_t wmi, adf_nbuf_t buf)
 {
     acfg_os_event_t     event       = {.id = ACFG_EV_SENT_ACTION};
-    
-    adf_os_assert(vap);
 
     atd_trace(ATD_DEBUG_FUNCTRACE, (" .START "));
 
@@ -4871,23 +4821,21 @@ atd_event_sent_action(atd_host_wifi_t   *wifi, atd_host_vap_t   *vap,
     atd_trace(ATD_DEBUG_FUNCTRACE, (" .END "));
 }
 
-/** 
+/**
  * @brief Station Leaving an AP Event
- * 
+ *
  * @param wifi
  * @param vap
  * @param wmi
  * @param buf
  */
 void
-atd_event_leave_ap(atd_host_wifi_t   *wifi, atd_host_vap_t   *vap, 
+atd_event_leave_ap(atd_host_wifi_t   *wifi, atd_host_vap_t   *vap,
                   wmi_id_t wmi, adf_nbuf_t buf)
 {
     a_uint32_t          len         = 0;
-    void               *data        = NULL; 
+    void               *data        = NULL;
     acfg_os_event_t     event       = {.id = ACFG_EV_LEAVE_AP};
-    
-    adf_os_assert(vap);
 
     atd_trace(ATD_DEBUG_FUNCTRACE, (" .START "));
 
@@ -4897,7 +4845,7 @@ atd_event_leave_ap(atd_host_wifi_t   *wifi, atd_host_vap_t   *vap,
     adf_nbuf_peek_header(buf, (a_uint8_t **)&data, &len);
     adf_nbuf_pull_head(buf, len);
 
-    adf_os_mem_copy(event.data.leave_ap.mac, data, 
+    adf_os_mem_copy(event.data.leave_ap.mac, data,
             len > ACFG_MACADDR_LEN ? ACFG_MACADDR_LEN : len);
 
     adf_net_indicate_event(vap->nethandle, &event);
@@ -4905,23 +4853,21 @@ atd_event_leave_ap(atd_host_wifi_t   *wifi, atd_host_vap_t   *vap,
     atd_trace(ATD_DEBUG_FUNCTRACE, (" .END "));
 }
 
-/** 
+/**
  * @brief Pass IE Event
- * 
+ *
  * @param wifi
  * @param vap
  * @param wmi
  * @param buf
  */
 void
-atd_event_gen_ie(atd_host_wifi_t   *wifi, atd_host_vap_t   *vap, 
+atd_event_gen_ie(atd_host_wifi_t   *wifi, atd_host_vap_t   *vap,
                   wmi_id_t wmi, adf_nbuf_t buf)
 {
     a_uint32_t          len         = 0;
-    void               *data        = NULL; 
+    void               *data        = NULL;
     acfg_os_event_t     event       = {.id = ACFG_EV_GEN_IE};
-    
-    adf_os_assert(vap);
 
     atd_trace(ATD_DEBUG_FUNCTRACE, (" .START "));
 
@@ -4948,23 +4894,22 @@ atd_event_gen_ie(atd_host_wifi_t   *wifi, atd_host_vap_t   *vap,
     atd_trace(ATD_DEBUG_FUNCTRACE, (" .END "));
 }
 
-#if 0
-/** 
+/**
  * @brief Pass Assoc Req IE Event
- * 
+ *
  * @param wifi
  * @param vap
  * @param wmi
  * @param buf
  */
 void
-atd_event_assoc_req_ie(atd_host_wifi_t   *wifi, atd_host_vap_t   *vap, 
+atd_event_assoc_req_ie(atd_host_wifi_t   *wifi, atd_host_vap_t   *vap,
                   wmi_id_t wmi, adf_nbuf_t buf)
 {
     a_uint32_t          len         = 0;
-    void               *data        = NULL; 
+    void               *data        = NULL;
     acfg_os_event_t     event       = {.id = ACFG_EV_ASSOC_REQ_IE};
-    
+
     adf_os_assert(vap);
 
     atd_trace(ATD_DEBUG_FUNCTRACE, (" .START "));
@@ -4988,24 +4933,21 @@ atd_event_assoc_req_ie(atd_host_wifi_t   *wifi, atd_host_vap_t   *vap,
 
     atd_trace(ATD_DEBUG_FUNCTRACE, (" .END "));
 }
-#endif
 
-/** 
- * @brief 
- * 
+/**
+ * @brief
+ *
  * @param wifi
  * @param vap
  * @param wmi
  * @param buf
  */
 void
-atd_event_if_running_sta(atd_host_wifi_t   *wifi, atd_host_vap_t   *vap, 
+atd_event_if_running_sta(atd_host_wifi_t   *wifi, atd_host_vap_t   *vap,
                     wmi_id_t wmi, adf_nbuf_t buf)
 {
     a_uint32_t          len         = 0;
-    atd_assoc_sta_t    *data       = NULL; 
-    
-    adf_os_assert(vap);
+    atd_assoc_sta_t    *data       = NULL;
 
     if (vap == NULL)
         return;
@@ -5015,28 +4957,26 @@ atd_event_if_running_sta(atd_host_wifi_t   *wifi, atd_host_vap_t   *vap,
     adf_nbuf_peek_header(buf, (a_uint8_t **)&data, &len);
     adf_nbuf_pull_head(buf, sizeof(atd_assoc_sta_t));
 
-    adf_net_carrier_on(vap->nethandle);       
+    adf_net_carrier_on(vap->nethandle);
     atd_trace(ATD_DEBUG_FUNCTRACE, (" .END "));
 
     return;
 }
 
-/** 
- * @brief 
- * 
+/**
+ * @brief
+ *
  * @param wifi
  * @param vap
  * @param wmi
  * @param buf
  */
 void
-atd_event_if_not_running_sta(atd_host_wifi_t   *wifi, atd_host_vap_t   *vap, 
+atd_event_if_not_running_sta(atd_host_wifi_t   *wifi, atd_host_vap_t   *vap,
                     wmi_id_t wmi, adf_nbuf_t buf)
 {
     a_uint32_t          len         = 0;
-    atd_assoc_sta_t    *data       = NULL; 
-    
-    adf_os_assert(vap);
+    atd_assoc_sta_t    *data       = NULL;
 
     atd_trace(ATD_DEBUG_FUNCTRACE, (" .START "));
 
@@ -5046,22 +4986,24 @@ atd_event_if_not_running_sta(atd_host_wifi_t   *wifi, atd_host_vap_t   *vap,
     adf_nbuf_peek_header(buf, (a_uint8_t **)&data, &len);
     adf_nbuf_pull_head(buf, sizeof(atd_assoc_sta_t));
 
-    adf_net_carrier_off(vap->nethandle);       
+    if (vap->nethandle)
+        adf_net_carrier_off(vap->nethandle);
+
     atd_trace(ATD_DEBUG_FUNCTRACE, (" .END "));
 
     return;
 }
 
-/** 
+/**
  * @brief Send a create vap event to the application
- * 
+ *
  * @param wifi
  * @param vap
  * @param wmi
  * @param buf
  */
 void
-atd_event_create_vap(atd_host_wifi_t   *wifi, atd_host_vap_t   *vap_input, 
+atd_event_create_vap(atd_host_wifi_t   *wifi, atd_host_vap_t   *vap_input,
                   wmi_id_t wmi, adf_nbuf_t buf)
 {
     adf_net_dev_info_t       info  = {{0}};
@@ -5071,14 +5013,14 @@ atd_event_create_vap(atd_host_wifi_t   *wifi, atd_host_vap_t   *vap_input,
     atd_create_vap_t     *data    = NULL;
     a_uint32_t              len         = 0,error,unit;
     a_uint8_t              if_name[ACFG_MAX_IFNAME];
-    
+
     atd_trace(ATD_DEBUG_FUNCTRACE, (" .START "));
 
     adf_nbuf_peek_header(buf, (a_uint8_t **)&data, &len);
     adf_nbuf_pull_head(buf, sizeof(struct acfg_create_vap));
 
     atd_trace((ATD_DEBUG_FUNCTRACE | ATD_DEBUG_CFG),
-              ("vap_name %s", 
+              ("vap_name %s",
                data->if_name));
 
     /*
@@ -5097,7 +5039,7 @@ atd_event_create_vap(atd_host_wifi_t   *wifi, atd_host_vap_t   *vap_input,
     atd_spin_lock_bh(wifi->dsc);      /* Lock */
 
     adf_os_assert(wifi->vap_list[vap->vap_index] == NULL);
-    
+
     wifi->vap_list[vap->vap_index] = vap;
 
     atd_spin_unlock_bh(wifi->dsc);    /* Unlock */
@@ -5152,14 +5094,14 @@ atd_event_create_vap(atd_host_wifi_t   *wifi, atd_host_vap_t   *vap_input,
         info.unit = unit;
     }
 
-    adf_os_str_ncopy(info.if_name, data->if_name, 
+    adf_os_str_ncopy(info.if_name, data->if_name,
                      adf_os_str_len(data->if_name));
     adf_os_mem_copy(info.dev_addr, &data->mac_addr[0], ACFG_MACADDR_LEN);
 
-    info.header_len = sizeof(atd_tx_hdr_t) + 
+    info.header_len = sizeof(atd_tx_hdr_t) +
                       htc_get_reserveheadroom(htch);
 
-    
+
     dev_switch.drv_ioctl       = atd_vap_ioctl;
     dev_switch.drv_tx_timeout  = atd_vap_tx_timeout ;
     dev_switch.drv_open        = atd_vap_open;
@@ -5173,7 +5115,7 @@ atd_event_create_vap(atd_host_wifi_t   *wifi, atd_host_vap_t   *vap_input,
         atd_trace(ATD_DEBUG_CFG, ("Failure during vap_attach \n"));
         goto fail;
     }
-    
+    vap->sys_index   = ADF_VAP_GET_IFINDEX(vap->nethandle);
     atd_trace(ATD_DEBUG_FUNCTRACE,("VAP created  _adf_net_ifname %s \n",
                  adf_net_ifname(vap->nethandle)));
 
@@ -5185,18 +5127,18 @@ fail:
 
 fail_unit :
     if(vap) adf_os_mem_free(vap);
-    
+
     return;
 }
 
- /* @brief Delete VAP event, 
- * 
+ /* @brief Delete VAP event,
+ *
  * @param wifi
  * @param vap
  * @param wmi
  * @param buf
  *
- * @note  This assumes that all events on this VAP has been 
+ * @note  This assumes that all events on this VAP has been
  *        reliably being delivered & processed before this
  *        arrives
  */
@@ -5206,16 +5148,13 @@ atd_event_delete_vap(atd_host_wifi_t    *wifi, atd_host_vap_t   *vap,
 {
     atd_trace(ATD_DEBUG_FUNCTRACE, (" .START "));
 
-    atd_trace(ATD_DEBUG_CFG, ("VAP delete %s\n", 
-                adf_net_ifname(vap->nethandle)));
-
-    adf_os_assert(vap);
+    atd_trace(ATD_DEBUG_CFG, ("VAP delete %p\n", vap));
 
     if (vap == NULL)
         return;
 
     if (vap->nethandle) {
-        adf_net_stop_queue(vap->nethandle); 
+        adf_net_stop_queue(vap->nethandle);
     }
 
     atd_free_vap_index(wifi, vap->vap_index);
@@ -5224,7 +5163,7 @@ atd_event_delete_vap(atd_host_wifi_t    *wifi, atd_host_vap_t   *vap,
         /* Free the wlan unit index maintained at adf for VAP's */
         adf_net_free_wlanunit(vap->nethandle);
 
-        adf_net_delete_dev(vap->nethandle); 
+        adf_net_delete_dev(vap->nethandle);
     }
 
     adf_os_mem_free(vap);
@@ -5300,7 +5239,7 @@ atd_event_delete_wifi(atd_host_wifi_t    *wifi, atd_host_vap_t   *vap,
 }
 
  /* @brief wsupp event generic handler
- * 
+ *
  * @param wifi
  * @param vap
  * @param wmi
@@ -5317,9 +5256,8 @@ atd_event_wsupp_generic(atd_host_wifi_t    *wifi, atd_host_vap_t   *vap,
 {
     a_uint32_t len;
     acfg_os_event_t event;
-    a_uint8_t *data; 
-    
-    adf_os_assert(vap);
+    a_uint8_t *data;
+
     atd_trace(ATD_DEBUG_FUNCTRACE, (" .START "));
 
     if (vap == NULL)
@@ -5339,16 +5277,16 @@ atd_event_wsupp_generic(atd_host_wifi_t    *wifi, atd_host_vap_t   *vap,
         atd_trace(ATD_DEBUG_CFG, ("invalid wsupp wmi event: %d\n", wmi));
         return;
     }
-        
+
     adf_net_indicate_event(vap->nethandle, &event);
 
     atd_trace(ATD_DEBUG_FUNCTRACE, (" .END "));
 }
 
 
-/** 
+/**
  * @brief Handle Bypass VAPCTRL event - Set LAN enable flag
- * 
+ *
  * @param wifi
  * @param vap
  * @param wmi
@@ -5364,7 +5302,7 @@ atd_event_byp_vap_lanen(atd_host_wifi_t    *wifi, atd_host_vap_t   *vap,
     if (vap == NULL)
         return;
 
-    atd_trace(ATD_DEBUG_CFG, ("BYPASS VAP Enable LAN Access%s\n", 
+    atd_trace(ATD_DEBUG_CFG, ("BYPASS VAP Enable LAN Access%s\n",
                 adf_net_ifname(vap->nethandle)));
 
     vap->lan_en     =   1;
@@ -5372,9 +5310,9 @@ atd_event_byp_vap_lanen(atd_host_wifi_t    *wifi, atd_host_vap_t   *vap,
     atd_trace(ATD_DEBUG_FUNCTRACE, (" .END "));
 }
 
-/** 
+/**
  * @brief  Handle Bypass VAPCTRL event - Reset LAN enable flag
- * 
+ *
  * @param wifi
  * @param vap
  * @param wmi
@@ -5390,7 +5328,7 @@ atd_event_byp_vap_landis(atd_host_wifi_t    *wifi, atd_host_vap_t   *vap,
     if (vap == NULL)
         return;
 
-    atd_trace(ATD_DEBUG_CFG, ("BYPASS VAP Enable LAN Access%s\n", 
+    atd_trace(ATD_DEBUG_CFG, ("BYPASS VAP Enable LAN Access%s\n",
                 adf_net_ifname(vap->nethandle)));
 
     vap->lan_en     =   0;
@@ -5457,29 +5395,29 @@ void atd_convert_spectral_samp_msg_ntoh(atd_spectral_samp_msg_t *out, atd_spectr
     out->samp_data.spectral_nb_upper = in->samp_data.spectral_nb_upper;
     out->samp_data.spectral_nb_lower = in->samp_data.spectral_nb_lower;
 
-    out->samp_data.classifier_params.spectral_20_40_mode = 
+    out->samp_data.classifier_params.spectral_20_40_mode =
         adf_os_ntohl(in->samp_data.classifier_params.spectral_20_40_mode);
-    out->samp_data.classifier_params.spectral_dc_index = 
+    out->samp_data.classifier_params.spectral_dc_index =
         adf_os_ntohl(in->samp_data.classifier_params.spectral_dc_index);
-    out->samp_data.classifier_params.spectral_dc_in_mhz = 
+    out->samp_data.classifier_params.spectral_dc_in_mhz =
         adf_os_ntohl(in->samp_data.classifier_params.spectral_dc_in_mhz);
-    out->samp_data.classifier_params.upper_chan_in_mhz = 
+    out->samp_data.classifier_params.upper_chan_in_mhz =
         adf_os_ntohl(in->samp_data.classifier_params.upper_chan_in_mhz);
-    out->samp_data.classifier_params.lower_chan_in_mhz = 
+    out->samp_data.classifier_params.lower_chan_in_mhz =
         adf_os_ntohl(in->samp_data.classifier_params.lower_chan_in_mhz);
 
     out->samp_data.bin_pwr_count = adf_os_ntohs(in->samp_data.bin_pwr_count);
     memcpy(out->samp_data.bin_pwr, in->samp_data.bin_pwr, MAX_NUM_BINS);
-    
+
     out->samp_data.interf_list.count = adf_os_ntohs(in->samp_data.interf_list.count);
 
     for (i = 0; i < MAX_INTERF; i++)
     {
-        out->samp_data.interf_list.interf[i].interf_type = 
+        out->samp_data.interf_list.interf[i].interf_type =
             in->samp_data.interf_list.interf[i].interf_type;
-        out->samp_data.interf_list.interf[i].interf_min_freq = 
+        out->samp_data.interf_list.interf[i].interf_min_freq =
             adf_os_ntohs(in->samp_data.interf_list.interf[i].interf_min_freq);
-        out->samp_data.interf_list.interf[i].interf_max_freq = 
+        out->samp_data.interf_list.interf[i].interf_max_freq =
             adf_os_ntohs(in->samp_data.interf_list.interf[i].interf_max_freq);
     }
 
@@ -5489,9 +5427,9 @@ void atd_convert_spectral_samp_msg_ntoh(atd_spectral_samp_msg_t *out, atd_spectr
 
 extern struct sock *atd_spectral_nl_sock;
 void
-atd_event_spectral_msg_send(atd_host_wifi_t *wifi, 
+atd_event_spectral_msg_send(atd_host_wifi_t *wifi,
         atd_host_vap_t *vap,
-        wmi_id_t wmi, 
+        wmi_id_t wmi,
         adf_nbuf_t buf)
 {
     a_uint32_t  len = 0;
@@ -5511,10 +5449,10 @@ atd_event_spectral_msg_send(atd_host_wifi_t *wifi,
         nlh->nlmsg_flags = 0;
         /* Its time todo ntoh conversion */
         atd_convert_spectral_samp_msg_ntoh(NLMSG_DATA(nlh), data);
-        netlink_broadcast(atd_spectral_nl_sock, 
-                nbuf, 
+        netlink_broadcast(atd_spectral_nl_sock,
+                nbuf,
                 0,
-                1, 
+                1,
                 GFP_ATOMIC);
     }
 }
@@ -5525,12 +5463,12 @@ atd_event_spectral_msg_send(atd_host_wifi_t *wifi,
  * @param out
  * @param in
  */
-void 
-atd_convert_bsteer_event_ntoh(ath_netlink_bsteering_event_t *out, 
-        atd_bsteering_event_t *in)
+void
+atd_convert_bsteer_event_ntoh(ath_netlink_bsteering_event_t *out,
+                              atd_bsteering_event_t *in, a_uint32_t sys_index)
 {
     out->type = adf_os_ntohl(in->type);
-    out->sys_index = adf_os_ntohl(in->sys_index);
+    out->sys_index = sys_index;
 
     switch(out->type)
     {
@@ -5622,7 +5560,7 @@ atd_event_bsteer_send(atd_host_wifi_t *wifi,
         NETLINK_CB(nbuf).pid = 0;        /* from kernel */
         NETLINK_CB(nbuf).dst_group = 0;  /* unicast */
         /* Its time todo ntoh conversion */
-        atd_convert_bsteer_event_ntoh(NLMSG_DATA(nlh), event);
+        atd_convert_bsteer_event_ntoh(NLMSG_DATA(nlh), event, vap->sys_index);
 
         netlink_unicast(atd_bsteer_nl_sock,
                 nbuf,
@@ -5631,7 +5569,7 @@ atd_event_bsteer_send(atd_host_wifi_t *wifi,
     }
 }
 
-a_status_t 
+a_status_t
 atd_cfg_set_chan(adf_drv_handle_t hdl, a_uint8_t  chan)
 {
     atd_host_vap_t    *vap    = (atd_host_vap_t * )hdl;
@@ -5649,15 +5587,13 @@ atd_cfg_set_chan(adf_drv_handle_t hdl, a_uint8_t  chan)
         goto fail ;
     }
 
-    pfreq = (acfg_freq_t *)atd_prep_cfg_hdr(nbuf, sizeof(acfg_freq_t), 
+    pfreq = (acfg_freq_t *)atd_prep_cfg_hdr(nbuf, sizeof(acfg_freq_t),
                                             wifi, vap);
 
-    pfreq->m = adf_os_htonl(chan);
-    pfreq->e = 0;
-	
-    atd_trace(ATD_DEBUG_CFG, ("SET value m %d , e %d", pfreq->m, pfreq->e));
+    *pfreq = adf_os_htonl(chan);
+    atd_trace(ATD_DEBUG_CFG, ("SET value, %d", *pfreq));
 
-    status = wmi_cmd_send(__wifi2wmi(wifi), WMI_CMD_FREQ_SET, nbuf, 
+    status = wmi_cmd_send(__wifi2wmi(wifi), WMI_CMD_FREQ_SET, nbuf,
             (a_uint8_t *)&resp, sizeof(a_int32_t));
 
     if (status != A_STATUS_OK) {
@@ -5699,7 +5635,7 @@ __mhz2ieee(a_uint32_t freq)
     return (freq - 5000) / 5;
 }
 
-a_status_t 
+a_status_t
 atd_cfg_get_chan(adf_drv_handle_t hdl, a_uint8_t *chan)
 {
     atd_host_vap_t *vap = (atd_host_vap_t *)hdl;
@@ -5728,9 +5664,9 @@ atd_cfg_get_chan(adf_drv_handle_t hdl, a_uint8_t *chan)
         goto fail;
     }
 
-    freq = adf_os_ntohl(resp.m);
+    freq = adf_os_ntohl(resp);
 
-    if(adf_os_ntohs(resp.e) == 1)
+    if(adf_os_ntohs(resp) == 1)
         *chan = (u_int8_t)__mhz2ieee(freq / 100000);
     else
         *chan = freq;
@@ -5742,7 +5678,7 @@ fail:
     return status;
 }
 
-a_status_t 
+a_status_t
 atd_cfg_set_freq(adf_drv_handle_t hdl, acfg_freq_t *freq)
 {
     atd_host_vap_t    *vap    = (atd_host_vap_t * )hdl;
@@ -5760,15 +5696,14 @@ atd_cfg_set_freq(adf_drv_handle_t hdl, acfg_freq_t *freq)
         goto fail ;
     }
 
-    pfreq = (acfg_freq_t *)atd_prep_cfg_hdr(nbuf, sizeof(acfg_freq_t), 
+    pfreq = (acfg_freq_t *)atd_prep_cfg_hdr(nbuf, sizeof(acfg_freq_t),
                                             wifi, vap);
 
-    pfreq->m = adf_os_htonl(freq->m);
-    pfreq->e = adf_os_htons(freq->e);
-	
-    atd_trace(ATD_DEBUG_CFG, ("SET value m %d , e %d", pfreq->m, pfreq->e));
+    *pfreq = adf_os_htonl(*freq);
+
+    atd_trace(ATD_DEBUG_CFG, ("freq %d SET value %d ", *freq, *pfreq));
 
-    status = wmi_cmd_send(__wifi2wmi(wifi), WMI_CMD_FREQ_SET, nbuf, 
+    status = wmi_cmd_send(__wifi2wmi(wifi), WMI_CMD_FREQ_SET, nbuf,
             (a_uint8_t *)&resp, sizeof(a_int32_t));
 
     if (status != A_STATUS_OK) {
@@ -5785,7 +5720,7 @@ fail:
     return status;
 }
 
-a_status_t 
+a_status_t
 atd_cfg_get_freq(adf_drv_handle_t  hdl, acfg_freq_t *freq)
 {
     atd_host_vap_t *vap = (atd_host_vap_t *)hdl;
@@ -5795,7 +5730,7 @@ atd_cfg_get_freq(adf_drv_handle_t  hdl, acfg_freq_t *freq)
     adf_nbuf_t nbuf;
 
     atd_trace((ATD_DEBUG_FUNCTRACE | ATD_DEBUG_CFG), ("Start"));
-	
+
     if ((nbuf = _atd_wmi_msg_alloc(__wifi2wmi(wifi))) == NULL) {
         atd_trace(ATD_DEBUG_CFG, ("Unable to allocate wmi buffer \n"));
         status = A_STATUS_ENOMEM;
@@ -5804,7 +5739,7 @@ atd_cfg_get_freq(adf_drv_handle_t  hdl, acfg_freq_t *freq)
 
     atd_prep_cfg_hdr(nbuf, 0, wifi, vap);
 
-    status = wmi_cmd_send(__wifi2wmi(wifi), WMI_CMD_FREQ_GET, nbuf, 
+    status = wmi_cmd_send(__wifi2wmi(wifi), WMI_CMD_FREQ_GET, nbuf,
             (a_uint8_t *)&resp, sizeof(acfg_freq_t));
 
     if (status != A_STATUS_OK) {
@@ -5812,12 +5747,11 @@ atd_cfg_get_freq(adf_drv_handle_t  hdl, acfg_freq_t *freq)
         status =  A_STATUS_EINVAL;
         goto fail;
     }
-	
-    freq->m = adf_os_ntohl(resp.m);
-    freq->e = adf_os_ntohs(resp.e);
 
-    atd_trace(ATD_DEBUG_CFG, ("RESULT m %d , e %d ", freq->m, freq->e));
-	
+    *freq = adf_os_ntohl(resp);
+
+    atd_trace(ATD_DEBUG_CFG, ("RESULT %d", *freq));
+
 fail:
     atd_trace((ATD_DEBUG_FUNCTRACE | ATD_DEBUG_CFG), ("End stat %x ",status ));
     return status;
@@ -5825,7 +5759,7 @@ fail:
 
 
 
-a_status_t 
+a_status_t
 atd_cfg_set_rts(adf_drv_handle_t hdl, acfg_rts_t *rts)
 {
     atd_host_vap_t    *vap    = (atd_host_vap_t * )hdl;
@@ -5843,16 +5777,14 @@ atd_cfg_set_rts(adf_drv_handle_t hdl, acfg_rts_t *rts)
         goto fail ;
     }
 
-    prts = (atd_rts_t *)atd_prep_cfg_hdr(nbuf, sizeof(atd_rts_t), 
+    prts = (atd_rts_t *)atd_prep_cfg_hdr(nbuf, sizeof(atd_rts_t),
                                             wifi, vap);
 
-    atd_trace(ATD_DEBUG_CFG, ("SET rts - %d ; flags - 0x%x,", 
-					prts->val, prts->flags));
+    *prts = adf_os_htonl(rts);
+
+    atd_trace(ATD_DEBUG_CFG, ("SET rts - %d", *prts));
 
-    prts->val = adf_os_htonl(rts->val);
-    prts->flags = adf_os_htonl(rts->flags);
-	
-    status = wmi_cmd_send(__wifi2wmi(wifi), WMI_CMD_RTS_SET, nbuf, 
+    status = wmi_cmd_send(__wifi2wmi(wifi), WMI_CMD_RTS_SET, nbuf,
             (a_uint8_t *)&resp, sizeof(a_int32_t));
 
     if (status != A_STATUS_OK) {
@@ -5871,7 +5803,7 @@ fail:
 
 
 
-a_status_t 
+a_status_t
 atd_cfg_get_rts(adf_drv_handle_t  hdl, acfg_rts_t *rts)
 {
     atd_host_vap_t *vap = (atd_host_vap_t *)hdl;
@@ -5881,7 +5813,7 @@ atd_cfg_get_rts(adf_drv_handle_t  hdl, acfg_rts_t *rts)
     adf_nbuf_t nbuf;
 
     atd_trace((ATD_DEBUG_FUNCTRACE | ATD_DEBUG_CFG), ("Start"));
-	
+
     if ((nbuf = _atd_wmi_msg_alloc(__wifi2wmi(wifi))) == NULL) {
         atd_trace(ATD_DEBUG_CFG, ("Unable to allocate wmi buffer \n"));
         status = A_STATUS_ENOMEM;
@@ -5890,7 +5822,7 @@ atd_cfg_get_rts(adf_drv_handle_t  hdl, acfg_rts_t *rts)
 
     atd_prep_cfg_hdr(nbuf, 0, wifi, vap);
 
-    status = wmi_cmd_send(__wifi2wmi(wifi), WMI_CMD_RTS_GET, nbuf, 
+    status = wmi_cmd_send(__wifi2wmi(wifi), WMI_CMD_RTS_GET, nbuf,
             (a_uint8_t *)&resp, sizeof(atd_rts_t));
 
     if (status != A_STATUS_OK) {
@@ -5898,13 +5830,9 @@ atd_cfg_get_rts(adf_drv_handle_t  hdl, acfg_rts_t *rts)
         status =  A_STATUS_EINVAL;
         goto fail;
     }
-	
-    rts->val = adf_os_ntohl(resp.val);
-    rts->flags = adf_os_ntohl(resp.flags);
-
-    atd_trace(ATD_DEBUG_CFG, ("RESULT val %d , flags 0x%04x", \
-              rts->val, rts->flags));
 
+    *rts = adf_os_ntohl(resp);
+    atd_trace(ATD_DEBUG_CFG, ("RESULT val %d", *rts));
 fail:
     atd_trace((ATD_DEBUG_FUNCTRACE | ATD_DEBUG_CFG), ("End stat %x ",status ));
     return status;
@@ -5912,7 +5840,7 @@ fail:
 
 
 
-a_status_t 
+a_status_t
 atd_cfg_set_frag(adf_drv_handle_t hdl, acfg_frag_t *frag)
 {
     atd_host_vap_t    *vap    = (atd_host_vap_t * )hdl;
@@ -5930,22 +5858,20 @@ atd_cfg_set_frag(adf_drv_handle_t hdl, acfg_frag_t *frag)
         goto fail ;
     }
 
-    pfrag = (atd_frag_t *)atd_prep_cfg_hdr(nbuf, sizeof(atd_frag_t), 
+    pfrag = (atd_frag_t *)atd_prep_cfg_hdr(nbuf, sizeof(atd_frag_t),
                                             wifi, vap);
 
-    atd_trace(ATD_DEBUG_CFG, ("SET frag - %d ; flags - 0x%x,", 
-					pfrag->val, pfrag->flags));
 
-    pfrag->val = adf_os_htonl(frag->val);
-    pfrag->flags = adf_os_htonl(frag->flags);
-	
-    status = wmi_cmd_send(__wifi2wmi(wifi), WMI_CMD_FRAG_SET, nbuf, 
+    *pfrag = adf_os_htonl(frag);
+    atd_trace(ATD_DEBUG_CFG, ("SET frag - %d", *pfrag));
+
+    status = wmi_cmd_send(__wifi2wmi(wifi), WMI_CMD_FRAG_SET, nbuf,
             (a_uint8_t *)&resp, sizeof(a_int32_t));
 
     if (status != A_STATUS_OK) {
         atd_trace(ATD_DEBUG_CFG, (" wmi_cmd_send Failed stat = %x\n", status));
         status = A_STATUS_EINVAL;
-     }
+    }
 
     resp = adf_os_ntohl(resp);
     if(resp != 0)
@@ -5958,7 +5884,7 @@ fail:
 
 
 
-a_status_t 
+a_status_t
 atd_cfg_get_frag(adf_drv_handle_t  hdl, acfg_frag_t *frag)
 {
     atd_host_vap_t *vap = (atd_host_vap_t *)hdl;
@@ -5968,7 +5894,7 @@ atd_cfg_get_frag(adf_drv_handle_t  hdl, acfg_frag_t *frag)
     adf_nbuf_t nbuf;
 
     atd_trace((ATD_DEBUG_FUNCTRACE | ATD_DEBUG_CFG), ("Start"));
-	
+
     if ((nbuf = _atd_wmi_msg_alloc(__wifi2wmi(wifi))) == NULL) {
         atd_trace(ATD_DEBUG_CFG, ("Unable to allocate wmi buffer \n"));
         status = A_STATUS_ENOMEM;
@@ -5976,8 +5902,8 @@ atd_cfg_get_frag(adf_drv_handle_t  hdl, acfg_frag_t *frag)
     }
 
     atd_prep_cfg_hdr(nbuf, 0, wifi, vap);
-	
-    status = wmi_cmd_send(__wifi2wmi(wifi), WMI_CMD_FRAG_GET, nbuf, 
+
+    status = wmi_cmd_send(__wifi2wmi(wifi), WMI_CMD_FRAG_GET, nbuf,
             (a_uint8_t *)&resp, sizeof(atd_frag_t));
 
     if (status != A_STATUS_OK) {
@@ -5985,13 +5911,11 @@ atd_cfg_get_frag(adf_drv_handle_t  hdl, acfg_frag_t *frag)
         status =  A_STATUS_EINVAL;
         goto fail;
     }
-	
-    frag->val = adf_os_ntohl(resp.val);
-    frag->flags = adf_os_ntohl(resp.flags);
 
-    atd_trace(ATD_DEBUG_CFG, ("RESULT val %d , flags 0x%04x", 
-              frag->val, frag->flags));
-	
+    *frag = adf_os_ntohl(resp);
+
+    atd_trace(ATD_DEBUG_CFG, ("RESULT val %d", *frag));
+
 fail:
     atd_trace((ATD_DEBUG_FUNCTRACE | ATD_DEBUG_CFG), ("End stat %x ",status ));
     return status;
@@ -5999,7 +5923,7 @@ fail:
 
 
 
-a_status_t 
+a_status_t
 atd_cfg_set_txpow(adf_drv_handle_t hdl, acfg_txpow_t *txpow)
 {
     atd_host_vap_t    *vap    = (atd_host_vap_t * )hdl;
@@ -6017,16 +5941,14 @@ atd_cfg_set_txpow(adf_drv_handle_t hdl, acfg_txpow_t *txpow)
         goto fail ;
     }
 
-    ptxpow = (atd_txpow_t *)atd_prep_cfg_hdr(nbuf, sizeof(atd_txpow_t), 
+    ptxpow = (atd_txpow_t *)atd_prep_cfg_hdr(nbuf, sizeof(atd_txpow_t),
                                             wifi, vap);
 
-    atd_trace(ATD_DEBUG_CFG, ("SET txpow - %d ; flags - 0x%x,", 
-					txpow->val, txpow->flags));
 
-    ptxpow->val = adf_os_htonl(txpow->val);
-    ptxpow->flags = adf_os_htonl(txpow->flags);
-	
-    status = wmi_cmd_send(__wifi2wmi(wifi), WMI_CMD_TXPOW_SET, nbuf, 
+    *ptxpow = adf_os_htonl(txpow);
+    atd_trace(ATD_DEBUG_CFG, ("SET txpow - %d", *txpow));
+
+    status = wmi_cmd_send(__wifi2wmi(wifi), WMI_CMD_TXPOW_SET, nbuf,
             (a_uint8_t *)&resp, sizeof(a_int32_t));
 
     if (status != A_STATUS_OK) {
@@ -6046,7 +5968,7 @@ fail:
 
 
 
-a_status_t 
+a_status_t
 atd_cfg_get_txpow(adf_drv_handle_t  hdl, acfg_txpow_t *txpow)
 {
     atd_host_vap_t *vap = (atd_host_vap_t *)hdl;
@@ -6056,7 +5978,7 @@ atd_cfg_get_txpow(adf_drv_handle_t  hdl, acfg_txpow_t *txpow)
     adf_nbuf_t nbuf;
 
     atd_trace((ATD_DEBUG_FUNCTRACE | ATD_DEBUG_CFG), ("Start"));
-	
+
     if ((nbuf = _atd_wmi_msg_alloc(__wifi2wmi(wifi))) == NULL) {
         atd_trace(ATD_DEBUG_CFG, ("Unable to allocate wmi buffer \n"));
         status = A_STATUS_ENOMEM;
@@ -6064,8 +5986,8 @@ atd_cfg_get_txpow(adf_drv_handle_t  hdl, acfg_txpow_t *txpow)
     }
 
     atd_prep_cfg_hdr(nbuf, 0, wifi, vap);
-	
-    status = wmi_cmd_send(__wifi2wmi(wifi), WMI_CMD_TXPOW_GET, nbuf, 
+
+    status = wmi_cmd_send(__wifi2wmi(wifi), WMI_CMD_TXPOW_GET, nbuf,
             (a_uint8_t *)&resp, sizeof(atd_txpow_t));
 
     if (status != A_STATUS_OK) {
@@ -6073,19 +5995,17 @@ atd_cfg_get_txpow(adf_drv_handle_t  hdl, acfg_txpow_t *txpow)
         status =  A_STATUS_EINVAL;
         goto fail;
     }
-	
-    txpow->val = adf_os_ntohl(resp.val);
-    txpow->flags = adf_os_ntohl(resp.flags);
 
-    atd_trace(ATD_DEBUG_CFG, ("RESULT val %d , flags 0x%04x", 
-              txpow->val, txpow->flags));
-	
+    *txpow = adf_os_ntohl(resp);
+
+    atd_trace(ATD_DEBUG_CFG, ("RESULT val %d ", *txpow));
+
 fail:
     atd_trace((ATD_DEBUG_FUNCTRACE | ATD_DEBUG_CFG), ("End stat %x ",status ));
     return status;
 }
 
-a_status_t 
+a_status_t
 atd_cfg_set_encode(adf_drv_handle_t  hdl, acfg_encode_t *encode)
 {
     atd_host_vap_t *vap = (atd_host_vap_t *)hdl;
@@ -6102,19 +6022,19 @@ atd_cfg_set_encode(adf_drv_handle_t  hdl, acfg_encode_t *encode)
         goto fail ;
     }
 
-    pkey = (atd_encode_rsp_t *)atd_prep_cfg_hdr(nbuf, 
-                                                sizeof(atd_encode_rsp_t), 
+    pkey = (atd_encode_rsp_t *)atd_prep_cfg_hdr(nbuf,
+                                                sizeof(atd_encode_rsp_t),
                                                 wifi, vap);
-	
+
     pkey->flag = adf_os_htonl(encode->flags);
     pkey->len = adf_os_htonl(encode->len);
 	if (encode->len)	 {
 		adf_os_mem_copy(pkey->key, encode->buff, ACFG_ENCODING_TOKEN_MAX);
-	}	
-    
+	}
+
     atd_trace(ATD_DEBUG_CFG, ("SET len %d , flags 0x%04x", \
               pkey->len, pkey->flag));
-    status = wmi_cmd_send(__wifi2wmi(wifi), WMI_CMD_ENCODE_SET, nbuf, 
+    status = wmi_cmd_send(__wifi2wmi(wifi), WMI_CMD_ENCODE_SET, nbuf,
             (a_uint8_t *)&resp, sizeof(a_int32_t));
 
     if (status != A_STATUS_OK) {
@@ -6132,7 +6052,7 @@ fail:
 	return status;
 }
 
-a_status_t 
+a_status_t
 atd_cfg_get_encode(adf_drv_handle_t  hdl, acfg_encode_t *encode)
 {
     atd_host_vap_t *vap = (atd_host_vap_t *)hdl;
@@ -6142,7 +6062,7 @@ atd_cfg_get_encode(adf_drv_handle_t  hdl, acfg_encode_t *encode)
     atd_encode_rsp_t key;
 
     atd_trace((ATD_DEBUG_FUNCTRACE | ATD_DEBUG_CFG), ("Start"));
-	
+
     if ((nbuf = _atd_wmi_msg_alloc(__wifi2wmi(wifi))) == NULL) {
         atd_trace(ATD_DEBUG_CFG, ("Unable to allocate wmi buffer \n"));
         status = A_STATUS_ENOMEM;
@@ -6150,8 +6070,8 @@ atd_cfg_get_encode(adf_drv_handle_t  hdl, acfg_encode_t *encode)
     }
 
     atd_prep_cfg_hdr(nbuf, 0, wifi, vap);
-	
-    status = wmi_cmd_send(__wifi2wmi(wifi), WMI_CMD_ENCODE_GET, nbuf, 
+
+    status = wmi_cmd_send(__wifi2wmi(wifi), WMI_CMD_ENCODE_GET, nbuf,
             (a_uint8_t *)&key, sizeof(atd_encode_rsp_t));
 
     if (status != A_STATUS_OK) {
@@ -6166,13 +6086,13 @@ atd_cfg_get_encode(adf_drv_handle_t  hdl, acfg_encode_t *encode)
 
     atd_trace(ATD_DEBUG_CFG, ("RESULT len %d , flags 0x%04x", \
               encode->len, encode->flags));
-	
+
 fail:
     atd_trace((ATD_DEBUG_FUNCTRACE | ATD_DEBUG_CFG), ("End stat %x ",status ));
     return status;
 }
 
-a_status_t 
+a_status_t
 atd_cfg_get_stats(adf_drv_handle_t  hdl, acfg_stats_t *stat)
 {
     atd_host_vap_t *vap = (atd_host_vap_t *)hdl;
@@ -6190,8 +6110,8 @@ atd_cfg_get_stats(adf_drv_handle_t  hdl, acfg_stats_t *stat)
     }
 
     atd_prep_cfg_hdr(nbuf, 0, wifi, vap);
-	
-    status = wmi_cmd_send(__wifi2wmi(wifi), WMI_CMD_STATS_GET, nbuf, 
+
+    status = wmi_cmd_send(__wifi2wmi(wifi), WMI_CMD_STATS_GET, nbuf,
             (a_uint8_t *)&resp, sizeof(atd_stats_t));
 
     if (status != A_STATUS_OK) {
@@ -6208,212 +6128,13 @@ atd_cfg_get_stats(adf_drv_handle_t  hdl, acfg_stats_t *stat)
     stat->discard_nwid = adf_os_ntohl(resp.discard_nwid);
     stat->discard_code = adf_os_ntohl(resp.discard_code);
     stat->missed_beacon = adf_os_ntohl(resp.missed_beacon);
-	
-fail:
-    atd_trace((ATD_DEBUG_FUNCTRACE | ATD_DEBUG_CFG), ("End stat %x ",status ));
-    return status;
-}
-
-/* security cfgs */
-a_status_t
-atd_cfg_wsupp_generic_request(adf_drv_handle_t hdl, wmi_id_t wid, 
-        void *data, a_uint32_t data_len,
-        void *reply, a_uint32_t reply_len)
-{
-    atd_host_vap_t *vap = (atd_host_vap_t * )hdl;
-    atd_host_wifi_t *wifi = vap->wifisc;
-    a_status_t status = A_STATUS_OK;
-    adf_nbuf_t nbuf;
-    void *dataptr;
-
-    atd_trace((ATD_DEBUG_FUNCTRACE | ATD_DEBUG_CFG), ("wid: %d len: %d %d", \
-                wid, data_len, reply_len));
-
-    if ((nbuf = _atd_wmi_msg_alloc(__wifi2wmi(wifi))) == NULL) {
-        atd_trace(ATD_DEBUG_CFG, ("Unable to allocate wmi buffer \n"));
-        status = A_STATUS_ENOMEM;
-        goto fail ;
-    }
-
-    dataptr = (acfg_wsupp_info_t *)atd_prep_cfg_hdr(nbuf, data_len, wifi, vap);
-
-    memcpy(dataptr, data, data_len);
-	
-    status = wmi_cmd_send(__wifi2wmi(wifi), wid, nbuf,
-                          (a_uint8_t *) reply, reply_len);
-
-
-    if (status != A_STATUS_OK){
-        atd_trace(ATD_DEBUG_CFG, (" wmi_cmd_send Failed stat = %x\n", status));
-        status = A_STATUS_EINVAL;
-        goto fail;
-    }
 
-fail:    
+fail:
     atd_trace((ATD_DEBUG_FUNCTRACE | ATD_DEBUG_CFG), ("End stat %x ",status ));
     return status;
-
-}
-
-a_status_t 
-atd_cfg_wsupp_init(adf_drv_handle_t  hdl, acfg_wsupp_info_t *winfo)
-{
-    u_int32_t retval;
-    a_status_t status = A_STATUS_OK;
-    status = atd_cfg_wsupp_generic_request(hdl, WMI_CMD_WSUPP_INIT, 
-        (void *) winfo, sizeof(acfg_wsupp_info_t),
-        (void *) &retval, sizeof(retval));
-	retval = adf_os_ntohl(retval);
-	atd_trace(ATD_DEBUG_CFG, ("%s: retval: %d\n", __func__, retval));
-    return status;
-}
-
-a_status_t 
-atd_cfg_wsupp_fini(adf_drv_handle_t  hdl, acfg_wsupp_info_t *winfo)
-{
-    u_int32_t retval;
-    a_status_t status = A_STATUS_OK;
-    status = atd_cfg_wsupp_generic_request(hdl, WMI_CMD_WSUPP_FINI, 
-        (void *) winfo, sizeof(acfg_wsupp_info_t),
-        (void *) &retval, sizeof(retval));
-	retval = adf_os_ntohl(retval);
-	atd_trace(ATD_DEBUG_CFG, ("%s: retval: %d\n", __func__, retval));
-    return status;
-}
-
-a_status_t 
-atd_cfg_wsupp_if_add(adf_drv_handle_t hdl, acfg_wsupp_info_t *winfo)
-{
-    u_int32_t retval;
-    a_status_t status = A_STATUS_OK;
-    status = atd_cfg_wsupp_generic_request(hdl, WMI_CMD_WSUPP_ADD_IF, 
-        (void *) winfo, sizeof(acfg_wsupp_info_t),
-        (void *) &retval, sizeof(retval));
-    retval = adf_os_ntohl(retval);
-    atd_trace(ATD_DEBUG_CFG, ("%s: retval: %d\n", __func__, retval));
-    return status;
-}
-
-a_status_t 
-atd_cfg_wsupp_if_remove(adf_drv_handle_t hdl, acfg_wsupp_info_t *winfo)
-{
-    u_int32_t retval;
-    a_status_t status = A_STATUS_OK;
-    status = atd_cfg_wsupp_generic_request(hdl, WMI_CMD_WSUPP_REMOVE_IF, 
-        (void *) winfo, sizeof(acfg_wsupp_info_t),
-        (void *) &retval, sizeof(retval));
-    retval = adf_os_ntohl(retval);
-    atd_trace(ATD_DEBUG_CFG, ("%s: retval: %d\n", __func__, retval));
-    return status;
-}
-
-a_status_t 
-atd_cfg_wsupp_nw_create(adf_drv_handle_t hdl, acfg_wsupp_info_t *winfo)
-{
-    u_int32_t retval;
-    a_status_t status = A_STATUS_OK;
-    status = atd_cfg_wsupp_generic_request(hdl, WMI_CMD_WSUPP_ADD_NW, 
-        (void *) winfo, sizeof(acfg_wsupp_info_t),
-        (void *) &retval, sizeof(retval));
-    winfo->u.nw_cfg.networkid = adf_os_ntohl(retval);
-    atd_trace(ATD_DEBUG_CFG, ("%s: retval: %d\n", __func__, retval));
-    return status;
-}
-
-a_status_t 
-atd_cfg_wsupp_nw_delete(adf_drv_handle_t hdl, acfg_wsupp_info_t *winfo)
-{
-    u_int32_t retval;
-    a_status_t status = A_STATUS_OK;
-
-    winfo->u.nw_cfg.networkid = adf_os_htonl(winfo->u.nw_cfg.networkid);
-    status = atd_cfg_wsupp_generic_request(hdl, WMI_CMD_WSUPP_REMOVE_NW, 
-        (void *) winfo, sizeof(acfg_wsupp_info_t),
-        (void *) &retval, sizeof(retval));
-    retval = adf_os_ntohl(retval);
-    atd_trace(ATD_DEBUG_CFG, ("%s: retval: %d\n", __func__, retval));
-    return status;
-}
-
-a_status_t 
-atd_cfg_wsupp_nw_set(adf_drv_handle_t hdl, acfg_wsupp_info_t *winfo)
-{
-    u_int32_t retval;
-    a_status_t status = A_STATUS_OK;
-
-    winfo->u.nw_cfg.item = adf_os_htonl(winfo->u.nw_cfg.item);
-    winfo->u.nw_cfg.networkid = adf_os_htonl(winfo->u.nw_cfg.networkid);
-    status = atd_cfg_wsupp_generic_request(hdl, WMI_CMD_WSUPP_SET_NETWORK, 
-        (void *) winfo, sizeof(acfg_wsupp_info_t),
-        (void *) &retval, sizeof(retval));
-    retval = adf_os_ntohl(retval);
-    atd_trace(ATD_DEBUG_CFG, ("%s: retval: %d\n", __func__, retval));
-    return status;
-}
-
-a_status_t 
-atd_cfg_wsupp_nw_get(adf_drv_handle_t hdl, acfg_wsupp_info_t *winfo)
-{
-    acfg_wsupp_get_reply_t retval;
-    a_status_t status = A_STATUS_OK;
-
-    winfo->u.nw_cfg.item = adf_os_htonl(winfo->u.nw_cfg.item);
-    winfo->u.nw_cfg.networkid = adf_os_htonl(winfo->u.nw_cfg.networkid);
-    status = atd_cfg_wsupp_generic_request(hdl, WMI_CMD_WSUPP_GET_NETWORK, 
-        (void *) winfo, sizeof(acfg_wsupp_info_t),
-        (void *) &retval, sizeof(retval));
-    memcpy(winfo->u.nw_cfg.reply, retval.reply, retval.len);
-	winfo->u.nw_cfg.reply[retval.len] = '\0';
-    winfo->u.nw_cfg.reply_len = retval.len;
-    return status;
-}
-
-a_status_t 
-atd_cfg_wsupp_nw_list(adf_drv_handle_t hdl, acfg_wsupp_info_t *winfo)
-{
-    acfg_wsupp_get_reply_t retval;
-    a_status_t status = A_STATUS_OK;
-
-    status = atd_cfg_wsupp_generic_request(hdl, WMI_CMD_WSUPP_LIST_NETWORK, 
-        (void *) winfo, sizeof(acfg_wsupp_info_t),
-        (void *) &retval, sizeof(retval));
-    memcpy(winfo->u.nw_cfg.reply, retval.reply, retval.len);
-    winfo->u.nw_cfg.reply[retval.len] = '\0';
-    winfo->u.nw_cfg.reply_len = retval.len;
-    return status;
-}
-
-a_status_t 
-atd_cfg_wsupp_wps_req(adf_drv_handle_t hdl, acfg_wsupp_info_t *winfo)
-{
-    a_uint8_t retval[ACFG_WSUPP_REPLY_LEN];
-    a_status_t status = A_STATUS_OK;
-
-    winfo->u.wps_cfg.type = adf_os_htonl(winfo->u.wps_cfg.type);
-    status = atd_cfg_wsupp_generic_request(hdl, WMI_CMD_WSUPP_SET_WPS, 
-        (void *) winfo, sizeof(acfg_wsupp_info_t),
-        (void *) &retval, sizeof(retval));
-    memcpy(winfo->u.wps_cfg.reply, retval, strlen(retval));
-    winfo->u.wps_cfg.reply_len = strlen(retval);
-    return status;
-}
-
-a_status_t 
-atd_cfg_wsupp_set(adf_drv_handle_t hdl, acfg_wsupp_info_t *winfo)
-{
-    u_int32_t retval;
-    a_status_t status = A_STATUS_OK;
-
-    winfo->u.rt_cfg.type = adf_os_htonl(winfo->u.rt_cfg.type);
-    status = atd_cfg_wsupp_generic_request(hdl, WMI_CMD_WSUPP_SET, 
-        (void *) winfo, sizeof(acfg_wsupp_info_t),
-        (void *) &retval, sizeof(retval));
-    retval = adf_os_ntohl(retval);
-    atd_trace(ATD_DEBUG_CFG, ("%s: retval: %d\n", __func__, retval));
-    return status;
 }
 
-static a_status_t 
+static a_status_t
 atd_cfg_set_reg(adf_drv_handle_t hdl, a_uint32_t offset, a_uint32_t value)
 {
     atd_host_wifi_t    *wifi  = (atd_host_wifi_t * )hdl;
@@ -6449,7 +6170,7 @@ fail:
     return status;
 }
 
-static a_status_t 
+static a_status_t
 atd_cfg_get_reg(adf_drv_handle_t hdl, a_uint32_t offset, a_uint32_t *value)
 {
     atd_host_wifi_t    *wifi  = (atd_host_wifi_t * )hdl;
@@ -6491,7 +6212,7 @@ fail:
    return status;
 }
 
-static a_status_t 
+static a_status_t
 atd_cfg_set_hwaddr(adf_drv_handle_t hdl, acfg_macaddr_t *mac)
 {
     atd_host_wifi_t   *wifi   = (atd_host_wifi_t * )hdl;
@@ -6534,7 +6255,7 @@ fail:
     return status;
 }
 
-static a_status_t 
+static a_status_t
 atd_cfg_set_vap_wmmparams(adf_drv_handle_t hdl, a_uint32_t *param, a_uint32_t value)
 {
     atd_host_vap_t    *vap    = (atd_host_vap_t * )hdl;
@@ -6551,7 +6272,7 @@ atd_cfg_set_vap_wmmparams(adf_drv_handle_t hdl, a_uint32_t *param, a_uint32_t va
         goto fail ;
     }
 
-    vap_param     = (atd_wmmparams_t *)atd_prep_cfg_hdr(nbuf, sizeof(atd_wmmparams_t), 
+    vap_param     = (atd_wmmparams_t *)atd_prep_cfg_hdr(nbuf, sizeof(atd_wmmparams_t),
                                                  wifi, vap);
     vap_param->param[0]     =   adf_os_htonl(*(a_uint32_t *)param);
 	vap_param->param[1]     =   adf_os_htonl(*((a_uint32_t *)param+1));
@@ -6566,7 +6287,7 @@ fail:
     return status;
 }
 
-static a_status_t 
+static a_status_t
 atd_cfg_get_vap_wmmparams(adf_drv_handle_t hdl, a_uint32_t *param, a_uint32_t *value)
 {
     atd_host_vap_t    *vap    = (atd_host_vap_t * )hdl;
@@ -6585,7 +6306,7 @@ atd_cfg_get_vap_wmmparams(adf_drv_handle_t hdl, a_uint32_t *param, a_uint32_t *v
         goto fail ;
     }
 
-    vap_param     = (atd_wmmparams_t *)atd_prep_cfg_hdr(nbuf, sizeof(atd_wmmparams_t), 
+    vap_param     = (atd_wmmparams_t *)atd_prep_cfg_hdr(nbuf, sizeof(atd_wmmparams_t),
                                                  wifi, vap);
     vap_param->param[0]     =   adf_os_htonl(*(a_uint32_t *)param);
 	vap_param->param[1]     =   adf_os_htonl(*((a_uint32_t *)param+1));
@@ -6606,10 +6327,9 @@ fail:
     return status;
 }
 
-static a_status_t atd_cfg_nawds_config(adf_drv_handle_t hdl, 
+static a_status_t atd_cfg_nawds_config(adf_drv_handle_t hdl,
                                         acfg_nawds_cfg_t *nawds_conf)
 {
-
     atd_host_vap_t     *vap    = (atd_host_vap_t * )hdl;
     atd_host_wifi_t *wifi   = vap->wifisc;
     atd_nawds_cfg_t         *pld, result = {0};
@@ -6622,31 +6342,31 @@ static a_status_t atd_cfg_nawds_config(adf_drv_handle_t hdl,
 
     switch(nawds_conf->cmdtype)
     {
-        case NAWDS_SET_MODE:
-        case NAWDS_SET_DEFCAPS:
-        case NAWDS_SET_OVERRIDE:
-        case NAWDS_SET_ADDR:
-        case NAWDS_CLR_ADDR:
-        case NAWDS_GET:
+        case IEEE80211_WLANCONFIG_NAWDS_SET_MODE:
+        case IEEE80211_WLANCONFIG_NAWDS_SET_DEFCAPS:
+        case IEEE80211_WLANCONFIG_NAWDS_SET_OVERRIDE:
+        case IEEE80211_WLANCONFIG_NAWDS_SET_ADDR:
+        case IEEE80211_WLANCONFIG_NAWDS_CLR_ADDR:
+        case IEEE80211_WLANCONFIG_NAWDS_GET:
             if ((nbuf = _atd_wmi_msg_alloc(__wifi2wmi(wifi))) == NULL) {
                 atd_trace(ATD_DEBUG_CFG, ("Unable to allocate wmi buffer \n"));
                 status = A_STATUS_ENOMEM;
                 goto fail ;
             }
-            pld = (atd_nawds_cfg_t *)atd_prep_cfg_hdr(nbuf, 
-                                                 sizeof(atd_nawds_cfg_t), 
+            pld = (atd_nawds_cfg_t *)atd_prep_cfg_hdr(nbuf,
+                                                 sizeof(atd_nawds_cfg_t),
                                                  wifi, vap);
             pld->cmdtype = adf_os_htonl(nawds_conf->cmdtype);
             pld->data.nawds.num = nawds_conf->data.nawds.num;
             pld->data.nawds.mode = nawds_conf->data.nawds.mode;
             pld->data.nawds.defcaps = nawds_conf->data.nawds.defcaps;
             pld->data.nawds.override = nawds_conf->data.nawds.override;
-            adf_os_mem_copy(pld->data.nawds.mac, 
+            adf_os_mem_copy(pld->data.nawds.mac,
                             nawds_conf->data.nawds.mac, ACFG_MACADDR_LEN);
             pld->data.nawds.caps = nawds_conf->data.nawds.caps;
-            if(nawds_conf->cmdtype == NAWDS_GET)
+            if(nawds_conf->cmdtype == IEEE80211_WLANCONFIG_NAWDS_GET)
             {
-                status = wmi_cmd_send(__wifi2wmi(wifi), WMI_CMD_NAWDS_CONFIG, 
+                status = wmi_cmd_send(__wifi2wmi(wifi), WMI_CMD_NAWDS_CONFIG,
                         nbuf,(a_uint8_t*)&result, sizeof(atd_nawds_cfg_t));
                 nawds_conf->cmdtype = adf_os_ntohl(result.cmdtype);
                 nawds_conf->status = adf_os_ntohl(result.status);
@@ -6654,49 +6374,34 @@ static a_status_t atd_cfg_nawds_config(adf_drv_handle_t hdl,
                 nawds_conf->data.nawds.mode = result.data.nawds.mode;
                 nawds_conf->data.nawds.defcaps = result.data.nawds.defcaps;
                 nawds_conf->data.nawds.override = result.data.nawds.override;
-                adf_os_mem_copy(nawds_conf->data.nawds.mac, 
+                adf_os_mem_copy(nawds_conf->data.nawds.mac,
                                 result.data.nawds.mac, ACFG_MACADDR_LEN);
                 nawds_conf->data.nawds.caps = result.data.nawds.caps;
             }
             else
             {
-                status = wmi_cmd_send(__wifi2wmi(wifi), WMI_CMD_NAWDS_CONFIG, 
+                status = wmi_cmd_send(__wifi2wmi(wifi), WMI_CMD_NAWDS_CONFIG,
                         nbuf, NULL, 0);
             }
             break;
-        
-        case WNM_SET_BSSMAX:
-        case WNM_GET_BSSMAX:
-        case WNM_TFS_ADD:
-        case WNM_TFS_DELETE:
-        case WNM_SET_TIMBCAST:
-        case WNM_GET_TIMBCAST:
+
+        case IEEE80211_WLANCONFIG_WNM_SET_BSSMAX:
+        case IEEE80211_WLANCONFIG_WNM_GET_BSSMAX:
+        case IEEE80211_WLANCONFIG_WNM_TFS_ADD:
+        case IEEE80211_WLANCONFIG_WNM_TFS_DELETE:
+        case IEEE80211_WLANCONFIG_WNM_SET_TIMBCAST:
+        case IEEE80211_WLANCONFIG_WNM_GET_TIMBCAST:
             if ((nbuf = _atd_wmi_msg_alloc(__wifi2wmi(wifi))) == NULL) {
                 atd_trace(ATD_DEBUG_CFG, ("Unable to allocate wmi buffer \n"));
                 status = A_STATUS_ENOMEM;
                 goto fail ;
             }
-            pld = (atd_nawds_cfg_t *)atd_prep_cfg_hdr(nbuf, 
-                                                 sizeof(atd_nawds_cfg_t), 
+            pld = (atd_nawds_cfg_t *)atd_prep_cfg_hdr(nbuf,
+                                                 sizeof(atd_nawds_cfg_t),
                                                  wifi, vap);
             pld->cmdtype = adf_os_htonl(nawds_conf->cmdtype);
-            adf_os_mem_copy(&pld->data.wnm, &nawds_conf->data.wnm, sizeof(struct acfg_wnm_cfg));
-            if(nawds_conf->cmdtype == WNM_GET_BSSMAX 
-                || nawds_conf->cmdtype == WNM_GET_TIMBCAST)
-            {
-                status = wmi_cmd_send(__wifi2wmi(wifi), WMI_CMD_NAWDS_CONFIG, 
-                        nbuf,(a_uint8_t*)&result, sizeof(atd_nawds_cfg_t));
-                nawds_conf->cmdtype = adf_os_ntohl(result.cmdtype);
-                nawds_conf->status = adf_os_ntohl(result.status);
-                adf_os_mem_copy(&nawds_conf->data.wnm, &result.data.wnm, sizeof(struct acfg_wnm_cfg));
-            }
-            else
-            {
-                status = wmi_cmd_send(__wifi2wmi(wifi), WMI_CMD_NAWDS_CONFIG, 
-                        nbuf, NULL, 0);
-            }
             break;
-        
+
         default:
             atd_trace(ATD_DEBUG_CFG, (" Invalid Nawds Command \n"));
             status = A_STATUS_EINVAL;
@@ -6709,8 +6414,7 @@ fail:
     return status;
 }
 
-
-static a_status_t 
+static a_status_t
 atd_cfg_doth_chsw(adf_drv_handle_t hdl, acfg_doth_chsw_t *chsw)
 {
     atd_host_vap_t *vap = (atd_host_vap_t *)hdl;
@@ -6757,15 +6461,15 @@ fail:
 
 
 
-/** 
- * @brief 
- * 
+/**
+ * @brief
+ *
  * @param hdl
  * @param addr
- * 
- * @return 
+ *
+ * @return
  */
-static a_status_t 
+static a_status_t
 atd_cfg_addmac(adf_drv_handle_t hdl, acfg_macaddr_t *addr)
 {
     atd_host_vap_t *vap = (atd_host_vap_t *)hdl;
@@ -6812,15 +6516,15 @@ fail:
 
 
 
-/** 
- * @brief 
- * 
+/**
+ * @brief
+ *
  * @param hdl
  * @param addr
- * 
- * @return 
+ *
+ * @return
  */
-static a_status_t 
+static a_status_t
 atd_cfg_delmac(adf_drv_handle_t hdl, acfg_macaddr_t *addr)
 {
     atd_host_vap_t *vap = (atd_host_vap_t *)hdl;
@@ -6867,15 +6571,15 @@ fail:
 
 
 
-/** 
- * @brief 
- * 
+/**
+ * @brief
+ *
  * @param hdl
  * @param addr
- * 
- * @return 
+ *
+ * @return
  */
-static a_status_t 
+static a_status_t
 atd_cfg_kickmac(adf_drv_handle_t hdl, acfg_macaddr_t *addr)
 {
     atd_host_vap_t *vap = (atd_host_vap_t *)hdl;
@@ -6921,15 +6625,15 @@ fail:
 }
 
 
-/** 
+/**
  * @brief Get Channel Info
- * 
+ *
  * @param hdl
  * @param mode
- * 
- * @return 
+ *
+ * @return
  */
-a_status_t 
+a_status_t
 atd_cfg_get_chan_info(adf_drv_handle_t hdl, acfg_chan_info_t *chan_info)
 {
     atd_host_vap_t     *vap    = (atd_host_vap_t *)hdl;
@@ -6952,12 +6656,12 @@ atd_cfg_get_chan_info(adf_drv_handle_t hdl, acfg_chan_info_t *chan_info)
         goto fail_free;
     }
 
-    atd_trace((ATD_DEBUG_FUNCTRACE | ATD_DEBUG_CFG), 
+    atd_trace((ATD_DEBUG_FUNCTRACE | ATD_DEBUG_CFG),
                                 ("chan_info - %p ", chan_info));
 
     atd_prep_cfg_hdr(nbuf, 0, wifi, vap);
 
-    status = wmi_cmd_send(__wifi2wmi(wifi), WMI_CMD_CHAN_INFO_GET, nbuf, 
+    status = wmi_cmd_send(__wifi2wmi(wifi), WMI_CMD_CHAN_INFO_GET, nbuf,
                           (a_uint8_t *)chan, sizeof(atd_chan_info_t));
 
     if (status == A_STATUS_OK) {
@@ -6987,15 +6691,15 @@ fail:
 }
 
 
-/** 
+/**
  * @brief Get Channel List
- * 
+ *
  * @param hdl
  * @param mode
- * 
- * @return 
+ *
+ * @return
  */
-a_status_t 
+a_status_t
 atd_cfg_get_chan_list(adf_drv_handle_t hdl, acfg_opaque_t *chan_list)
 {
     atd_host_vap_t     *vap    = (atd_host_vap_t *)hdl;
@@ -7017,14 +6721,14 @@ atd_cfg_get_chan_list(adf_drv_handle_t hdl, acfg_opaque_t *chan_list)
         goto fail;
     }
 
-    atd_trace((ATD_DEBUG_FUNCTRACE | ATD_DEBUG_CFG), 
+    atd_trace((ATD_DEBUG_FUNCTRACE | ATD_DEBUG_CFG),
                                 ("len - %d ", chan_list->len));
 
     buf = (a_uint32_t *)atd_prep_cfg_hdr(nbuf, sizeof(a_uint32_t), wifi, vap);
 
     *buf = adf_os_htonl(chan_list->len);
 
-    status = wmi_cmd_send(__wifi2wmi(wifi), WMI_CMD_CHAN_LIST_GET, nbuf, 
+    status = wmi_cmd_send(__wifi2wmi(wifi), WMI_CMD_CHAN_LIST_GET, nbuf,
                           chan_list->pointer, chan_list->len);
 
 fail:
@@ -7034,15 +6738,15 @@ fail:
 }
 
 
-/** 
+/**
  * @brief Get ACL MAC Address List
- * 
+ *
  * @param hdl
  * @param mode
- * 
- * @return 
+ *
+ * @return
  */
-a_status_t 
+a_status_t
 atd_cfg_get_mac_address(adf_drv_handle_t hdl, acfg_macacl_t *mac_addr_list)
 {
     atd_host_vap_t     *vap    = (atd_host_vap_t *)hdl;
@@ -7058,20 +6762,20 @@ atd_cfg_get_mac_address(adf_drv_handle_t hdl, acfg_macacl_t *mac_addr_list)
         status = A_STATUS_ENOMEM;
     }
 
-    atd_trace((ATD_DEBUG_FUNCTRACE | ATD_DEBUG_CFG), 
+    atd_trace((ATD_DEBUG_FUNCTRACE | ATD_DEBUG_CFG),
                                 ("get mac addr "));
 
     buf = (a_uint32_t *)atd_prep_cfg_hdr(nbuf, 0, wifi, vap);
 
 
-    status = wmi_cmd_send(__wifi2wmi(wifi), 
-                          WMI_CMD_MAC_ADDR_GET, 
-                          nbuf, (a_uint8_t *)&mac_addr_list_resp, 
+    status = wmi_cmd_send(__wifi2wmi(wifi),
+                          WMI_CMD_MAC_ADDR_GET,
+                          nbuf, (a_uint8_t *)&mac_addr_list_resp,
                           sizeof(atd_macacl_t));
     mac_addr_list->num = adf_os_ntohl(mac_addr_list_resp.num);
     for (i = 0; i < mac_addr_list->num; i++)
-        adf_os_mem_copy(mac_addr_list->macaddr[i], 
-                        mac_addr_list_resp.macaddr[i], 
+        adf_os_mem_copy(mac_addr_list->macaddr[i],
+                        mac_addr_list_resp.macaddr[i],
                         ACFG_MACADDR_LEN);
 
     atd_trace((ATD_DEBUG_FUNCTRACE | ATD_DEBUG_CFG),
@@ -7079,146 +6783,30 @@ atd_cfg_get_mac_address(adf_drv_handle_t hdl, acfg_macacl_t *mac_addr_list)
     return status;
 }
 
-
-/** 
+/**
  * @brief Get P2P Param
- * 
+ *
  * @param hdl
  * @param mode
- * 
- * @return 
+ *
+ * @return
  */
-a_status_t 
+a_status_t
 atd_cfg_get_p2p_param(adf_drv_handle_t hdl, acfg_p2p_param_t *p2p_param)
 {
-    atd_host_vap_t     *vap    = (atd_host_vap_t *)hdl;
-    atd_host_wifi_t    *wifi   = vap->wifisc;
-    a_status_t          status = A_STATUS_OK;
-    adf_nbuf_t          nbuf;
-    a_uint32_t          *buf;
-    a_uint32_t          *resp_buf;
-
-    /*Error Check*/
-    if(p2p_param->length < 0) {
-        atd_trace(ATD_DEBUG_CFG, ("Invalid length\n"));
-        status = A_STATUS_EINVAL;
-        goto fail;
-    }
-
-    resp_buf = adf_os_mem_alloc(NULL, p2p_param->length + sizeof(a_uint32_t));
-    if (!resp_buf) {
-        atd_trace(ATD_DEBUG_CFG, ("Unable to allocate response buffer \n"));
-        status = A_STATUS_ENOMEM;
-        goto fail;
-    }
-
-    if ((nbuf = _atd_wmi_msg_alloc(__wifi2wmi(wifi))) == NULL) {
-        atd_trace(ATD_DEBUG_CFG, ("Unable to allocate wmi buffer \n"));
-        adf_os_mem_free(resp_buf);
-        status = A_STATUS_ENOMEM;
-        goto fail;
-    }
-
-    atd_trace((ATD_DEBUG_FUNCTRACE | ATD_DEBUG_CFG), 
-                                ("len - %d ", p2p_param->length));
-
-    if (p2p_param->param == IEEE80211_IOC_P2P_FETCH_FRAME) {
-        a_uint32_t is_empty[2] = {0};
-
-        buf = (a_uint32_t *)atd_prep_cfg_hdr(nbuf, 2 * sizeof(a_uint32_t), wifi, vap);
-
-        *buf = adf_os_htonl(sizeof(a_uint32_t));
-        *(buf + 1) =  adf_os_htonl(IEEE80211_IOC_P2P_FRAME_LIST_EMPTY);
-
-        status = wmi_cmd_send(__wifi2wmi(wifi), 
-                          WMI_CMD_P2P_PARAM_GET, 
-                          nbuf, (a_uint8_t *)is_empty, sizeof(is_empty));
-
-        if (status == A_STATUS_OK && 
-                adf_os_ntohl(is_empty[0]) == sizeof(a_uint32_t) && 
-                is_empty[1]) {
-           atd_trace(ATD_DEBUG_CFG, ("Return ENOSPC \n"));
-           adf_os_mem_free(resp_buf);
-           status = A_STATUS_ENOSPC;
-           goto fail;
-        }
-    
-        if ((nbuf = _atd_wmi_msg_alloc(__wifi2wmi(wifi))) == NULL) {
-            atd_trace(ATD_DEBUG_CFG, ("Unable to allocate wmi buffer \n"));
-            adf_os_mem_free(resp_buf);
-            status = A_STATUS_ENOMEM;
-            goto fail;
-        }
-    }
-
-    buf = (a_uint32_t *)atd_prep_cfg_hdr(nbuf, 2 * sizeof(a_uint32_t), wifi, vap);
-
-    *buf = adf_os_htonl(p2p_param->length);
-    *(buf + 1) =  adf_os_htonl(p2p_param->param);
-
-    status = wmi_cmd_send(__wifi2wmi(wifi), 
-                          WMI_CMD_P2P_PARAM_GET, 
-                          nbuf, (a_uint8_t *)resp_buf, 
-                          p2p_param->length + sizeof(a_uint32_t));
-
-    if (status == A_STATUS_OK) {
-        if (p2p_param->length > adf_os_ntohl(*resp_buf))
-            p2p_param->length = adf_os_ntohl(*resp_buf);
-        adf_os_mem_copy(p2p_param->pointer, 
-                        resp_buf + 1, p2p_param->length);
-
-        switch (p2p_param->param) {
-            case IEEE80211_IOC_P2P_FIND_BEST_CHANNEL:
-            {
-                int i;
-                acfg_best_freq_t *f = (acfg_best_freq_t *)p2p_param->pointer;
-                for (i = 0; i < ACFG_MAX_BEST_CHANS; i++)
-                    f->freq[i] = adf_os_ntohl(f->freq[i]);
-            }
-            break;
-
-            case IEEE80211_IOC_P2P_FETCH_FRAME:
-            {
-                acfg_rx_frame_t *fr = (acfg_rx_frame_t *)p2p_param->pointer;
-                fr->freq = adf_os_ntohl(fr->freq);
-                fr->type = adf_os_ntohl(fr->type);
-            }
-            break;
-
-            case IEEE80211_IOC_P2P_NOA_INFO:
-            {
-                 int i;
-                 acfg_noa_info_t *noa = (acfg_noa_info_t *)p2p_param->pointer;
-                 noa->tsf = adf_os_ntohl(noa->tsf);
-                 for (i = 0; i < ACFG_MAX_NOA_DESCS; i++) {
-                     noa->desc[i].type_count = adf_os_ntohl(noa->desc[i].type_count);
-                     noa->desc[i].duration = adf_os_ntohl(noa->desc[i].duration);
-                     noa->desc[i].interval = adf_os_ntohl(noa->desc[i].interval);
-                     noa->desc[i].start_time = adf_os_ntohl(noa->desc[i].start_time);
-                 }
-            }
-            break;
-        }
-    }
-
-    adf_os_mem_free(resp_buf);
-
-fail:
-    atd_trace((ATD_DEBUG_FUNCTRACE | ATD_DEBUG_CFG),
-                                ("End status %x ", status));
-    return status;
+    return 0;
 }
 
 
-/** 
+/**
  * @brief Set P2P Param
- * 
+ *
  * @param hdl
  * @param mode
- * 
- * @return 
+ *
+ * @return
  */
-a_status_t 
+a_status_t
 atd_cfg_set_p2p_param(adf_drv_handle_t hdl, acfg_p2p_param_t *p2p_param)
 {
     atd_host_vap_t     *vap    = (atd_host_vap_t *)hdl;
@@ -7237,36 +6825,19 @@ atd_cfg_set_p2p_param(adf_drv_handle_t hdl, acfg_p2p_param_t *p2p_param)
 
     n = ((p2p_param->length + (2 * sizeof(a_uint32_t))) / WMI_DEF_MSG_LEN) + 1;
 
-    //if ((nbuf = _atd_wmi_msg_alloc(__wifi2wmi(wifi))) == NULL)
     if ((nbuf = wmi_msg_alloc(__wifi2wmi(wifi), n * WMI_DEF_MSG_LEN)) == NULL) {
         atd_trace(ATD_DEBUG_CFG, ("Unable to allocate wmi buffer \n"));
         status = A_STATUS_ENOMEM;
         goto fail;
     }
 
-    atd_trace((ATD_DEBUG_FUNCTRACE | ATD_DEBUG_CFG), 
+    atd_trace((ATD_DEBUG_FUNCTRACE | ATD_DEBUG_CFG),
                                 ("len - %d ", p2p_param->length));
 
-    buf = (a_uint32_t *)atd_prep_cfg_hdr(nbuf, 
+    buf = (a_uint32_t *)atd_prep_cfg_hdr(nbuf,
                     (2 * sizeof(a_uint32_t)) + p2p_param->length, wifi, vap);
 
     switch (p2p_param->param) {
-        case IEEE80211_IOC_P2P_SET_CHANNEL:
-        {
-            acfg_set_chan_t *set_chan = (acfg_set_chan_t *)p2p_param->pointer;
-            set_chan->freq = adf_os_htonl(set_chan->freq);
-            set_chan->req_id = adf_os_htonl(set_chan->req_id);
-            set_chan->time = adf_os_htonl(set_chan->time);
-        }
-        break;
-
-        case IEEE80211_IOC_P2P_SEND_ACTION:
-        {
-            acfg_send_act_t *act = (acfg_send_act_t *)p2p_param->pointer;
-            act->freq = adf_os_htonl(act->freq);
-        }
-        break;
-
         case IEEE80211_IOC_SCAN_REQ:
         {
             int i;
@@ -7276,30 +6847,13 @@ atd_cfg_set_p2p_param(adf_drv_handle_t hdl, acfg_p2p_param_t *p2p_param)
             scan->len = adf_os_htons(scan->len);
         }
         break;
-
-        case IEEE80211_IOC_P2P_GO_NOA:
-        {
-            int i, num;
-            u_int16_t tmp;
-            acfg_noa_req_t *noa = (acfg_noa_req_t *)p2p_param->pointer;
-            num = p2p_param->length / sizeof(*noa);
-            for (i = 0; i < num && i < ACFG_MAX_NOA_REQ; i++) {
-                adf_os_mem_copy(&tmp, noa[i].offset_next_tbtt, sizeof(tmp));
-                tmp = adf_os_htons(tmp);
-                adf_os_mem_copy(noa[i].offset_next_tbtt, &tmp, sizeof(tmp));
-                adf_os_mem_copy(&tmp, noa[i].duration, sizeof(tmp));
-                tmp = adf_os_htons(tmp);
-                adf_os_mem_copy(noa[i].duration, &tmp, sizeof(tmp));
-            }
-        }
-        break;
     }
 
     *buf = adf_os_htonl(p2p_param->length);
     *(buf + 1) =  adf_os_htonl(p2p_param->param);
     adf_os_mem_copy(buf + 2, p2p_param->pointer, p2p_param->length);
 
-    status = wmi_cmd_send(__wifi2wmi(wifi), 
+    status = wmi_cmd_send(__wifi2wmi(wifi),
                           WMI_CMD_P2P_PARAM_SET, nbuf, NULL, 0);
 
 fail:
@@ -7308,7 +6862,7 @@ fail:
     return status;
 }
 
-a_status_t 
+a_status_t
 atd_cfg_acl_setmac(adf_drv_handle_t hdl, acfg_macaddr_t *mac, a_uint8_t add)
 {
     a_status_t          status = A_STATUS_OK;
@@ -7319,13 +6873,13 @@ atd_cfg_acl_setmac(adf_drv_handle_t hdl, acfg_macaddr_t *mac, a_uint8_t add)
     a_int32_t          resp;
 
     atd_trace((ATD_DEBUG_FUNCTRACE | ATD_DEBUG_CFG), ("Start"));
-	
+
     if ((nbuf = _atd_wmi_msg_alloc(__wifi2wmi(wifi))) == NULL) {
         atd_trace(ATD_DEBUG_CFG, ("Unable to allocate wmi buffer \n"));
         status = A_STATUS_ENOMEM;
         goto fail ;
     }
-    pmac = (acfg_macaddr_t *)atd_prep_cfg_hdr(nbuf, sizeof(acfg_macaddr_t), 
+    pmac = (acfg_macaddr_t *)atd_prep_cfg_hdr(nbuf, sizeof(acfg_macaddr_t),
                                               wifi, vap);
 
     memcpy(pmac->addr, mac->addr, ACFG_MACADDR_LEN);
@@ -7334,10 +6888,10 @@ atd_cfg_acl_setmac(adf_drv_handle_t hdl, acfg_macaddr_t *mac, a_uint8_t add)
                 pmac->addr[0], pmac->addr[1], pmac->addr[2], pmac->addr[3], \
                 pmac->addr[4], pmac->addr[5]));
 	if (add) {
-	    status = wmi_cmd_send(__wifi2wmi(wifi), WMI_CMD_ACL_ADDMAC, nbuf, 
+	    status = wmi_cmd_send(__wifi2wmi(wifi), WMI_CMD_ACL_ADDMAC, nbuf,
     	        (a_uint8_t *)&resp, sizeof(a_int32_t));
 	} else {
-	    status = wmi_cmd_send(__wifi2wmi(wifi), WMI_CMD_ACL_DELMAC, nbuf, 
+	    status = wmi_cmd_send(__wifi2wmi(wifi), WMI_CMD_ACL_DELMAC, nbuf,
     	        (a_uint8_t *)&resp, sizeof(a_int32_t));
 	}
     if (status != A_STATUS_OK) {
@@ -7442,18 +6996,18 @@ atd_cfg_get_profile(adf_drv_handle_t       hdl, acfg_radio_vap_info_t *profile)
     profile->ampdu_limit_bytes = 0;
     profile->ampdu_subframes = 0;
     for (i = 0; i < profile->num_vaps; i++) {
-        adf_os_mem_copy(profile->vap_info[i].vap_name, 
+        adf_os_mem_copy(profile->vap_info[i].vap_name,
                         profile_result.vap_info[i].vap_name, ACFG_MAX_IFNAME);
-        adf_os_mem_copy(profile->vap_info[i].vap_mac, 
+        adf_os_mem_copy(profile->vap_info[i].vap_mac,
                         profile_result.vap_info[i].vap_mac, ACFG_MACADDR_LEN);
         profile->vap_info[i].phymode = profile_result.vap_info[i].phymode;
         profile->vap_info[i].sec_method = profile_result.vap_info[i].sec_method;
         profile->vap_info[i].cipher = profile_result.vap_info[i].cipher;
-        adf_os_mem_copy(profile->vap_info[i].wep_key, 
+        adf_os_mem_copy(profile->vap_info[i].wep_key,
                         profile_result.vap_info[i].wep_key, ACFG_MAX_PSK_LEN);
-        profile->vap_info[i].wep_key_len = 
+        profile->vap_info[i].wep_key_len =
                                     profile_result.vap_info[i].wep_key_len;
-        profile->vap_info[i].wep_key_idx = 
+        profile->vap_info[i].wep_key_idx =
                                     profile_result.vap_info[i].wep_key_idx;
         profile->vap_info[i].wds_enabled = 0;
         adf_os_mem_set(profile->vap_info[i].wds_addr, 0, ACFG_MACSTR_LEN);
@@ -7462,7 +7016,7 @@ atd_cfg_get_profile(adf_drv_handle_t       hdl, acfg_radio_vap_info_t *profile)
 
 	atd_convert_profile(profile);
 fail:
-	return status;	
+	return status;
 }
 
 a_status_t atd_cfg_set_chwidthswitch(adf_drv_handle_t  hdl, acfg_set_chn_width_t* chnw)
diff --git a/host/thin_driver/atd/atd_dev.c b/host/thin_driver/atd/atd_dev.c
index 95bffc3..06267f60 100644
--- a/host/thin_driver/atd/atd_dev.c
+++ b/host/thin_driver/atd/atd_dev.c
@@ -24,148 +24,148 @@
 #define ATD_MAXDEVICES 10
 
 extern atd_cfg_wifi_t  wifi_cfg;
-
-/** 
- * @brief 
- * 
+extern a_uint32_t rom_mode;
+/**
+ * @brief
+ *
  * @param hif_handle
- * 
- * @return 
+ *
+ * @return
  */
-static hif_status_t  
+static hif_status_t
 atd_device_detect    (hif_handle_t hif_handle);
 
-/** 
- * @brief 
- * 
+/**
+ * @brief
+ *
  * @param ctx
- * 
- * @return 
+ *
+ * @return
  */
-static hif_status_t  
+static hif_status_t
 atd_device_disconnect    (void *ctx );
 
-/** 
- * @brief 
- * 
+/**
+ * @brief
+ *
  * @param dsc
- * 
- * @return 
+ *
+ * @return
  */
-static a_status_t    
+static a_status_t
 atd_connect_services (atd_host_dev_t * dsc );
 
-/** 
- * @brief 
- * 
+/**
+ * @brief
+ *
  * @param dsc
- * 
- * @return 
+ *
+ * @return
  */
-static void          
+static void
 atd_device_cleanup   (atd_host_dev_t * dsc);
 
-/** 
- * @brief 
- * 
+/**
+ * @brief
+ *
  * @param dsc
  * @param resp
- * 
- * @return 
+ *
+ * @return
  */
-static a_uint32_t  
+static a_uint32_t
 atd_query_num_radio    (atd_host_dev_t *dsc, atd_radio_query_resp_t * resp);
 
-/** 
- * @brief 
- * @return 
+/**
+ * @brief
+ * @return
  */
-static hif_status_t 
+static hif_status_t
 atd_target_bootinit(void);
 
-/** 
- * @brief 
- * 
+/**
+ * @brief
+ *
  * @param dsc
- * 
- * @return 
+ *
+ * @return
  */
-static a_status_t  
+static a_status_t
 atd_configure_target   (atd_host_dev_t *dsc);
 
-/** 
+/**
  * @brief Cleanup the wifi
- * 
+ *
  * @param dsc
  * @param wifi_index
  */
-static void       
+static void
 atd_wifi_cleanup(atd_host_dev_t  *dsc, a_uint8_t  wifi_index);
 
-/** 
- * @brief 
- * 
+/**
+ * @brief
+ *
  * @param dsc
  * @param resp
- * 
- * @return 
+ *
+ * @return
  */
-static a_status_t 
+static a_status_t
 atd_setup_wifi(atd_host_dev_t *dsc, atd_radio_query_resp_t * resp);
 
-/** 
- * @brief 
- * 
+/**
+ * @brief
+ *
  * @param vap
  * @param nbuf
- * 
- * @return 
+ *
+ * @return
  */
-static adf_os_inline a_status_t 
+static adf_os_inline a_status_t
 atd_send_prepare(struct atd_host_vap *vap, adf_nbuf_t nbuf);
 
-/** 
- * @brief 
- * 
+/**
+ * @brief
+ *
  * @param ctx
- * 
- * @return 
+ *
+ * @return
  */
-static a_status_t  
+static a_status_t
 ath_device_htcready(void *ctx );
 
-/** 
- * @brief 
- * 
+/**
+ * @brief
+ *
  * @param ctx
  */
-static void   
+static void
 ath_device_htcready_worker(void *ctx );
 
 
-/** 
- * @brief 
- * 
+/**
+ * @brief
+ *
  * @param ctx
  * @param cbargs
- * 
- * @return 
+ *
+ * @return
  */
-static a_status_t 
+static a_status_t
 atd_wps_cb(void *ctx, adf_wps_cb_args_t *cbargs) ;
 
 
-/** 
- * @brief 
- * 
+/**
+ * @brief
+ *
  * @param ctx
  */
-static void 
+static void
 pbc_worker(void *ctx) ;
 
-/** 
+/**
  * @brief send device state change event to the ACFG clients
- * 
+ *
  * @param nethandle  - nethandle of the device to be informed
  * @param prev_state - previous state of the device
  * @param new_state  - new state of the device
@@ -176,14 +176,14 @@ atd_event_device_state_change(adf_net_handle_t nethandle,
                                 acfg_device_state_t new_state);
 
 
-/** 
+/**
  * @brief  Put the target ln power down mode
- * 
+ *
  * @param dsc
- * 
- * @return 
+ *
+ * @return
  */
-static a_status_t 
+static a_status_t
 atd_pwrdown_device(atd_host_dev_t *dsc);
 
 #ifdef ATD_DEBUG_ENABLE
@@ -193,7 +193,7 @@ int atd_dbg_mask ;
 atd_host_dev_t * atd_devices[ATD_MAXDEVICES];
 
 
-/* 
+/*
  * Module configurable  parameter
  */
 
@@ -201,7 +201,7 @@ a_uint32_t atd_target_devtype = WASP_TARGET;
 a_uint32_t atd_tgt_pwrdown_support = 0;
 
 
-static hif_status_t  
+static hif_status_t
 atd_device_detect( hif_handle_t hif_handle)
 {
     atd_host_dev_t        *dsc;
@@ -219,9 +219,9 @@ atd_device_detect( hif_handle_t hif_handle)
     }
     adf_os_mem_zero(dsc, sizeof(struct atd_host_dev));
 
-    for (dev_index = 0; dev_index < ATD_MAXDEVICES; dev_index++) 
+    for (dev_index = 0; dev_index < ATD_MAXDEVICES; dev_index++)
         if (!atd_devices[dev_index]) break;
-    
+
 
     if (dev_index == ATD_MAXDEVICES) {
         atd_trace(ATD_DEBUG_FUNCTRACE,\
@@ -245,7 +245,7 @@ atd_device_detect( hif_handle_t hif_handle)
                                     adf_os_function,atd_target_devtype));
 
     hif_claim_device(hif_handle, dsc);
-    dsc->hif_handle = hif_handle; 
+    dsc->hif_handle = hif_handle;
 
     if ((status = atd_configure_target(dsc)) != A_STATUS_OK) {
         adf_os_print("Target Configuration failed \n");
@@ -285,10 +285,10 @@ ath_device_htcready(void *ctx ){
 		return A_STATUS_OK;
     }
 
-    adf_os_create_work(NULL, &dsc->htcrdy_work, ath_device_htcready_worker, 
+    adf_os_create_work(NULL, &dsc->htcrdy_work, ath_device_htcready_worker,
                      (void  *)dsc);
 
-    adf_os_create_work(NULL, &dsc->pbc_work, pbc_worker, 
+    adf_os_create_work(NULL, &dsc->pbc_work, pbc_worker,
                      (void  *)dsc);
 
     atd_trace(ATD_DEBUG_LEVEL0,(" scheduling work "));
@@ -333,13 +333,13 @@ static void atd_band_steering_netlink_receive(struct sk_buff *__skb)
         nlh = (struct nlmsghdr *)skb->data;
         data = NLMSG_DATA(nlh);
         atd_bsteer_pid = nlh->nlmsg_pid;
-        printk("Band steering events being sent to PID:%d\n", 
+        printk("Band steering events being sent to PID:%d\n",
                 atd_bsteer_pid);
         kfree_skb(skb);
     }
 }
 
-static void 
+static void
 ath_device_htcready_worker(void *ctx)
 {
 
@@ -388,16 +388,16 @@ ath_device_htcready_worker(void *ctx)
                 radiorsp.num_radio));
 
     /*
-     * populate deffault device mac addr 
-     * register the wifi0 as per the num of radio 
-     */ 
+     * populate deffault device mac addr
+     * register the wifi0 as per the num of radio
+     */
     status = atd_setup_wifi(dsc, &radiorsp);
 
     if(status != A_STATUS_OK)
         goto fail;
 
-    /* Register WPS PBC callback for radios handled by offload stack. 
-     * We register this only for one radio as the WPS PBC button is 
+    /* Register WPS PBC callback for radios handled by offload stack.
+     * We register this only for one radio as the WPS PBC button is
      * not radio specific and is common for all vaps on all radios.
      */
     if (!dsc->pbc_cb_radio)
@@ -507,7 +507,7 @@ atd_device_disconnect(void *ctx)
 }
 
 
-a_status_t 
+a_status_t
 atd_connect_services(atd_host_dev_t * dsc )
 {
     a_status_t status =A_STATUS_OK;
@@ -540,7 +540,7 @@ atd_connect_services(atd_host_dev_t * dsc )
     creq.cb.ep_txcomp   = NULL;
     creq.cb.ep_rx       = atd_host_rx;
     creq.svcid          = WMI_DATA_BE_SVC;
-    
+
     atd_trace(ATD_DEBUG_FUNCTRACE, ("Start connect service \n"));
 
     status = htc_connect_service(htc_handle, &creq, &cresp);
@@ -553,14 +553,14 @@ atd_connect_services(atd_host_dev_t * dsc )
         return status ;
     }
 
-    atd_trace(ATD_DEBUG_LEVEL3,("data_ep  %d \n",dsc->data_ep)); 
+    atd_trace(ATD_DEBUG_LEVEL3,("data_ep  %d \n",dsc->data_ep));
 
     atd_trace(ATD_DEBUG_FUNCTRACE,(" End "));
     return status;
 }
 
 
-static void 
+static void
 atd_device_cleanup(atd_host_dev_t * dsc)
 {
     a_uint32_t i = 0;
@@ -570,7 +570,7 @@ atd_device_cleanup(atd_host_dev_t * dsc)
     /* intimate target down event */
     atd_event_device_state_change(NULL, ACFG_DEVICE_STATE_READY, ACFG_DEVICE_STATE_RESET);
 
-    /** 
+    /**
      * Power down the device if it is supported
      */
     if(atd_tgt_pwrdown_support)
@@ -610,7 +610,7 @@ atd_device_cleanup(atd_host_dev_t * dsc)
 
     atd_trace(ATD_DEBUG_CFG,("Cleaning interfaces"));
 
-    for(i = 0; i < MAX_NUM_RADIO; i++) 
+    for(i = 0; i < MAX_NUM_RADIO; i++)
         atd_wifi_cleanup(dsc, i);
 
     atd_trace(ATD_DEBUG_CFG,("Cleaning Handles & Events"));
@@ -618,12 +618,12 @@ atd_device_cleanup(atd_host_dev_t * dsc)
     adf_os_destroy_work(NULL, &dsc->htcrdy_work);
 
     adf_os_destroy_work(NULL, &dsc->pbc_work);
-    
+
     atd_mutex_unlock(dsc);
 
     /* Checkpoint after this there is nobody out there  */
     atd_flush_ref(dsc);
-    
+
     atd_trace(ATD_DEBUG_CFG,("Flush Done"));
 
     adf_os_spinlock_destroy(&dsc->spin_lock);
@@ -634,7 +634,7 @@ atd_device_cleanup(atd_host_dev_t * dsc)
 }
 
 
-a_uint32_t 
+a_uint32_t
 atd_query_num_radio(atd_host_dev_t *dsc,
                     atd_radio_query_resp_t * resp)
 {
@@ -642,7 +642,7 @@ atd_query_num_radio(atd_host_dev_t *dsc,
     a_uint8_t *data;
     a_uint32_t i;
     adf_nbuf_t nbuf;
-    
+
     atd_trace(ATD_DEBUG_FUNCTRACE,(" x "));
 
     if ((nbuf = _atd_wmi_msg_alloc(dsc->wmi_handle)) == NULL) {
@@ -666,10 +666,10 @@ atd_query_num_radio(atd_host_dev_t *dsc,
         adf_os_print("wifi mac address name %d %s  :%x:%x:%x:%x:%x:%x \n",
                       i,
                       &resp->ifname[i][0],
-                      resp->mac_addr[i][0], 
-                      resp->mac_addr[i][1], 
-                      resp->mac_addr[i][2], 
-                      resp->mac_addr[i][3], 
+                      resp->mac_addr[i][0],
+                      resp->mac_addr[i][1],
+                      resp->mac_addr[i][2],
+                      resp->mac_addr[i][3],
                       resp->mac_addr[i][4],
                       resp->mac_addr[i][5]);
     }
@@ -677,14 +677,14 @@ out:
     return status ;
 }
 
-a_uint32_t 
+a_uint32_t
 atd_pwrdown_device(atd_host_dev_t *dsc)
-                    
+
 {
     a_status_t status = A_STATUS_OK;
     a_uint8_t *data;
     adf_nbuf_t nbuf;
-    
+
     atd_trace(ATD_DEBUG_FUNCTRACE,(" x "));
 
     if ((nbuf = _atd_wmi_msg_alloc(dsc->wmi_handle)) == NULL) {
@@ -709,8 +709,8 @@ out:
 }
 
 
-a_status_t  
-atd_setup_wifi(atd_host_dev_t * dsc, 
+a_status_t
+atd_setup_wifi(atd_host_dev_t * dsc,
         atd_radio_query_resp_t * radiorsp)
 {
     a_status_t status = A_STATUS_OK;
@@ -722,7 +722,7 @@ atd_setup_wifi(atd_host_dev_t * dsc,
 
         adf_dev_sw_t dev_switch={0};
         adf_net_dev_info_t info = {{0}};
-        dsc->wifi_list[i] = adf_os_mem_alloc(NULL, sizeof(struct atd_host_wifi)); 
+        dsc->wifi_list[i] = adf_os_mem_alloc(NULL, sizeof(struct atd_host_wifi));
         if(dsc->wifi_list[i] == NULL){
             adf_os_print("Error in allocationg wifi");
             return A_STATUS_FAILED;
@@ -736,23 +736,23 @@ atd_setup_wifi(atd_host_dev_t * dsc,
         dev_switch.drv_tx               = atd_wifi_tx   ;
         dev_switch.drv_cmd              = atd_wifi_cmd  ;
         dev_switch.drv_ioctl            = atd_wifi_ioctl;
-        dev_switch.drv_tx_timeout       = atd_wifi_tx_timeout ;  
-        
+        dev_switch.drv_tx_timeout       = atd_wifi_tx_timeout ;
+
         atd_trace(ATD_DEBUG_FUNCTRACE, ("Creating netdev ..... %d %s \n", \
                                                 i, &radiorsp->ifname[i][0]));
-        adf_os_str_ncopy(info.if_name,&radiorsp->ifname[i][0], 
+        adf_os_str_ncopy(info.if_name,&radiorsp->ifname[i][0],
                          adf_os_str_len(&radiorsp->ifname[i][0]));
 
-        adf_os_mem_copy(info.dev_addr, &radiorsp->mac_addr[i], 
+        adf_os_mem_copy(info.dev_addr, &radiorsp->mac_addr[i],
                         ACFG_MACADDR_LEN);
 
-        info.header_len = sizeof(atd_tx_hdr_t) + 
+        info.header_len = sizeof(atd_tx_hdr_t) +
                           htc_get_reserveheadroom(dsc->htc_handle);
 
 
-        dsc->wifi_list[i]->netdev = adf_net_create_wifidev(dsc->wifi_list[i], 
-                                                           &dev_switch, 
-                                                           &info, 
+        dsc->wifi_list[i]->netdev = adf_net_create_wifidev(dsc->wifi_list[i],
+                                                           &dev_switch,
+                                                           &info,
                                                            &wifi_cfg);
 
     }
@@ -760,13 +760,13 @@ atd_setup_wifi(atd_host_dev_t * dsc,
 
 }
 
-/** 
- * @brief This function will cleanup the VAP 
- * 
+/**
+ * @brief This function will cleanup the VAP
+ *
  * @param wifi
  * @param vap_index
- * 
- * @return 
+ *
+ * @return
  */
 void
 atd_vap_cleanup(atd_host_wifi_t     *wifi, a_uint8_t    vap_index)
@@ -779,7 +779,7 @@ atd_vap_cleanup(atd_host_wifi_t     *wifi, a_uint8_t    vap_index)
 
     if (!vap) goto bail;
 
-    atd_trace(ATD_DEBUG_CFG, ("Deleted net dev %s \n", 
+    atd_trace(ATD_DEBUG_CFG, ("Deleted net dev %s \n",
                 adf_net_ifname(vap->nethandle)));
 
     adf_os_assert(vap->nethandle);
@@ -798,7 +798,7 @@ bail:
 }
 
 
-void 
+void
 atd_wifi_cleanup(atd_host_dev_t     *dsc, a_uint8_t   wifi_index)
 {
     atd_host_wifi_t    *wifi = NULL;
@@ -813,12 +813,12 @@ atd_wifi_cleanup(atd_host_dev_t     *dsc, a_uint8_t   wifi_index)
     wifi = dsc->wifi_list[wifi_index];
 
     dsc->wifi_list[wifi_index] = NULL;
-   
+
     atd_spin_unlock_bh(dsc);            /* Unlock */
-    
+
     if (!wifi)  goto bail;
 
-    for (i = 0; i < MAX_VAP_SUPPORTED; i++) 
+    for (i = 0; i < MAX_VAP_SUPPORTED; i++)
         atd_vap_cleanup(wifi, i);
 
     adf_os_assert(wifi->netdev);
@@ -844,7 +844,7 @@ a_status_t atd_wifi_open(adf_drv_handle_t hdl)
     return status;
 }
 
-void  
+void
 atd_wifi_close(adf_drv_handle_t hdl)
 {
     atd_trace(ATD_DEBUG_FUNCTRACE,("Start"));
@@ -852,7 +852,7 @@ atd_wifi_close(adf_drv_handle_t hdl)
     atd_trace(ATD_DEBUG_FUNCTRACE,("End"));
 }
 
-a_status_t 
+a_status_t
 atd_wifi_tx_timeout(adf_drv_handle_t hdl)
 {
 
@@ -861,12 +861,12 @@ atd_wifi_tx_timeout(adf_drv_handle_t hdl)
     atd_trace(ATD_DEBUG_FUNCTRACE,("Start"));
     atd_trace(ATD_DEBUG_ERROR,("Not expected"));
     atd_trace(ATD_DEBUG_FUNCTRACE,("End"));
- 
+
     return status;
 
 }
-a_status_t 
-atd_wifi_cmd(adf_drv_handle_t  drv_hdl, adf_net_cmd_t cmd, 
+a_status_t
+atd_wifi_cmd(adf_drv_handle_t  drv_hdl, adf_net_cmd_t cmd,
              adf_net_cmd_data_t  *data)
 {
     a_status_t status = A_STATUS_OK ;
@@ -874,11 +874,11 @@ atd_wifi_cmd(adf_drv_handle_t  drv_hdl, adf_net_cmd_t cmd,
     atd_trace(ATD_DEBUG_FUNCTRACE,("Start"));
     atd_trace(ATD_DEBUG_ERROR,("Not expected"));
     atd_trace(ATD_DEBUG_FUNCTRACE,("End"));
- 
+
     return status;
 }
 
-a_status_t 
+a_status_t
 atd_wifi_ioctl(adf_drv_handle_t hdl, a_int32_t num, void *data)
 {
 
@@ -886,16 +886,16 @@ atd_wifi_ioctl(adf_drv_handle_t hdl, a_int32_t num, void *data)
     atd_trace(ATD_DEBUG_FUNCTRACE,("Start"));
     atd_trace(ATD_DEBUG_ERROR,("Not expected"));
     atd_trace(ATD_DEBUG_FUNCTRACE,("End"));
- 
+
     return status;
 
 
 }
 
 /*
- * Vap configuration 
- */ 
-a_status_t 
+ * Vap configuration
+ */
+a_status_t
 atd_vap_ioctl(adf_drv_handle_t hdl, a_int32_t num, void *data)
 {
 
@@ -903,12 +903,12 @@ atd_vap_ioctl(adf_drv_handle_t hdl, a_int32_t num, void *data)
     atd_trace(ATD_DEBUG_FUNCTRACE,("Start"));
     atd_trace(ATD_DEBUG_ERROR,("Not expected"));
     atd_trace(ATD_DEBUG_FUNCTRACE,("End"));
- 
+
     return status;
 
 
 }
-a_status_t 
+a_status_t
 atd_vap_tx_timeout(adf_drv_handle_t hdl)
 {
 
@@ -927,7 +927,7 @@ atd_vap_open(adf_drv_handle_t hdl)
     struct atd_host_vap * vap = (struct atd_host_vap *)hdl;
     adf_net_handle_t nethandle = vap->nethandle;
     atd_host_wifi_t * wifi = vap->wifisc;
-    atd_vap_open_cmd_t * cmd;  
+    atd_vap_open_cmd_t * cmd;
     wmi_handle_t   wmi_handle =  __wifi2wmi(wifi);
     adf_nbuf_t nbuf = NULL;
 
@@ -940,7 +940,7 @@ atd_vap_open(adf_drv_handle_t hdl)
         adf_os_print("Unable to allocate wmi buffer \n");
         goto out ;
     }
-    
+
     cmd = (atd_vap_open_cmd_t *) adf_nbuf_put_tail(nbuf,
                                         sizeof(atd_vap_open_cmd_t));
     cmd->wifi_index = wifi->wifi_index ;
@@ -955,7 +955,7 @@ atd_vap_open(adf_drv_handle_t hdl)
 
     adf_net_start_queue(nethandle);
 
-out :    
+out :
 
     atd_trace(ATD_DEBUG_FUNCTRACE,("End ..."));
     return status;
@@ -969,7 +969,7 @@ atd_vap_close(adf_drv_handle_t hdl)
     struct atd_host_vap * vap = (struct atd_host_vap *)hdl;
     adf_net_handle_t nethandle = vap->nethandle;
     atd_host_wifi_t * wifi = vap->wifisc;
-    atd_vap_close_cmd_t * cmd;  
+    atd_vap_close_cmd_t * cmd;
     wmi_handle_t   wmi_handle =  __wifi2wmi(wifi);
     adf_nbuf_t nbuf = NULL;
 
@@ -983,7 +983,7 @@ atd_vap_close(adf_drv_handle_t hdl)
         adf_os_print("Unable to allocate wmi buffer \n");
         goto out ;
     }
-    
+
     cmd = (atd_vap_open_cmd_t *) adf_nbuf_put_tail(nbuf,
                                         sizeof(atd_vap_close_cmd_t));
     cmd->wifi_index = wifi->wifi_index ;
@@ -1008,7 +1008,7 @@ out:
 a_status_t
 atd_vap_cmd(adf_drv_handle_t  drv_hdl, adf_net_cmd_t cmd,
             adf_net_cmd_data_t  *data)
-{   
+{
     a_status_t  error = A_STATUS_OK;
 
     atd_trace(ATD_DEBUG_FUNCTRACE,(" x "));
@@ -1101,7 +1101,7 @@ atd_host_tx(adf_drv_handle_t hdl, adf_nbuf_t nbuf)
     {
         /*adf_nbuf_peek_header(nbuf, (a_uint8_t **)&eh, &len);*/
 
-        /* For this require sta association event should come from target . 
+        /* For this require sta association event should come from target .
            an  = ieee80211_find_txnode(vap, eh->ether_dhost);
 
            if(an == NULL);
@@ -1140,7 +1140,7 @@ out :
         if( nbuf != ADF_NBUF_NULL )
             adf_nbuf_free(nbuf);
 
-    } 
+    }
 
     atd_trace(ATD_DEBUG_FUNCTRACE,(" Start "));
     return 0;
@@ -1151,7 +1151,7 @@ out :
  */
 
 
-a_status_t 
+a_status_t
 atd_wifi_tx(adf_drv_handle_t hdl, adf_nbuf_t nbuf)
 {
 
@@ -1163,7 +1163,7 @@ atd_wifi_tx(adf_drv_handle_t hdl, adf_nbuf_t nbuf)
     adf_nbuf_free(nbuf);
 
     atd_trace(ATD_DEBUG_FUNCTRACE,("end"));
- 
+
     return status;
 
 }
@@ -1191,7 +1191,7 @@ atd_send_prepare(struct atd_host_vap *vap, adf_nbuf_t nbuf)
         }
 
     }
-    dh = (atd_tx_hdr_t*)adf_nbuf_push_head(nbuf, 
+    dh = (atd_tx_hdr_t*)adf_nbuf_push_head(nbuf,
                                             sizeof(atd_tx_hdr_t));
     dh->vap_index   = vap->vap_index ;
     dh->wifi_index = wifi->wifi_index;
@@ -1201,7 +1201,7 @@ atd_send_prepare(struct atd_host_vap *vap, adf_nbuf_t nbuf)
 /*Recieve Path */
 
 #define atd_host_find_vap(_wifi,_vapindex) _wifi->vap_list[_vapindex]
-void   
+void
 atd_host_rx(void *instance, adf_nbuf_t nbuf, htc_endpointid_t ep )
 {
 
@@ -1213,7 +1213,7 @@ atd_host_rx(void *instance, adf_nbuf_t nbuf, htc_endpointid_t ep )
     atd_host_dev_t *adsc = (atd_host_dev_t *) instance;
 
     atd_trace(ATD_DEBUG_FUNCTRACE,(" x "));
-    
+
     adf_nbuf_peek_header(nbuf, &anbdata, &anblen);
     rxhdr = (atd_rx_hdr_t *)anbdata;
 
@@ -1222,7 +1222,7 @@ atd_host_rx(void *instance, adf_nbuf_t nbuf, htc_endpointid_t ep )
         adf_nbuf_free(nbuf);
         return;
     }
-   
+
     /* Protect the entire Receive path  */
 
     atd_spin_lock(adsc);  /* Lock */
@@ -1238,7 +1238,7 @@ atd_host_rx(void *instance, adf_nbuf_t nbuf, htc_endpointid_t ep )
         adf_nbuf_free(nbuf);
         return;
     }
-    
+
     vap = atd_host_find_vap(wifi, rxhdr->vap_index);
     if (vap == NULL ) {
         adf_os_print("Vap not found radio index %d vap index %d \n",
@@ -1261,12 +1261,14 @@ atd_host_rx(void *instance, adf_nbuf_t nbuf, htc_endpointid_t ep )
 static hif_status_t
 atd_target_bootinit(void)
 {
-  
-    a_status_t status;
+
+    a_status_t status = A_STATUS_OK;
 
     atd_trace(ATD_DEBUG_FUNCTRACE,("start"));
 
-    status = fwd_bootfirmware_download();
+    if(rom_mode) {
+        status = fwd_bootfirmware_download();
+    }
 
     atd_trace(ATD_DEBUG_FUNCTRACE,("end"));
 
@@ -1274,14 +1276,16 @@ atd_target_bootinit(void)
 
 }
 
-static a_status_t  
+static a_status_t
 atd_configure_target(atd_host_dev_t *dsc)
 {
-    a_status_t status;
+    a_status_t status = A_STATUS_OK;
 
     atd_trace(ATD_DEBUG_FUNCTRACE,("start"));
 
-    status = fwd_firmware_download(dsc->hif_handle);
+    if(rom_mode) {
+        status = fwd_firmware_download(dsc->hif_handle);
+    }
 
     atd_trace(ATD_DEBUG_FUNCTRACE,("end"));
 
@@ -1289,17 +1293,17 @@ atd_configure_target(atd_host_dev_t *dsc)
 }
 
 
-/** 
+/**
  * @brief Worker for handling WPS PBC events
- * 
+ *
  * @param ctx
  */
-static void 
+static void
 pbc_worker(void *ctx)
 {
     int ret ;
     atd_host_dev_t * dsc = (atd_host_dev_t *)ctx;
-    a_uint32_t num_vaps, 
+    a_uint32_t num_vaps,
                radio_count,
                vap_count,
                temp,
@@ -1312,13 +1316,13 @@ pbc_worker(void *ctx)
     const char *ws_msgprefix = "PBC_" ;
     char *ws_helperapp = "/sbin/wsupp_helper" ;
 
-    char *envp[] = { 
+    char *envp[] = {
                     "HOME=/root",
-                    "PATH=/bin:/sbin:/usr/sbin:/usr/bin", 
+                    "PATH=/bin:/sbin:/usr/sbin:/usr/bin",
                     NULL} ;
     char **argv ;
 	static char *tag = "PUSH-BUTTON.indication";
-   
+
     prefix_len = adf_os_str_len((const char *)ws_msgprefix) ;
 
     /* count the number of vaps */
@@ -1332,9 +1336,9 @@ pbc_worker(void *ctx)
             {
                 vap_list = wifi_list->vap_list[vap_count] ;
                 if(vap_list) {
-					adf_send_custom_wireless_event(vap_list->nethandle, tag);	
+                    adf_send_custom_wireless_event(vap_list->nethandle, tag);
                     num_vaps++;
-				}
+                }
             }
         }
     }// end for
@@ -1345,13 +1349,13 @@ pbc_worker(void *ctx)
     adf_os_mem_set(argv, 0 , temp );
 
     /* Populate argument vector.
-     * Allocate memory for each element 
+     * Allocate memory for each element
      * and place '<msgprefix> <vap name>' in the vector.
      */
     argv[0] = ws_helperapp ;    /* First arg is app name itself */
     argv[num_vaps+1] = NULL ;   /* NULL terminated arg list */
-    temp = 1 ;                  /* Set temp to index of first 
-                                 * arg after appname  
+    temp = 1 ;                  /* Set temp to index of first
+                                 * arg after appname
                                  */
     for(radio_count = 0 ; radio_count < MAX_NUM_RADIO; radio_count++)
     {
@@ -1368,17 +1372,17 @@ pbc_worker(void *ctx)
 
                     nethdl = vap_list->nethandle ;
                     vapname = hdl_to_netdev(nethdl)->name ;
-                    msgsize = prefix_len 
+                    msgsize = prefix_len
                                 + adf_os_str_len((const char *)vapname);
-                    
+
                     argv[temp] = (char *)adf_os_mem_alloc(NULL, msgsize);
 
                     /* copy prefix and vapname to arg vactor */
-                    adf_os_mem_copy(argv[temp] , (const void *)ws_msgprefix, 
+                    adf_os_mem_copy(argv[temp] , (const void *)ws_msgprefix,
                                                                 prefix_len);
 
-                    adf_os_mem_copy(argv[temp]+prefix_len, 
-                                    (const void *)vapname, 
+                    adf_os_mem_copy(argv[temp]+prefix_len,
+                                    (const void *)vapname,
                                     adf_os_str_len((const char *)vapname) );
 
                     temp++;
@@ -1392,12 +1396,12 @@ pbc_worker(void *ctx)
     {
         /* execute wsupp helper */
         ret = call_usermodehelper(ws_helperapp, argv, envp, UMH_WAIT_EXEC) ;
-		
+
         if(ret != 0)
         {
             adf_os_print("Error creating wsupp helper process \n");
         }
-		
+
     }
 
     /* Free argument vector */
@@ -1414,18 +1418,18 @@ pbc_worker(void *ctx)
     }
 
     adf_os_mem_free(argv);
-    
+
     return ;
 }
 
 
-/** 
-  * @brief Called in interrupt context. 
+/**
+  * @brief Called in interrupt context.
   *        Executes wsupp helper.
-  *        
-  * @param ctx[in] 
-  * 
-  * @return 
+  *
+  * @param ctx[in]
+  *
+  * @return
   */
 static a_status_t
 atd_wps_cb(void *ctx, adf_wps_cb_args_t *cbargs)
@@ -1445,20 +1449,20 @@ atd_wps_cb(void *ctx, adf_wps_cb_args_t *cbargs)
     }
 
     adf_os_sched_work(NULL, &dsc->pbc_work);
-    
+
     return A_STATUS_OK ;
 }
 
-/** 
+/**
  * @brief send device state change event to the ACFG clients
- * 
+ *
  * @param nethandle  - nethandle of the device to be informed
  * @param prev_state - previous state of the device
  * @param new_state  - new state of the device
  */
 void
 atd_event_device_state_change(adf_net_handle_t nethandle,
-                                acfg_device_state_t prev_state, 
+                                acfg_device_state_t prev_state,
                                 acfg_device_state_t new_state)
 {
     acfg_os_event_t     event   = {.id = ACFG_EV_DEVICE_STATE_CHANGE};
diff --git a/host/thin_driver/atd/atd_internal.h b/host/thin_driver/atd/atd_internal.h
index 99f39a2..219097d 100644
--- a/host/thin_driver/atd/atd_internal.h
+++ b/host/thin_driver/atd/atd_internal.h
@@ -18,6 +18,18 @@
 #define __ATD_INTERNAL_H
 
 #include <adf_os_types.h>
+
+#ifndef _BYTE_ORDER
+#define _BYTE_ORDER BIG_ENDIAN
+#endif
+
+#ifndef __packed
+#define __packed    __attribute__((__packed__))
+#endif
+
+#include <ieee80211_external_config.h>
+#define EXTERNAL_USE_ONLY
+
 #include <adf_os_pci.h>
 #include <adf_os_dma.h>
 #include <adf_os_timer.h>
@@ -31,7 +43,6 @@
 #include <adf_net_types.h>
 #include <adf_nbuf.h>
 #include <adf_net.h>
-#include <adf_os_netlink.h>
 
 #include <htc.h>
 #include <wmi.h>
@@ -44,6 +55,7 @@
 #include <atd_cmd.h>
 #include <atd_event.h>
 #include <atd_wsupp.h>
+#include <adf_os_netlink.h>
 #include <atd_appbr.h>
 #include <atd_byp.h>
 
@@ -67,7 +79,7 @@ typedef struct atd_host_dev {
     htc_endpointid_t        wmi_cmd_ep; /**< WMI Command Endpoint ID */
     htc_endpointid_t        data_ep;    /**< Data Endpoint ID */
     htc_endpointid_t        wsupp_ep;   /**< WSUPP Helper Endpoint ID */
-    
+
     adf_os_spinlock_t       spin_lock;  /**< Big Spinlock */
     adf_os_mutex_t          mutex;      /**< Big Mutex */
     adf_os_atomic_t         ref_cnt;    /**< Device reference count */
@@ -110,8 +122,9 @@ typedef struct atd_host_vap {
     a_uint8_t               vap_opmode;
 
     a_bool_t                lan_en; /** VAP can access LAN */
-                                    /** WAN- LAN , WAN - VAP bridges 
+                                    /** WAN- LAN , WAN - VAP bridges
                                      * are not supported */
+    a_uint32_t              sys_index;
 }atd_host_vap_t;
 
 
@@ -135,11 +148,11 @@ a_status_t  atd_host_tx    (adf_drv_handle_t acore, adf_nbuf_t netbuf );
 void        atd_host_rx    (void *, adf_nbuf_t , htc_endpointid_t);
 
 
-a_status_t atd_cfg_create_vap(adf_drv_handle_t      hdl, 
-                              a_uint8_t             icp_name[ACFG_MAX_IFNAME], 
+a_status_t atd_cfg_create_vap(adf_drv_handle_t      hdl,
+                              a_uint8_t             icp_name[ACFG_MAX_IFNAME],
                               acfg_opmode_t         icp_opmode,
                               a_int32_t             icp_vapid,
-                              acfg_vapinfo_flags_t  icp_vapflags);
+                              a_uint32_t            icp_vapflags);
 
 
 a_status_t fwd_firmware_download(hif_handle_t hif);
@@ -149,9 +162,9 @@ a_status_t fwd_bootfirmware_download(void);
 
 
 
-/** 
+/**
  * @brief Dev Spin lock
- * 
+ *
  * @param dev_sc
  */
 static inline void
@@ -160,9 +173,9 @@ atd_spin_lock(atd_host_dev_t  *dev_sc)
     adf_os_spin_lock(&dev_sc->spin_lock);
 }
 
-/** 
+/**
  * @brief Dev Spin unlock
- * 
+ *
  * @param dev_sc
  */
 static inline void
@@ -170,9 +183,9 @@ atd_spin_unlock(atd_host_dev_t  *dev_sc)
 {
     adf_os_spin_unlock(&dev_sc->spin_lock);
 }
-/** 
+/**
  * @brief Dev Spin lock
- * 
+ *
  * @param dev_sc
  */
 static inline void
@@ -181,9 +194,9 @@ atd_spin_lock_bh(atd_host_dev_t  *dev_sc)
     adf_os_spin_lock_bh(&dev_sc->spin_lock);
 }
 
-/** 
+/**
  * @brief Dev Spin unlock
- * 
+ *
  * @param dev_sc
  */
 static inline void
@@ -193,9 +206,9 @@ atd_spin_unlock_bh(atd_host_dev_t  *dev_sc)
 }
 
 
-/** 
+/**
  * @brief Dev Mutex lock
- * 
+ *
  * @param dev_sc
  */
 static inline void
@@ -204,9 +217,9 @@ atd_mutex_lock(atd_host_dev_t  *dev_sc)
     adf_os_mutex_acquire(NULL, &dev_sc->mutex);
 }
 
-/** 
+/**
  * @brief Dev Mutex unlock
- * 
+ *
  * @param dev_sc
  */
 static inline void
@@ -215,10 +228,10 @@ atd_mutex_unlock(atd_host_dev_t  *dev_sc)
     adf_os_mutex_release(NULL, &dev_sc->mutex);
 }
 
-/** 
+/**
  * @brief Increment the device reference count & acquire the
  *        delete protection semaphore
- * 
+ *
  * @param dev_sc
  */
 static inline void
@@ -227,13 +240,13 @@ atd_init_ref(atd_host_dev_t      *dev_sc)
     adf_os_atomic_init(&dev_sc->ref_cnt);
     adf_os_atomic_inc(&dev_sc->ref_cnt);
 
-    adf_os_sem_init(&dev_sc->sem_del); 
+    adf_os_sem_init(&dev_sc->sem_del);
     adf_os_sem_acquire(NULL, &dev_sc->sem_del);
 }
 
-/** 
+/**
  * @brief wait for the reference to come down to zero
- * 
+ *
  * @param dev_sc
  */
 static inline void
@@ -241,11 +254,11 @@ atd_flush_ref(atd_host_dev_t    *dev_sc)
 {
     if (!adf_os_atomic_dec_and_test(&dev_sc->ref_cnt))
         adf_os_sem_acquire(NULL, &dev_sc->sem_del);
-    
+
 }
-/** 
+/**
  * @brief Increment the device reference count
- * 
+ *
  * @param dev_sc
  */
 static inline void
@@ -258,25 +271,25 @@ static inline void
 atd_dec_ref(atd_host_dev_t      *dev_sc)
 {
    if (adf_os_atomic_dec_and_test(&dev_sc->ref_cnt))
-      adf_os_sem_release(NULL, &dev_sc->sem_del); 
+      adf_os_sem_release(NULL, &dev_sc->sem_del);
 }
-/** 
+/**
  * @brief Post a new event in the event Queue
- * 
+ *
  * @param dev_sc
  * @param buf
- * 
+ *
  */
 void
 atd_event_run(atd_host_dev_t  *dev_sc, wmi_id_t  id, adf_nbuf_t     buf);
 
-/** 
+/**
  * @brief Free up a vap slot from wifi list array
- * 
+ *
  * @param wifi
  * @param vap_index
- * 
- * @return 
+ *
+ * @return
  */
 static inline atd_host_vap_t *
 atd_free_vap_index(atd_host_wifi_t    *wifi,  a_uint8_t   vap_index)
@@ -289,7 +302,7 @@ atd_free_vap_index(atd_host_wifi_t    *wifi,  a_uint8_t   vap_index)
     vap = wifi->vap_list[vap_index];
 
     /* Don't care for the vap_index */
-    wifi->vap_list[vap_index] = NULL;   
+    wifi->vap_list[vap_index] = NULL;
 
     atd_spin_unlock_bh(wifi->dsc);  /* Unlock */
 
diff --git a/host/thin_driver/wmi/wmi.c b/host/thin_driver/wmi/wmi.c
index ac998d5..ad512a4 100644
--- a/host/thin_driver/wmi/wmi.c
+++ b/host/thin_driver/wmi/wmi.c
@@ -14,6 +14,7 @@
  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
  */
 
+#include <atd_internal.h>
 #include <adf_os_types.h>
 #include <adf_os_pci.h>
 #include <adf_os_dma.h>
@@ -36,7 +37,6 @@
 
 #include <wmi.h>
 #include <wmi_api.h>
-#include <atd_internal.h>
 
 // Remove this debug after good amount of test
 #define WMI_RETRY_DBG
diff --git a/include/atd_cmd.h b/include/atd_cmd.h
index c792369..8061413 100644
--- a/include/atd_cmd.h
+++ b/include/atd_cmd.h
@@ -15,20 +15,35 @@
  */
 
 /*
- * @File: 
- * 
+ * @File:
+ *
  * @Abstract: ATD Data Structure for interfacing between Target and Host
  *
  */
 #ifndef __ATD_CMD_H
 #define __ATD_CMD_H
 
+#include <ieee80211_external_config.h>
 #include <acfg_api_types.h>
 #include <spectral_cmd.h>
+#include <if_athioctl.h>
+#include <a_types.h>
+#include <cdp_txrx_stats_struct.h>
+
+#define ACFG_TESTMODE_CHAN     0x1
+#define ACFG_TESTMODE_BSSID    0x2
+#define ACFG_TESTMODE_RX       0x3
+#define ACFG_TESTMODE_RESULT   0x4
+#define ACFG_TESTMODE_ANT      0x5
+
+#define ACFG_MAC_STR_LEN         17
+
+#define ACFG_MAX_ACL_NODE       64
+#define ACFG_CTRL_IFACE_LEN     30
 
 /*
- * Hostapd Ioctls sends max 10 bytes but receives 
- * big size data. How to know valid bytes in the 
+ * Hostapd Ioctls sends max 10 bytes but receives
+ * big size data. How to know valid bytes in the
  * buffer sent by Hostapd ??. To be optmized
  */
 #define VALID_PAYLOAD_SIZE 256
@@ -76,8 +91,6 @@ typedef acfg_vendor_param_req_t atd_vendor_param_t;
 
 typedef acfg_rssi_t atd_rssi_t;
 
-typedef acfg_custdata_t atd_custdata_t;
-
 /**
  * @brief Get/Set wireless commands
  */
@@ -87,12 +100,12 @@ typedef acfg_custdata_t atd_custdata_t;
 #define IOCTL_VIRDEV_MASK  (0x04000000)
 
 #define IEEE80211_IOCTL_TESTMODE            (IOCTL_VIRDEV_MASK | 1)       /* Test Mode for Factory */
-#define IEEE80211_IOCTL_STAINFO             (IOCTL_VIRDEV_MASK | 2)       /* Station Information */          
-#define IEEE80211_IOCTL_PHYMODE             (IOCTL_VIRDEV_MASK | 3)       /* PHY Mode */          
-#define IEEE80211_IOCTL_SCANTIME            (IOCTL_VIRDEV_MASK | 4)       /* Foreground Active Scan Time (T8) */          
-#define IEEE80211_IOCTL_SCAN                (IOCTL_VIRDEV_MASK | 5)       /* Foreground Active Scan */  
-#define IEEE80211_IOCTL_RSSI                (IOCTL_VIRDEV_MASK | 6)       /* Get RSSI */    
-#define IEEE80211_IOCTL_CUSTDATA            (IOCTL_VIRDEV_MASK | 7)       /* Get custdata */  
+#define IEEE80211_IOCTL_STAINFO             (IOCTL_VIRDEV_MASK | 2)       /* Station Information */
+#define IEEE80211_IOCTL_PHYMODE             (IOCTL_VIRDEV_MASK | 3)       /* PHY Mode */
+#define IEEE80211_IOCTL_SCANTIME            (IOCTL_VIRDEV_MASK | 4)       /* Foreground Active Scan Time (T8) */
+#define IEEE80211_IOCTL_SCAN                (IOCTL_VIRDEV_MASK | 5)       /* Foreground Active Scan */
+#define IEEE80211_IOCTL_RSSI                (IOCTL_VIRDEV_MASK | 6)       /* Get RSSI */
+#define IEEE80211_IOCTL_CUSTDATA            (IOCTL_VIRDEV_MASK | 7)       /* Get custdata */
 
 typedef struct {
       a_uint32_t vendor;
@@ -159,25 +172,19 @@ typedef struct atd_encode_rsp {
 } __attribute__((__packed__)) atd_encode_rsp_t ;
 
 typedef struct atd_powmgmt {
-    a_uint32_t val ;    
+    a_uint32_t val ;
     a_uint16_t flags ;
     a_uint8_t disabled ;
 } __attribute__((__packed__)) atd_powmgmt_t ;
 
-typedef struct atd_txpow {
-    a_uint32_t val ;
-    acfg_txpow_flags_t flags ;
-} __attribute__((__packed__)) atd_txpow_t ;
-
-typedef struct atd_rts {
-    a_uint32_t val ;
-    acfg_rts_flags_t flags ;
-} __attribute__((__packed__)) atd_rts_t ;
+typedef acfg_frag_t atd_frag_t;
+typedef acfg_rts_t atd_rts_t;
+typedef acfg_txpow_t atd_txpow_t;
 
-typedef struct atd_frag {
-    a_uint32_t val ;
-    acfg_frag_flags_t flags ;
-} __attribute__((__packed__)) atd_frag_t ;
+typedef struct atd_range {
+    a_uint8_t *buff ;
+    a_uint32_t len ;
+} atd_range_t ;
 
 typedef struct atd_range_buf {
     a_uint32_t           throughput;
@@ -239,22 +246,12 @@ typedef struct atd_range_buf {
 #endif
 } __attribute__((__packed__)) atd_range_buf_t;
 
-typedef struct atd_key {
-    a_uint8_t        type;
-    a_uint8_t        pad;
-    a_uint16_t       keyix;
-    a_uint8_t        keylen;
-    a_uint8_t        flags;
-    a_uint8_t        macaddr[ACFG_MACADDR_LEN];
-    a_uint64_t       keyrsc;
-    a_uint64_t       keytsc;
-    a_uint8_t        keydata[ACFG_KEYDATA_LEN];
-} __attribute__((__packed__)) atd_key_t;
+typedef struct ieee80211req_key atd_key_t;
 
 typedef struct atd_scan_result {
     a_uint16_t       isr_len;
     a_uint16_t       isr_freq;
-    a_uint32_t       isr_flags; 
+    a_uint32_t       isr_flags;
     a_uint8_t        isr_noise;
     a_uint8_t        isr_rssi;
     a_uint8_t        isr_intval;
@@ -267,16 +264,7 @@ typedef struct atd_scan_result {
     a_uint16_t       isr_ie_len;
 } __attribute__((__packed__)) atd_scan_result_t;
 
-typedef struct atd_mlme {
-    a_uint8_t        op;
-    a_uint8_t        ssid_len;
-    a_uint16_t       reason;
-    a_uint16_t       seq;
-    a_uint8_t        macaddr[ACFG_MACADDR_LEN];
-    a_uint8_t        ssid[ACFG_MAX_SSID_LEN];
-    a_uint8_t        optie[ACFG_MAX_IELEN * 2];
-    a_uint16_t       optie_len;
-} __attribute__((__packed__)) atd_mlme_t;
+typedef struct ieee80211req_mlme atd_mlme_t;
 
 typedef struct atd_channel {
     a_uint16_t   freq;
@@ -300,11 +288,14 @@ typedef struct atd_chan_info {
 
 typedef acfg_filter_t atd_filter_t;
 
+#if 0
 typedef struct atd_appie {
     a_uint32_t       frmtype;
     a_uint32_t       buflen;
     a_uint8_t        buf[0];
 } __attribute__((__packed__)) atd_appie_t;
+#endif
+typedef struct ieee80211req_getset_appiebuf atd_appie_t;
 
 typedef struct atd_mgmt {
     a_uint8_t        macaddr[ACFG_MACADDR_LEN];
@@ -315,8 +306,8 @@ typedef struct atd_mgmt {
 typedef acfg_delkey_t atd_delkey_t;
 
 typedef struct atd_nawds_cfg {
-    NAWDS_CMDTYPE cmdtype;
-    NAWDS_STATUS status;
+    IEEE80211_WLANCONFIG_CMDTYPE cmdtype;
+    IEEE80211_WLANCONFIG_STATUS status;
     union {
         struct {
             a_uint8_t num;
@@ -327,7 +318,6 @@ typedef struct atd_nawds_cfg {
             a_uint8_t caps;
         }nawds;
 
-        struct acfg_wnm_cfg wnm;
     }data;
 } __attribute__((__packed__)) atd_nawds_cfg_t;
 
@@ -422,12 +412,7 @@ typedef struct atd_stats {
     a_uint32_t missed_beacon;
 } __attribute__((__packed__)) atd_stats_t;
 
-typedef struct atd_ath_diag {
-    a_uint8_t  ad_name[ACFG_MAX_IFNAME];
-    a_uint16_t ad_id;
-    a_uint16_t ad_in_size;
-    a_uint32_t ad_out_size;
-} __attribute__((__packed__)) atd_ath_diag_t;
+typedef struct ath_diag atd_ath_diag_t;
 
 typedef struct atd_acl_mac {
     a_uint32_t num;
@@ -440,340 +425,6 @@ typedef struct atd_wsupp_message {
     a_uint8_t data[0];
 } __attribute__((__packed__)) atd_wsupp_message_t;
 
-typedef struct atd_ath_stats_11n {
-    a_uint32_t    ast_watchdog;
-    a_uint32_t    ast_resetOnError;
-    a_uint32_t    ast_mat_ucast_encrypted;
-    a_uint32_t    ast_mat_rx_recrypt;
-    a_uint32_t    ast_mat_rx_decrypt;
-    a_uint32_t    ast_mat_key_switch;
-    a_uint32_t    ast_hardware;
-    a_uint32_t    ast_bmiss;
-    a_uint32_t    ast_rxorn;
-    a_uint32_t    ast_rxorn_bmiss;
-    a_uint32_t    ast_rxeol;
-    a_uint32_t    ast_txurn;
-    a_uint32_t    ast_txto;
-    a_uint32_t    ast_cst;
-    a_uint32_t    ast_mib;
-    a_uint32_t    ast_rx;
-    a_uint32_t    ast_rxdesc;
-    a_uint32_t    ast_rxerr;
-    a_uint32_t    ast_rxnofrm;
-    a_uint32_t    ast_tx;
-    a_uint32_t    ast_txdesc;
-    a_uint32_t    ast_tim_timer;
-    a_uint32_t    ast_bbevent;
-    a_uint32_t    ast_rxphy;
-    a_uint32_t    ast_rxkcm;
-    a_uint32_t    ast_swba;
-    a_uint32_t    ast_brssi;
-    a_uint32_t    ast_bnr;
-    a_uint32_t    ast_tim;
-    a_uint32_t    ast_dtim;
-    a_uint32_t    ast_dtimsync;
-    a_uint32_t    ast_gpio;
-    a_uint32_t    ast_cabend;
-    a_uint32_t    ast_tsfoor;
-    a_uint32_t    ast_gentimer;
-    a_uint32_t    ast_gtt;
-    a_uint32_t    ast_fatal;
-    a_uint32_t    ast_tx_packets;
-    a_uint32_t    ast_rx_packets;
-    a_uint32_t    ast_tx_mgmt;
-    a_uint32_t    ast_tx_discard;
-    a_uint32_t    ast_tx_invalid;
-    a_uint32_t    ast_tx_qstop;
-    a_uint32_t    ast_tx_encap;
-    a_uint32_t    ast_tx_nonode;
-    a_uint32_t    ast_tx_nobuf;
-    a_uint32_t    ast_tx_stop;
-    a_uint32_t    ast_tx_resume;
-    a_uint32_t    ast_tx_nobufmgt;
-    a_uint32_t    ast_tx_xretries;
-    a_uint64_t    ast_tx_hw_retries;
-    a_uint64_t    ast_tx_hw_success;
-    a_uint32_t    ast_tx_fifoerr;
-    a_uint32_t    ast_tx_filtered;
-    a_uint32_t    ast_tx_badrate;
-    a_uint32_t    ast_tx_noack;
-    a_uint32_t    ast_tx_cts;
-    a_uint32_t    ast_tx_shortpre;
-    a_uint32_t    ast_tx_altrate;
-    a_uint32_t    ast_tx_protect;
-    a_uint32_t    ast_rx_orn;
-    a_uint32_t    ast_rx_badcrypt;
-    a_uint32_t    ast_rx_badmic;
-    a_uint32_t    ast_rx_nobuf;
-    a_uint32_t    ast_rx_swdecrypt;
-    a_uint32_t    ast_rx_hal_in_progress;
-    a_uint32_t    ast_rx_num_data;
-    a_uint32_t    ast_rx_num_mgmt;
-    a_uint32_t    ast_rx_num_ctl;
-    a_uint32_t    ast_rx_num_unknown;
-    a_uint32_t    ast_max_pkts_per_intr;
-    a_uint32_t    ast_pkts_per_intr[ACFG_MAX_INTR_BKT+1];
-    a_int8_t      ast_tx_rssi;
-    a_int8_t      ast_tx_rssi_ctl0;
-    a_int8_t      ast_tx_rssi_ctl1;
-    a_int8_t      ast_tx_rssi_ctl2;
-    a_int8_t      ast_tx_rssi_ext0;
-    a_int8_t      ast_tx_rssi_ext1;
-    a_int8_t      ast_tx_rssi_ext2;
-    a_int8_t      ast_rx_rssi;
-    a_int8_t      ast_rx_rssi_ctl0;
-    a_int8_t      ast_rx_rssi_ctl1;
-    a_int8_t      ast_rx_rssi_ctl2;
-    a_int8_t      ast_rx_rssi_ext0;
-    a_int8_t      ast_rx_rssi_ext1;
-    a_int8_t      ast_rx_rssi_ext2;
-    a_uint32_t    ast_be_xmit;
-    a_uint32_t    ast_be_nobuf;
-    a_uint32_t    ast_per_cal;
-    a_uint32_t    ast_per_calfail;
-    a_uint32_t    ast_per_rfgain;
-    a_uint32_t    ast_rate_calls;
-    a_uint32_t    ast_rate_raise;
-    a_uint32_t    ast_rate_drop;
-    a_uint32_t    ast_ant_defswitch;
-    a_uint32_t    ast_ant_txswitch;
-    a_uint32_t    ast_ant_rx[8];
-    a_uint32_t    ast_ant_tx[8];
-    a_uint64_t    ast_rx_bytes;
-    a_uint64_t    ast_tx_bytes;
-    a_uint32_t    ast_rx_num_qos_data[16];
-    a_uint32_t    ast_rx_num_nonqos_data;
-    a_uint32_t    ast_txq_packets[16];
-    a_uint32_t    ast_txq_xretries[16];
-    a_uint32_t    ast_txq_fifoerr[16];
-    a_uint32_t    ast_txq_filtered[16];
-    a_uint32_t    ast_txq_athbuf_limit[16];
-    a_uint32_t    ast_txq_nobuf[16];
-    a_uint8_t     ast_num_rxchain;
-    a_uint8_t     ast_num_txchain;
-    struct {
-        a_uint32_t   tx_pkts;
-        a_uint32_t   tx_checks;
-        a_uint32_t   tx_drops;
-        a_uint32_t   tx_minqdepth;
-        a_uint32_t   tx_queue;
-        a_uint32_t   tx_resetq;
-        a_uint32_t   tx_comps;
-        a_uint32_t   tx_comperror;
-        a_uint32_t   tx_unaggr_comperror;
-        a_uint32_t   tx_stopfiltered;
-        a_uint32_t   tx_qnull;
-        a_uint32_t   tx_noskbs;
-        a_uint32_t   tx_nobufs;
-        a_uint32_t   tx_badsetups;
-        a_uint32_t   tx_normnobufs;
-        a_uint32_t   tx_schednone;
-        a_uint32_t   tx_bars;
-        a_uint32_t   tx_legacy;
-        a_uint32_t   txunaggr_single;
-        a_uint32_t   txbar_xretry;
-        a_uint32_t   txbar_compretries;
-        a_uint32_t   txbar_errlast;
-        a_uint32_t   tx_compunaggr;
-        a_uint32_t   txunaggr_xretry;
-        a_uint32_t   tx_compaggr;
-        a_uint32_t   tx_bawadv;
-        a_uint32_t   tx_bawretries;
-        a_uint32_t   tx_bawnorm;
-        a_uint32_t   tx_bawupdates;
-        a_uint32_t   tx_bawupdtadv;
-        a_uint32_t   tx_retries;
-        a_uint32_t   tx_xretries;
-        a_uint32_t   tx_aggregates;
-        a_uint32_t   tx_sf_hw_xretries;
-        a_uint32_t   tx_aggr_frames;
-        a_uint32_t   txaggr_noskbs;
-        a_uint32_t   txaggr_nobufs;
-        a_uint32_t   txaggr_badkeys;
-        a_uint32_t   txaggr_schedwindow;
-        a_uint32_t   txaggr_single;
-        a_uint32_t   txaggr_mimo;
-        a_uint32_t   txaggr_compgood;
-        a_uint32_t   txaggr_comperror;
-        a_uint32_t   txaggr_compxretry;
-        a_uint32_t   txaggr_compretries;
-        a_uint32_t   txunaggr_compretries;
-        a_uint32_t   txaggr_prepends;
-        a_uint32_t   txaggr_filtered;
-        a_uint32_t   txaggr_fifo;
-        a_uint32_t   txaggr_xtxop;
-        a_uint32_t   txaggr_desc_cfgerr;
-        a_uint32_t   txaggr_data_urun;
-        a_uint32_t   txaggr_delim_urun;
-        a_uint32_t   txaggr_errlast;
-        a_uint32_t   txunaggr_errlast;
-        a_uint32_t   txaggr_longretries;
-        a_uint32_t   txaggr_shortretries;
-        a_uint32_t   txaggr_timer_exp;
-        a_uint32_t   txaggr_babug;
-        a_uint32_t   txrifs_single;
-        a_uint32_t   txrifs_babug;
-        a_uint32_t   txaggr_badtid;
-        a_uint32_t   txrifs_compretries;
-        a_uint32_t   txrifs_bar_alloc;
-        a_uint32_t   txrifs_bar_freed;
-        a_uint32_t   txrifs_compgood;
-        a_uint32_t   txrifs_prepends;
-        a_uint32_t   tx_comprifs;
-        a_uint32_t   tx_compnorifs;
-        a_uint32_t   rx_pkts;
-        a_uint32_t   rx_aggr;
-        a_uint32_t   rx_aggrbadver;
-        a_uint32_t   rx_bars;
-        a_uint32_t   rx_nonqos;
-        a_uint32_t   rx_seqreset;
-        a_uint32_t   rx_oldseq;
-        a_uint32_t   rx_bareset;
-        a_uint32_t   rx_baresetpkts;
-        a_uint32_t   rx_dup;
-        a_uint32_t   rx_baadvance;
-        a_uint32_t   rx_recvcomp;
-        a_uint32_t   rx_bardiscard;
-        a_uint32_t   rx_barcomps;
-        a_uint32_t   rx_barrecvs;
-        a_uint32_t   rx_skipped;
-        a_uint32_t   rx_comp_to;
-        a_uint32_t   rx_timer_starts;
-        a_uint32_t   rx_timer_stops;
-        a_uint32_t   rx_timer_run;
-        a_uint32_t   rx_timer_more;
-        a_uint32_t   wd_tx_active;
-        a_uint32_t   wd_tx_inactive;
-        a_uint32_t   wd_tx_hung;
-        a_uint32_t   wd_spurious;
-        a_uint32_t   tx_requeue;
-        a_uint32_t   tx_drain_txq;
-        a_uint32_t   tx_drain_tid;
-        a_uint32_t   tx_cleanup_tid;
-        a_uint32_t   tx_drain_bufs;
-        a_uint32_t   tx_tidpaused;
-        a_uint32_t   tx_tidresumed;
-        a_uint32_t   tx_unaggr_filtered;
-        a_uint32_t   tx_aggr_filtered;
-        a_uint32_t   tx_filtered;
-        a_uint32_t   rx_rb_on;
-        a_uint32_t   rx_rb_off;
-        a_uint32_t   rx_dsstat_err;
-        a_uint32_t   bf_stream_miss;
-        a_uint32_t   bf_bandwidth_miss;
-        a_uint32_t   bf_destination_miss;
-    } ast_11n_stats;
-    struct {
-        a_uint32_t           dfs_stats_valid;
-        a_uint32_t           event_count;
-        a_uint32_t           chirp_count;
-        a_uint32_t           num_filter;
-        struct {
-            a_uint32_t       max_pri_count;
-            a_uint32_t       max_used_pri;
-            a_uint32_t       excess_pri;
-            a_uint32_t       pri_threshold_reached;
-            a_uint32_t       dur_threshold_reached;
-            a_uint32_t       rssi_threshold_reached;
-            a_uint32_t       filter_id;
-        } fstat[ACFG_MAX_DFS_FILTER];
-    } ast_dfs_stats;
-    a_uint32_t   ast_bb_hang;
-    a_uint32_t   ast_mac_hang;
-    a_uint32_t   ast_wow_wakeups;
-    a_uint32_t   ast_wow_wakeupsok;
-    a_uint32_t   ast_wow_wakeupserror;
-    a_uint32_t   ast_normal_sleeps;
-    a_uint32_t   ast_normal_wakeups;
-    a_uint32_t   ast_wow_sleeps;
-    a_uint32_t   ast_wow_sleeps_nonet;
-    a_uint32_t   ast_uapsdqnulbf_unavail;
-    a_uint32_t   ast_uapsdqnul_pkts;
-    a_uint32_t   ast_uapsdtriggers;
-    a_uint32_t   ast_uapsdnodeinvalid;
-    a_uint32_t   ast_uapsdeospdata;
-    a_uint32_t   ast_uapsddata_pkts;
-    a_uint32_t   ast_uapsddatacomp;
-    a_uint32_t   ast_uapsdqnulcomp;
-    a_uint32_t   ast_uapsddataqueued;
-    a_uint32_t   ast_uapsdedmafifofull;
-    a_uint32_t   ast_vow_ul_tx_calls[4];
-    a_uint32_t   ast_vow_ath_txq_calls[4];
-    a_uint32_t   ast_vow_ath_be_drop, ast_vow_ath_bk_drop;
-    a_uint32_t   ast_cfend_sched;
-    a_uint32_t   ast_cfend_sent;
-    a_uint32_t   ast_retry_delay[ACFG_LATENCY_CATS][ACFG_LATENCY_BINS];
-    a_uint32_t   ast_queue_delay[ACFG_LATENCY_CATS][ACFG_LATENCY_BINS];
-    a_uint32_t   vi_timestamp[ACFG_VI_LOG_LEN];
-    a_uint8_t    vi_rssi_ctl0[ACFG_VI_LOG_LEN];
-    a_uint8_t    vi_rssi_ctl1[ACFG_VI_LOG_LEN];
-    a_uint8_t    vi_rssi_ctl2[ACFG_VI_LOG_LEN];
-    a_uint8_t    vi_rssi_ext0[ACFG_VI_LOG_LEN];
-    a_uint8_t    vi_rssi_ext1[ACFG_VI_LOG_LEN];
-    a_uint8_t    vi_rssi_ext2[ACFG_VI_LOG_LEN];
-    a_uint8_t    vi_rssi[ACFG_VI_LOG_LEN];
-    a_uint8_t    vi_evm0[ACFG_VI_LOG_LEN];
-    a_uint8_t    vi_evm1[ACFG_VI_LOG_LEN];
-    a_uint8_t    vi_evm2[ACFG_VI_LOG_LEN];
-    a_uint8_t    vi_rs_rate[ACFG_VI_LOG_LEN];
-    a_uint32_t   vi_tx_frame_cnt[ACFG_VI_LOG_LEN];
-    a_uint32_t   vi_rx_frame_cnt[ACFG_VI_LOG_LEN];
-    a_uint32_t   vi_rx_clr_cnt[ACFG_VI_LOG_LEN];
-    a_uint32_t   vi_rx_ext_clr_cnt[ACFG_VI_LOG_LEN];
-    a_uint32_t   vi_cycle_cnt[ACFG_VI_LOG_LEN];
-    a_uint8_t    vi_stats_index;
-    a_uint8_t    ast_txbf;
-    a_uint8_t    ast_lastratecode;
-    a_uint32_t   ast_sounding_count;
-    a_uint32_t   ast_txbf_rpt_count;
-    a_uint32_t   ast_mcs_count[ACFG_MCS_RATES+1];
-    a_uint32_t   ast_rx_looplimit_start;
-    a_uint32_t   ast_rx_looplimit_end;
-    a_uint32_t   ast_chan_clr_cnt;
-    a_uint32_t   ast_cycle_cnt;
-    a_int16_t    ast_noise_floor;
-    struct {
-        a_uint32_t   ast_ackrcv_bad;
-        a_uint32_t   ast_rts_bad;
-        a_uint32_t   ast_rts_good;
-        a_uint32_t   ast_fcs_bad;
-        a_uint32_t   ast_beacons;
-        struct {
-            a_uint32_t   tx_shortretry;
-            a_uint32_t   tx_longretry;
-            a_uint32_t   tx_xretries;
-            a_uint32_t   ht_tx_unaggr_xretry;
-            a_uint32_t   ht_tx_xretries;
-            a_uint32_t   tx_pkt;
-            a_uint32_t   tx_aggr;
-            a_uint32_t   tx_retry;
-            a_uint32_t   txaggr_retry;
-            a_uint32_t   txaggr_sub_retry;
-        } ast_tgt_stats;
-    } ast_mib_stats;
-    struct {
-        int        valid;
-        a_uint32_t status;
-        a_uint32_t tsf;
-        a_uint32_t phy_panic_wd_ctl1;
-        a_uint32_t phy_panic_wd_ctl2;
-        a_uint32_t phy_gen_ctrl;
-        a_uint32_t rxc_pcnt;
-        a_uint32_t rxf_pcnt;
-        a_uint32_t txf_pcnt;
-        a_uint32_t cycles;
-        a_uint32_t wd;
-        a_uint32_t det;
-        a_uint32_t rdar;
-        a_uint32_t r_odfm;
-        a_uint32_t r_cck;
-        a_uint32_t t_odfm;
-        a_uint32_t t_cck;
-        a_uint32_t agc;
-        a_uint32_t src;
-    } ast_bb_panic[ACFG_MAX_BB_PANICS];
-} __attribute__((__packed__)) atd_ath_stats_11n_t;
-
 typedef struct atd_txrx_elem {
     a_uint64_t      pkts;
     a_uint64_t      bytes;
@@ -801,456 +452,10 @@ typedef struct atd_txrx_stats {
     } rx;
 } __attribute__((__packed__)) atd_txrx_stats_t;
 
-typedef struct atd_ath_stats_11ac {
-    int                       txrx_stats_level;
-    atd_txrx_stats_t          txrx_stats;
-    struct {
-        struct {
-            a_int32_t         comp_queued;
-            a_int32_t         comp_delivered;
-            a_int32_t         msdu_enqued;
-            a_int32_t         mpdu_enqued;
-            a_int32_t         wmm_drop;
-            a_int32_t         local_enqued;
-            a_int32_t         local_freed;
-            a_int32_t         hw_queued;
-            a_int32_t         hw_reaped;
-            a_int32_t         underrun;
-            a_int32_t         tx_abort;
-            a_int32_t         mpdus_requed;
-            a_uint32_t        tx_ko;
-            a_uint32_t        data_rc;
-            a_uint32_t        self_triggers;
-            a_uint32_t        sw_retry_failure;
-            a_uint32_t        illgl_rate_phy_err;
-            a_uint32_t        pdev_cont_xretry;
-            a_uint32_t        pdev_tx_timeout;
-            a_uint32_t        pdev_resets;
-            a_uint32_t        stateless_tid_alloc_failure;
-            a_uint32_t        phy_underrun;
-            a_uint32_t        txop_ovf;
-        } tx;
-        struct {
-            a_int32_t         mid_ppdu_route_change;
-            a_int32_t         status_rcvd;
-            a_int32_t         r0_frags;
-            a_int32_t         r1_frags;
-            a_int32_t         r2_frags;
-            a_int32_t         r3_frags;
-            a_int32_t         htt_msdus;
-            a_int32_t         htt_mpdus;
-            a_int32_t         loc_msdus;
-            a_int32_t         loc_mpdus;
-            a_int32_t         oversize_amsdu;
-            a_int32_t         phy_errs;
-            a_int32_t         phy_err_drop;
-            a_int32_t         mpdu_errs;
-        } rx;
-        struct {
-            a_uint32_t        dram_remain;
-            a_uint32_t        iram_remain;
-        } mem;
-        struct {
-	    a_int32_t         dummy;
-        } peer;
-    } stats;
-    struct {
-        a_uint64_t    tx_beacon;
-        a_uint32_t    be_nobuf;
-        a_uint32_t    tx_buf_count; 
-        a_uint32_t    tx_packets;
-        a_uint32_t    rx_packets;
-        a_int32_t     tx_mgmt;
-        a_uint32_t    tx_num_data;
-        a_uint32_t    rx_num_data;
-        a_int32_t     rx_mgmt;
-        a_uint32_t    rx_num_mgmt;
-        a_uint32_t    rx_num_ctl;
-        a_uint32_t    tx_rssi;
-        a_uint32_t    tx_mcs[10];
-        a_uint32_t    rx_mcs[10];
-        a_uint32_t    rx_rssi_comb;
-        struct {
-            a_uint8_t     rx_rssi_pri20;
-            a_uint8_t     rx_rssi_sec20;
-            a_uint8_t     rx_rssi_sec40;
-            a_uint8_t     rx_rssi_sec80;
-        } rx_rssi_chain0;
-        struct {
-            a_uint8_t     rx_rssi_pri20;
-            a_uint8_t     rx_rssi_sec20;
-            a_uint8_t     rx_rssi_sec40;
-            a_uint8_t     rx_rssi_sec80;
-        } rx_rssi_chain1;
-        struct {
-            a_uint8_t     rx_rssi_pri20;
-            a_uint8_t     rx_rssi_sec20;
-            a_uint8_t     rx_rssi_sec40;
-            a_uint8_t     rx_rssi_sec80;
-        } rx_rssi_chain2;
-        struct {
-            a_uint8_t     rx_rssi_pri20;
-            a_uint8_t     rx_rssi_sec20;
-            a_uint8_t     rx_rssi_sec40;
-            a_uint8_t     rx_rssi_sec80;
-        } rx_rssi_chain3;
-        a_uint64_t    rx_bytes;
-        a_uint64_t    tx_bytes;
-        a_uint32_t    tx_compaggr;
-        a_uint32_t    rx_aggr;
-        a_uint32_t    tx_bawadv;
-        a_uint32_t    tx_compunaggr;
-        a_uint32_t    rx_overrun;
-        a_uint32_t    rx_badcrypt;
-        a_uint32_t    rx_badmic;
-        a_uint32_t    rx_crcerr;
-        a_uint32_t    rx_phyerr;
-        a_uint32_t    ackRcvBad;
-        a_uint32_t    rtsBad;
-        a_uint32_t    rtsGood;
-        a_uint32_t    fcsBad;
-        a_uint32_t    noBeacons;
-        a_uint32_t    mib_int_count;
-        a_uint32_t    rx_looplimit_start;
-        a_uint32_t    rx_looplimit_end;
-        a_uint8_t     ap_stats_tx_cal_enable;
-    } interface_stats;
-} __attribute__((__packed__)) atd_ath_stats_11ac_t;
-
-typedef struct atd_bcnrpt {
-    a_uint8_t bssid[6];
-    a_uint8_t rsni;
-    a_uint8_t rcpi;
-    a_uint8_t chnum;
-    a_uint8_t more;
-} __attribute__((__packed__)) atd_bcnrpt_t;
-
-typedef struct atd_rrmstats {
-    a_uint8_t     chann_load[ACFG_MAX_IEEE_CHAN];
-    struct {
-        a_uint8_t        antid;
-        a_int8_t         anpi;
-        a_uint8_t        ipi[11]; 
-    } noise_data[ACFG_MAX_IEEE_CHAN];
-    struct {
-        struct {
-            a_uint32_t   txfragcnt;
-            a_uint32_t   mcastfrmcnt;
-            a_uint32_t   failcnt;
-            a_uint32_t   rxfragcnt;
-            a_uint32_t   mcastrxfrmcnt;
-            a_uint32_t   fcserrcnt;
-            a_uint32_t   txfrmcnt;
-        } gid0;
-        struct {
-            a_uint32_t   rty;
-            a_uint32_t   multirty;
-            a_uint32_t   frmdup;
-            a_uint32_t   rtsuccess;
-            a_uint32_t   rtsfail;
-            a_uint32_t   ackfail;
-        } gid1;
-        struct {
-            a_uint32_t   qostxfragcnt;
-            a_uint32_t   qosfailedcnt;
-            a_uint32_t   qosrtycnt;
-            a_uint32_t   multirtycnt;
-            a_uint32_t   qosfrmdupcnt;
-            a_uint32_t   qosrtssuccnt;
-            a_uint32_t   qosrtsfailcnt;
-            a_uint32_t   qosackfailcnt;
-            a_uint32_t   qosrxfragcnt;
-            a_uint32_t   qostxfrmcnt;
-            a_uint32_t   qosdiscadrfrmcnt;
-            a_uint32_t   qosmpdurxcnt;
-            a_uint32_t   qosrtyrxcnt;
-        } gidupx[8];
-        struct {
-             a_uint8_t   ap_avg_delay;
-             a_uint8_t   be_avg_delay;
-             a_uint8_t   bk_avg_delay;
-             a_uint8_t   vi_avg_delay;
-             a_uint8_t   vo_avg_delay;
-             a_uint16_t  st_cnt;
-             a_uint8_t   ch_util;
-        } gid10;
-        struct {
-            a_uint8_t    tid;
-            a_uint8_t    brange;
-            a_uint8_t    mac[6];
-            a_uint32_t   tx_cnt;
-            a_uint32_t   discnt;
-            a_uint32_t   multirtycnt;
-            a_uint32_t   cfpoll;
-            a_uint32_t   qdelay;
-            a_uint32_t   txdelay;
-            a_uint32_t   bin[6];
-        } tsm_data;
-        struct {
-            a_uint8_t    phytype;
-            a_uint8_t    arcpi;
-            a_uint8_t    lrsni;
-            a_uint8_t    lrcpi;
-            a_uint8_t    antid;
-            a_uint8_t    ta[6];
-            a_uint8_t    bssid[6];
-            a_uint16_t   frmcnt;
-        } frmcnt_data[12];
-        struct {
-            a_uint8_t    tx_pow;
-            a_uint8_t    lmargin;
-            a_uint8_t    rxant;
-            a_uint8_t    txant;
-            a_uint8_t    rcpi;
-            a_uint8_t    rsni;
-        } lm_data;
-        struct {
-            a_uint8_t    id;
-            a_uint8_t    len;
-            a_uint8_t    lat_res;
-            a_uint8_t    alt_type;
-            a_uint8_t    long_res;
-            a_uint8_t    alt_res;
-            a_uint8_t    azi_res;
-            a_uint8_t    alt_frac;
-            a_uint8_t    datum;
-            a_uint8_t    azi_type;
-            a_uint16_t   lat_integ;
-            a_uint16_t   long_integ;
-            a_uint16_t   azimuth;
-            a_uint32_t   lat_frac;
-            a_uint32_t   long_frac;
-            a_uint32_t   alt_integ;
-        } ni_rrm_lciinfo;
-        struct {
-            a_uint8_t    id;
-            a_uint8_t    len;
-            a_uint8_t    lat_res;
-            a_uint8_t    alt_type;
-            a_uint8_t    long_res;
-            a_uint8_t    alt_res;
-            a_uint8_t    azi_res;
-            a_uint8_t    alt_frac;
-            a_uint8_t    datum;
-            a_uint8_t    azi_type;
-            a_uint16_t   lat_integ;
-            a_uint16_t   long_integ;
-            a_uint16_t   azimuth;
-            a_uint32_t   lat_frac;
-            a_uint32_t   long_frac;
-            a_uint32_t   alt_integ;
-        } ni_vap_lciinfo;
-    } ni_rrm_stats;
-} __attribute__((__packed__)) atd_rrmstats_t;
-
-typedef struct atd_acs_dbg {
-    a_uint8_t   nchans;
-    a_uint8_t   entry_id;
-    a_uint16_t  chan_freq;
-    a_uint8_t   ieee_chan;
-    a_uint8_t   chan_nbss;
-    a_int32_t   chan_maxrssi;
-    a_int32_t   chan_minrssi;
-    a_int16_t   noisefloor;
-    a_int16_t   channel_loading;
-    a_uint32_t  chan_load;
-    a_uint8_t   sec_chan;
-} __attribute__((__packed__)) atd_acs_dbg_t;
-
-typedef struct atd_athdbg_req {
-    a_uint8_t cmd;
-    a_uint8_t dstmac[ACFG_MACADDR_LEN];
-    union {
-        int param[4];
-        struct  {
-            a_uint16_t   num_rpt;
-            a_uint8_t    regclass;
-            a_uint8_t    channum;
-            a_uint16_t   random_ivl;
-            a_uint16_t   duration;
-            a_uint8_t    reqmode;
-            a_uint8_t    reqtype;
-            a_uint8_t    bssid[6];
-            a_uint8_t    mode;
-            a_uint8_t    req_ssid;
-            a_uint8_t    rep_cond;
-            a_uint8_t    rep_thresh;
-            a_uint8_t    rep_detail;
-            a_uint8_t    req_ie;
-            a_uint8_t    num_chanrep;
-            struct {
-                a_uint8_t regclass;
-                a_uint8_t numchans;
-                a_uint8_t channum[5];
-            } apchanrep[2];
-        } bcnrpt;
-        struct {
-            a_uint16_t   num_rpt;
-            a_uint16_t   rand_ivl;
-            a_uint16_t   meas_dur;
-            a_uint8_t    reqmode;
-            a_uint8_t    reqtype;
-            a_uint8_t    tid;
-            a_uint8_t    macaddr[6];
-            a_uint8_t    bin0_range;
-            a_uint8_t    trig_cond;
-            a_uint8_t    avg_err_thresh;
-            a_uint8_t    cons_err_thresh;
-            a_uint8_t    delay_thresh;
-            a_uint8_t    meas_count;
-            a_uint8_t    trig_timeout;
-        } tsmrpt;
-        struct {
-             a_uint8_t   dialogtoken;
-             a_uint8_t   ssid[32];
-             a_uint8_t   ssid_len;
-        } neigrpt;
-        struct {
-             a_uint8_t   dialogtoken;
-             a_uint8_t   candidate_list;
-             a_uint8_t   disassoc;
-             a_uint16_t  disassoc_timer;
-             a_uint8_t   validity_itvl;
-        } bstmreq;
-        struct {
-            a_uint8_t    traffic_type;
-            a_uint8_t    direction;
-            a_uint8_t    dot1Dtag;
-            a_uint8_t    tid;
-            a_uint8_t    acc_policy_edca;
-            a_uint8_t    acc_policy_hcca;
-            a_uint8_t    aggregation;
-            a_uint8_t    psb;
-            a_uint8_t    ack_policy;
-            a_uint16_t   norminal_msdu_size;
-            a_uint16_t   max_msdu_size;
-            a_uint32_t   min_srv_interval;
-            a_uint32_t   max_srv_interval;
-            a_uint32_t   inactivity_interval;
-            a_uint32_t   suspension_interval;
-            a_uint32_t   srv_start_time;
-            a_uint32_t   min_data_rate;
-            a_uint32_t   mean_data_rate;
-            a_uint32_t   peak_data_rate;
-            a_uint32_t   max_burst_size;
-            a_uint32_t   delay_bound;
-            a_uint32_t   min_phy_rate;
-            a_uint16_t   surplus_bw;
-            a_uint16_t   medium_time;
-        } tsinfo;
-        struct {
-            a_uint8_t    dstmac[6];
-            a_uint16_t   num_rpts;
-            a_uint8_t    regclass;
-            a_uint8_t    chnum;
-            a_uint16_t   r_invl;
-            a_uint16_t   m_dur;
-            a_uint8_t    cond;
-            a_uint8_t    c_val;
-        } chloadrpt;
-        struct {
-            a_uint8_t    dstmac[6];
-            a_uint16_t   num_rpts;
-            a_uint16_t   m_dur;
-            a_uint16_t   r_invl;
-            a_uint8_t    gid;
-        } stastats;
-        struct {
-            a_uint16_t   num_rpts;
-            a_uint8_t    dstmac[6];
-            a_uint8_t    regclass;
-            a_uint8_t    chnum;
-            a_uint16_t   r_invl;
-            a_uint16_t   m_dur;
-            a_uint8_t    cond;
-            a_uint8_t    c_val;
-        } nhist;
-        struct {
-            a_uint8_t    dstmac[6];
-            a_uint8_t    peermac[6];
-            a_uint16_t   num_rpts;
-            a_uint8_t    regclass;
-            a_uint8_t    chnum;
-            a_uint16_t   r_invl;
-            a_uint16_t   m_dur;
-            a_uint8_t    ftype;
-        } frm_req;
-        struct {
-            a_uint8_t    dstmac[6];
-            a_uint16_t   num_rpts;
-            a_uint8_t    location;
-            a_uint8_t    lat_res;
-            a_uint8_t    long_res;
-            a_uint8_t    alt_res;
-            a_uint8_t    azi_res;
-            a_uint8_t    azi_type;
-        } lci_req;
-        struct {
-            a_uint32_t   index;
-            a_uint32_t   data_size;
-            void         *data_addr;
-        } rrmstats_req;
-        struct {
-            a_uint32_t   index;
-            a_uint32_t   data_size;
-            void         *data_addr;
-        } acs_rep;
-        struct {
-            a_uint32_t   data_size;
-            a_uint32_t   cmdid;
-            void         *data_addr;
-        } tr069;
-        struct {
-            a_uint32_t inactivity_timeout_normal;
-            a_uint32_t inactivity_timeout_overload;
-            a_uint32_t inactivity_check_period;
-            a_uint32_t utilization_sample_period;
-            a_uint32_t utilization_average_num_samples;
-            a_uint32_t inactive_rssi_crossing_threshold;
-            a_uint32_t low_rssi_crossing_threshold;
-        } bst;
-        struct {
-            a_uint8_t  raw_log_enable;
-        } bst_dbg;
-        struct {
-            a_uint8_t sender_addr[ACFG_MACADDR_LEN];
-            a_uint16_t num_measurements;
-        } bst_rssi_req;
-        a_uint8_t bsteering_probe_resp_wh;
-        a_uint8_t bsteering_enable;
-        a_uint8_t bsteering_overload;
-        a_uint8_t bsteering_rssi_num_samples;
-        struct {
-            a_uint8_t     mu_req_id;
-            a_uint8_t     mu_channel;
-            a_uint32_t    mu_type;
-            a_uint32_t    mu_duration;
-            a_uint32_t    lteu_tx_power;
-        } mu_scan;
-        struct {
-            a_uint8_t     lteu_gpio_start;
-            a_uint8_t     lteu_num_bins;        
-            a_uint8_t     use_actual_nf;        
-            a_uint32_t    lteu_weight[ACFG_LTEU_MAX_BINS];
-            a_uint32_t    lteu_thresh[ACFG_LTEU_MAX_BINS];
-            a_uint32_t    lteu_gamma[ACFG_LTEU_MAX_BINS];
-            a_uint32_t    lteu_scan_timeout;
-            a_uint32_t    alpha_num_bssid;
-        } lteu_cfg_t;
-        struct {
-            a_uint8_t     scan_req_id;
-            a_uint8_t     scan_num_chan;      
-            a_uint8_t     scan_channel_list[ACFG_MAX_SCAN_CHANS];
-            a_int32_t     scan_type;            
-            a_uint32_t    scan_duration;       
-            a_uint32_t    scan_repeat_probe_time;
-            a_uint32_t    scan_rest_time;       
-            a_uint32_t    scan_idle_time;       
-            a_uint32_t    scan_probe_delay;     
-        } ap_scan_t;
-    } data;
-} __attribute__((__packed__)) atd_athdbg_req_t;
-
+typedef struct ieee80211_acs_dbg atd_acs_dbg_t;
+typedef ieee80211_rrmstats_t atd_rrmstats_t;
+typedef ieee80211_bcnrpt_t atd_bcnrpt_t;
+typedef struct ieee80211req_athdbg atd_athdbg_req_t;
 
 typedef struct atd_set_chn_width {
     a_uint32_t    setchnwidth[3];
@@ -1378,5 +583,19 @@ typedef struct atd_spectral_chan_stats {
     int8_t maxregpower;
 } __attribute__((__packed__)) atd_SPECTRAL_CHAN_STATS_T;
 
+#define ATD_CUSTDATA_LENGTH       20
+
+/**
+ * @brief get custdata
+ */
+typedef struct atd_custdata {
+    a_uint8_t      custdata[ATD_CUSTDATA_LENGTH];
+}atd_custdata_t;
+
+typedef struct ath_stats acfg_ath_stats_11n_t;
+typedef struct ath_stats atd_ath_stats_11n_t;
+typedef struct ol_stats atd_ath_stats_11ac_t;
+typedef struct ol_stats acfg_ath_stats_11ac_t;
+
 #endif /*  __ATD_CMD_H */
 
diff --git a/include/atd_wsupp_msg.h b/include/atd_wsupp_msg.h
index 50dc9d1..954022a 100644
--- a/include/atd_wsupp_msg.h
+++ b/include/atd_wsupp_msg.h
@@ -18,6 +18,7 @@
 #define ATD_WSUPP_MSG_H
 
 #include <a_base_types.h>
+#include <ieee80211_external_config.h>
 #include <acfg_api_types.h>
 
 #define WSUPP_MSG_UNIQUE_BIN_LEN    ACFG_WSUPP_UNIQUE_LEN
diff --git a/include/band_steering.h b/include/band_steering.h
deleted file mode 100644
index 39f013a..0000000
--- a/include/band_steering.h
+++ /dev/null
@@ -1,403 +0,0 @@
-/*
- * @@-COPYRIGHT-START-@@
- *
- * Copyright (c) 2014 Qualcomm Atheros, Inc.
- * All Rights Reserved.
- * Qualcomm Atheros Confidential and Proprietary.
- *
- * @@-COPYRIGHT-END-@@
- */
-
-#ifndef _BAND_STEERING__
-#define _BAND_STEERING__
-#define NETLINK_BAND_STEERING_EVENT 21
-#define BSTEERING_INVALID_RSSI 0
-#define IEEE80211_ADDR_LEN 6
-/**
- * Metadata about a probe request received from a client that is useful
- * for making band steering decisions.
- */
-struct bs_probe_req_ind {
-    /* The MAC address of the client that sent the probe request.*/
-    u_int8_t sender_addr[IEEE80211_ADDR_LEN];
-    /*  The RSSI of the received probe request.*/
-    u_int8_t rssi;
-};
-
-/**
- * Metadata about an authentication message that was sent with a failure
- * code due to the client being prohibited by the ACL.
- */
-struct bs_auth_reject_ind {
-    /* The MAC address of the client to which the authentication message 
-        was sent with a failure code.*/
-    u_int8_t client_addr[IEEE80211_ADDR_LEN];
-    /* The RSSI of the received authentication message (the one that
-       triggered the rejection).*/
-    u_int8_t rssi;
-};
-
-/**
- * Data rated related information contained in ATH_EVENT_BSTEERING_NODE_ASSOCIATED
- * and IEEE80211_DBGREQ_BSTEERING_GET_DATARATE_INFO response
- */
-typedef struct ieee80211_bsteering_datarate_info_t {
-    /* Maximum bandwidth the client supports, valid values are enumerated
-     * in enum ieee80211_cwm_width in _ieee80211.h. But the header file cannot
-     * be included here because of potential circular dependency. Caller should
-     * make sure that only valid values can be written/read. */
-    u_int8_t max_chwidth;
-    /* Number of spatial streams the client supports */
-    u_int8_t num_streams;
-    /* PHY mode the client supports. Same as max_chwidth field, only valid values
-     * enumerated in enum ieee80211_phymode can be used here. */
-    u_int8_t phymode;
-    /* Maximum MCS the client supports */
-    u_int8_t max_MCS;
-    /* Maximum TX power the client supports */
-    u_int8_t max_txpower;
-} ieee80211_bsteering_datarate_info_t;
-
-/**
- * Metadata about a STA that has associated
- */
-struct bs_node_associated_ind {
-    /* The MAC address of the client that is associated.*/
-    u_int8_t client_addr[IEEE80211_ADDR_LEN];
-    /* Set to 1 if this client supports BSS Transition Management */
-    u_int8_t isBTMSupported : 1;
-    /* Set to 1 if this client implements Radio Resource Manangement */
-    u_int8_t isRRMSupported : 1;
-    /* Data rate related information supported by this client */
-    ieee80211_bsteering_datarate_info_t datarate_info;
-};
-
-/**
- * Metadata about a client activity status change.
- */
-struct bs_activity_change_ind {
-    /* The MAC address of the client that activity status changes */
-    u_int8_t client_addr[IEEE80211_ADDR_LEN];
-    /* Activity status*/
-    u_int8_t activity;
-};
-
-/**
- * Data for a channel utilization measurement.
- */
-struct bs_chan_utilization_ind {
-    /* The current utilization on the band, expressed as a percentage.*/
-    u_int8_t utilization;
-};
-
-/**
- * Enumeration to mark crossing direction
- */
-typedef enum {
-    /* Threshold not crossed */
-    BSTEERING_XING_UNCHANGED = 0,
-    /* Threshold crossed in the up direction */
-    BSTEERING_XING_UP = 1,
-    /* Threshold crossed in the down direction */
-    BSTEERING_XING_DOWN = 2
-} BSTEERING_XING_DIRECTION;
-
-/**
- * Metadata about a client RSSI measurement crossed threshold.
- */
-struct bs_rssi_xing_threshold_ind {
-    /* The MAC address of the client */
-    u_int8_t client_addr[IEEE80211_ADDR_LEN];
-    /* The measured RSSI */
-    u_int8_t rssi;
-    /* Flag indicating if it crossed inactivity RSSI threshold */
-    BSTEERING_XING_DIRECTION inact_rssi_xing;
-    /* Flag indicating if it crossed low RSSI threshold */
-    BSTEERING_XING_DIRECTION low_rssi_xing;
-    /* Flag indicating if it crossed the rate RSSI threshold */
-    BSTEERING_XING_DIRECTION rate_rssi_xing;
-};
-
-/**
- * Metadata about a client requested RSSI measurement
- */
-struct bs_rssi_measurement_ind {
-    /* The MAC address of the client */
-    u_int8_t client_addr[IEEE80211_ADDR_LEN];
-    /* The measured RSSI */
-    u_int8_t rssi;
-};
-
-/**
- * Metadata about a Tx rate measurement 
- * NOTE: Debug event only, use bs_tx_rate_xing_threshold_ind for
- * rate crossing information.  
- */
-struct bs_tx_rate_measurement_ind {
-    /* The MAC address of the client */
-    u_int8_t client_addr[IEEE80211_ADDR_LEN];
-    /* The measured Tx rate */
-    u_int32_t tx_rate;
-};
-
-/**
- * Radio Resource Managmenet report types
- *
- * Note that these types are only used between user space and driver, and
- * not in sync with the OTA types defined in 802.11k spec.
- */
-typedef enum {
-    /* Indication of a beacon report. */
-    BSTEERING_RRM_TYPE_BCNRPT,
-
-    BSTEERING_RRM_TYPE_INVALID
-} BSTEERING_RRM_TYPE;
-
-/**
- * Number of RRM beacon reports in a single OTA message can be conveyed in
- * in single event up to user space. Multiple events will be sent if more
- * than this number of reports is included in a single OTA message.
- */
-#define IEEE80211_BSTEERING_RRM_NUM_BCNRPT_MAX 4
-
-/**
- * Metadata and report contents about a Radio Resource Measurement report
- */
-struct bs_rrm_report_ind {
-    /* The type of the rrm event: One of BSTEERING_RRM_TYPE.*/
-    u_int32_t rrm_type;
-    /* The token corresponding to the measurement request.*/
-    u_int8_t dialog_token;
-    /* MAC address of the reporter station.*/
-    u_int8_t macaddr[IEEE80211_ADDR_LEN];
-    /* The result bitmap, as defined in IEEE80211_RRM_MEASRPT_MODE.*/
-    u_int8_t measrpt_mode;
-    /* The report data. Which member is valid is based on the
-       rrm_type field.*/
-    union {
-        atd_bcnrpt_t   bcnrpt[IEEE80211_BSTEERING_RRM_NUM_BCNRPT_MAX];
-    } data;
-};
-
-/**
- * Wireless Network Management (WNM) report types
- */
-typedef enum {
-    /* Indication of reception of a BSS Transition Management response frame */
-    BSTEERING_WNM_TYPE_BSTM_RESPONSE,
-
-    BSTEERING_WNM_TYPE_INVALID
-} BSTEERING_WNM_TYPE;
-
-/* BSS Transition Management Response information that can be returned via netlink message */
-struct bs_wnm_bstm_resp {
-    /* status of the response to the request frame */
-    u_int8_t status;
-    /* number of minutes that the STA requests the BSS to delay termination */
-    u_int8_t termination_delay;
-    /* BSSID of the BSS that the STA transitions to */
-    u_int8_t target_bssid[IEEE80211_ADDR_LEN];
-} ;
-
-/**
- * Metadata and report contents about a Wireless Network 
- * Management event 
- */
-struct bs_wnm_event_ind {
-    /* The type of the wnm event: One of BSTEERING_WNM_TYPE.*/
-    u_int32_t wnm_type;
-    /* The token corresponding to the message.*/
-    u_int8_t dialog_token;
-    /* MAC address of the sending station.*/
-    u_int8_t macaddr[IEEE80211_ADDR_LEN];
-    /* The event data. Which member is valid is based on the
-       wnm_type field.*/
-    union {
-        struct bs_wnm_bstm_resp bstm_resp;
-    } data;
-};
-
-/**
- * Metadata about a client Tx rate threshold crossing event.
- */
-struct bs_tx_rate_xing_threshold_ind {
-    /* The MAC address of the client */
-    u_int8_t client_addr[IEEE80211_ADDR_LEN];
-    /* The Tx rate (in Kbps) */
-    u_int32_t tx_rate;
-    /* Flag indicating crossing direction */
-    BSTEERING_XING_DIRECTION xing;
-};
-
-/**
- * Metadata about Tx power change on a VAP
- */
-struct bs_tx_power_change_ind {
-    /* The new Tx power */
-    u_int16_t tx_power;
-};
-
-/**
- * Common event structure for all Netlink indications to userspace.
- */
-typedef struct ath_netlink_bsteering_event {
-    /* The type of the event: One of ATH_BSTEERING_EVENT.*/
-    u_int32_t type;
-    /* The OS-specific index of the VAP on which the event occurred.*/
-    u_int32_t sys_index;
-    /* The data for the event. Which member is valid is based on the
-       type field.*/
-    union {
-        struct bs_probe_req_ind bs_probe;
-        struct bs_node_associated_ind bs_node_associated;
-        struct bs_activity_change_ind bs_activity_change;
-        struct bs_auth_reject_ind bs_auth;
-        struct bs_chan_utilization_ind bs_chan_util;
-        struct bs_rssi_xing_threshold_ind bs_rssi_xing;
-        struct bs_rssi_measurement_ind bs_rssi_measurement;
-        struct bs_rrm_report_ind rrm_report;
-        struct bs_wnm_event_ind wnm_event;
-        struct bs_tx_rate_xing_threshold_ind bs_tx_rate_xing;
-        struct bs_tx_rate_measurement_ind bs_tx_rate_measurement;
-        struct bs_tx_power_change_ind bs_tx_power_change;
-    } data;
-} ath_netlink_bsteering_event_t;
-
-/**
- * Parameters that can be configured by userspace to control the band
- * steering events.
- */
-typedef struct ieee80211_bsteering_param_t {
-    /* Amount of time a client has to be idle under normal (no overload)
-       conditions before it becomes a candidate for steering.*/
-    u_int32_t inactivity_timeout_normal;
-    /*  Amount of time a client has to be idle under overload conditions
-        before it becomes a candidate for steering.*/
-    u_int32_t inactivity_timeout_overload;
-    /* Frequency (in seconds) at which the client inactivity staus should
-       be checked. */
-    u_int32_t inactivity_check_period;
-    /* Frequency (in seconds) at which the medium utilization should be
-       measured. */
-    u_int32_t utilization_sample_period;
-    /* The number of samples over which the medium utilization should be
-       averaged before being reported.*/
-    u_int32_t utilization_average_num_samples;
-    /* Two RSSI values for which to generate threshold crossing events for
-       an idle client. Such events are generated when the thresholds are
-       crossed in either direction.*/
-    u_int32_t inactive_rssi_xing_high_threshold;
-    u_int32_t inactive_rssi_xing_low_threshold;
-    /* The RSSI value for which to generate threshold crossing events for
-        both active and idle clients. This value should generally be less
-        than inactive_rssi_xing_low_threshold.*/
-    u_int32_t low_rssi_crossing_threshold;
-    /* The lower-bound Tx rate value (Kbps) for which to generate threshold crossing events
-       if the Tx rate for a client decreases below this value. */
-    u_int32_t low_tx_rate_crossing_threshold;
-    /* The upper-bound Tx rate (Kbps) value for which to generate threshold crossing events
-       if the Tx rate for a client increases above this value. */
-    u_int32_t high_tx_rate_crossing_threshold;
-    /* The RSSI value for which to generate threshold crossing events for
-       active clients. Used in conjunction with the rate crossing events
-       to determine if STAs should be downgraded. */
-    u_int32_t low_rate_rssi_crossing_threshold;
-    /* The RSSI value for which to generate threshold crossing events for
-       active clients. Used in conjunction with the rate crossing events
-       to determine if STAs should be upgraded. */
-    u_int32_t high_rate_rssi_crossing_threshold;
-} ieee80211_bsteering_param_t;
-
-/**
- * Parameters that are used to configure lmac part band steering logic.
- * Currently it contains inactivity related parameters.
- */
-typedef struct ieee80211_bsteering_lmac_param_t {
-    /* Frequency (in seconds) at which the client inactivity staus should
-       be checked.*/
-    u_int32_t inactivity_check_period;
-
-    /* Number of check periods a client has to be idle under normal (no overload)
-       conditions before it becomes a candidate for steering.*/
-    u_int32_t inactivity_threshold_normal;
-
-    /* Number of check periods a client has to be idle under overload conditions
-       before it becomes a candidate for steering.*/
-    u_int32_t inactivity_threshold_overload;
-} ieee80211_bsteering_lmac_param_t;
-
-/**
- * Parameters that must be specified to trigger an RSSI measurement by
- * sending QoS Null Data Packets and examining the RSSI from the ACK.
- */
-typedef struct ieee80211_bsteering_rssi_req_t {
-    /* The address of the client to measure.*/
-    u_int8_t sender_addr[IEEE80211_ADDR_LEN];
-    /* The number of consecutive measurements to make. This must be
-       at least 1.*/
-    u_int16_t num_measurements;
-} ieee80211_bsteering_rssi_req_t;
-
-/**
- * Parameters that can be configured by userspace to enable logging of
- * intermediate results via events to userspace.
- */
-typedef struct ieee80211_bsteering_dbg_param_t {
-    /* Whether logging of the raw channel utilization data is enabled.*/
-    u_int8_t  raw_chan_util_log_enable:1;
-    /* Whether logging of the raw RSSI measurement is enabled.*/
-    u_int8_t  raw_rssi_log_enable:1;
-    /* Whether logging of the raw Tx rate measurement is enabled.*/
-    u_int8_t raw_tx_rate_log_enable:1;
-} ieee80211_bsteering_dbg_param_t;
-
-/**
- * Event types that are asynchronously generated by the band steering
- * module.
- */
-typedef enum {
-    /* Indication of utilization of the channel.*/
-    ATH_EVENT_BSTEERING_CHAN_UTIL = 1,
-    /* Indication that a probe request was received from a client.*/
-    ATH_EVENT_BSTEERING_PROBE_REQ = 2,
-    /* Indicated that a STA associated.*/
-    ATH_EVENT_BSTEERING_NODE_ASSOCIATED = 3,
-    /* Indication that an authentication frame was sent with a failure
-        status code.*/
-    ATH_EVENT_BSTEERING_TX_AUTH_FAIL = 4,
-    /* Indication that a client changes from active to inactive or
-       vice versa.*/
-    ATH_EVENT_BSTEERING_CLIENT_ACTIVITY_CHANGE = 5,
-    /* Indication when the client RSSI crosses above or below the
-       configured threshold.*/
-    ATH_EVENT_BSTEERING_CLIENT_RSSI_CROSSING = 6,
-    /* Indication when a requested RSSI measurement for a specific
-       client is available.*/
-    ATH_EVENT_BSTEERING_CLIENT_RSSI_MEASUREMENT = 7,
-    /* Indication when a 802.11k radio resource management report
-       is received from a client.*/
-    ATH_EVENT_BSTEERING_RRM_REPORT = 8,
-    /* Indication when a 802.11v wireless network management (WNM) message
-       is received from a client.*/
-    ATH_EVENT_BSTEERING_WNM_EVENT = 9,
-    /* Indication when the client Tx rate crosses above or below the
-       configured threshold. */
-    ATH_EVENT_BSTEERING_CLIENT_TX_RATE_CROSSING = 10,
-    /* Indication when a VAP has stopped.
-       Note: This is not the same as a VAP being brought down. This will be seen
-       in RE mode when the uplink STA interface disassociates. */
-    ATH_EVENT_BSTEERING_VAP_STOP = 11,
-    /* Indication when Tx power changes on a VAP. */
-    ATH_EVENT_BSTEERING_TX_POWER_CHANGE = 12,
-    /*  Events generated solely for debugging purposes. These are not
-        intended for direct consumption by any algorithm components but are
-        here to facilitate logging the raw data.*/
-    ATH_EVENT_BSTEERING_DBG_CHAN_UTIL = 32,
-    /* Raw RSSI measurement event used to facilitate logging.*/
-    ATH_EVENT_BSTEERING_DBG_RSSI = 33,
-    /* Raw Tx rate measurement event used to facilitate logging.*/
-    ATH_EVENT_BSTEERING_DBG_TX_RATE = 34,
-} ATH_BSTEERING_EVENT;
-
-#undef IEEE80211_ADDR_LEN
-#endif /* _BAND_STEERING__ */
diff --git a/include/wmi.h b/include/wmi.h
index 076f59c..4f4c399 100644
--- a/include/wmi.h
+++ b/include/wmi.h
@@ -165,7 +165,7 @@ enum wmi_id {
     WMI_EVENT_IF_RUNNING_STA,   /**< IF_RUNNING STA */
     WMI_EVENT_IF_NOT_RUNNING_STA,   /**< IF_NOT_RUNNING STA */
     WMI_EVENT_GEN_IE,           /**< Pass IE */
-    //WMI_EVENT_ASSOC_REQ_IE,     /**< Pass Assoc Req IE */
+    WMI_EVENT_ASSOC_REQ_IE,     /**< Pass Assoc Req IE */
     WMI_EVENT_IW_CUSTOM,        /**< IW_CUSTOM */
     WMI_EVENT_IW_ASSOCREQIE,    /**< IW_ASSOCREQIE for Probe request frames */
     WMI_EVENT_MIC_FAIL,
diff --git a/target/linux/build/partner-platform/thin_driver/Makefile b/target/linux/build/partner-platform/thin_driver/Makefile
index 0f6bb09..9812ffa 100644
--- a/target/linux/build/partner-platform/thin_driver/Makefile
+++ b/target/linux/build/partner-platform/thin_driver/Makefile
@@ -84,9 +84,6 @@ EXTRA_CFLAGS    	+= -DTARGET_STANDALONE=1
 else
 EXTRA_CFLAGS    	+= -DTARGET_STANDALONE=0
 endif
-ifneq ($(strip ${UMAC_SUPPORT_VI_DBG}),1)
-EXTRA_CFLAGS    	+= -DUMAC_SUPPORT_VI_DBG=0
-endif
 ifneq ($(strip ${ATH_C3_WAR}),1)
 EXTRA_CFLAGS    	+= -DATH_C3_WAR=0
 endif
diff --git a/target/linux/build/wasp/Makefile b/target/linux/build/wasp/Makefile
index e66c209..ed3534f 100644
--- a/target/linux/build/wasp/Makefile
+++ b/target/linux/build/wasp/Makefile
@@ -1,3 +1,6 @@
+
+PWD             = $(shell pwd)
+
 ifeq (${OFFLOAD_CFG},)
     OFFLOAD_CFG=default
 endif
@@ -6,7 +9,8 @@ CC			= $(TOOLPREFIX)gcc
 
 TGT_PATH= ../../../
 
-include $(PWD)/Kbuild.$(OFFLOAD_CFG)
+obj-m   += thin_driver/
+obj-m   += hif_$(BUS)/
 
 define cleanup_files
 	@find $(1) -type f -name "*.o" -exec rm -vf {} ';'; 
@@ -15,14 +19,11 @@ define cleanup_files
 endef
 
 ifeq ($(KERNELRELEASE),)
-KERNELVER   ?= $(shell uname -r)
-KERNELPATH	?= /lib/modules/$(KERNELVER)/build/
-PWD	     	?= $(shell pwd)
-MODULEPATH  ?= $(DESTDIR)/lib/modules/$(KERNELVER)/offload/
 
 all: 
 	echo "Building full offload target" 
-	$(MAKE) -C $(KERNELPATH) SUBDIRS=$(shell pwd) modules
+	export WLAN_DRIVER_PATH=$(WLAN_DRIVER_PATH)
+	$(MAKE) -C $(KERNELPATH) ARCH=$(ARCH) CROSS_COMPILE=$(TOOLPREFIX) SUBDIRS=$(PWD) BOOT=flash HIF=$(BUS) modules
 
 clean:
 	$(MAKE) -C $(KERNELPATH) SUBDIRS=$(shell pwd) clean
diff --git a/target/linux/build/wasp/hif_gmac/Makefile b/target/linux/build/wasp/hif_gmac/Makefile
index de18a5d..cce8e72 100644
--- a/target/linux/build/wasp/hif_gmac/Makefile
+++ b/target/linux/build/wasp/hif_gmac/Makefile
@@ -1,6 +1,8 @@
+PWD = $(SUBDIRS)/hif_gmac
+
 OFFLOAD_HIF_GMAC = ../../../hif/gmac/
 
-OFFLOAD_TGT_INC     = ../../../
+OFFLOAD_TGT_INC     = ../../../..
 OFFLOAD_DRV_INC     = $(OFFLOAD_TGT_INC)/../
 OFFLOAD_STACK_INC   = $(OFFLOAD_DRV_INC)../
 OFFLOAD_HIF_INC     = ../../hif
@@ -10,6 +12,7 @@ EXTRA_CFLAGS    += -I$(PWD)/$(OFFLOAD_DRV_INC)/include/
 EXTRA_CFLAGS    += -I$(PWD)/$(OFFLOAD_TGT_INC)/linux/include/
 EXTRA_CFLAGS    += -I$(PWD)/$(OFFLOAD_HIF_INC)/gmac
 
+EXTRA_CFLAGS    += -DBUILD_PARTNER_PLATFORM
 
 ifeq ($(strip $(GMAC_FRAGMENT_SUPPORT)),1)
 EXTRA_CFLAGS    += -DGMAC_FRAGMENT_SUPPORT
diff --git a/target/linux/build/wasp/misc/Makefile b/target/linux/build/wasp/misc/Makefile
index c2f70f8..bef3310 100644
--- a/target/linux/build/wasp/misc/Makefile
+++ b/target/linux/build/wasp/misc/Makefile
@@ -8,7 +8,7 @@ EXTRA_CFLAGS    += -I$(PWD)/$(OFFLOAD_STACK_INC)/include
 EXTRA_CFLAGS    += -I$(PWD)/$(OFFLOAD_DRV_INC)/include/
 EXTRA_CFLAGS    += -I$(PWD)/$(OFFLOAD_TGT_INC)/linux/include/
 
-
+EXTRA_CFLAGS    += -DBUILD_PARTNER_PLATFORM
 
 obj-m          += xmiipsave.o
 xmiipsave-objs    := $(OFFLOAD_MISC)/xmiipsave.o
diff --git a/target/linux/build/wasp/thin_driver/Makefile b/target/linux/build/wasp/thin_driver/Makefile
index d338ef9..f73ac6d 100644
--- a/target/linux/build/wasp/thin_driver/Makefile
+++ b/target/linux/build/wasp/thin_driver/Makefile
@@ -1,11 +1,12 @@
+PWD = $(SUBDIRS)/thin_driver
 
-OFFLOAD_TGT_INC     = ../../../
+OFFLOAD_TGT_INC     = ../../../..
 OFFLOAD_DRV_INC     = $(OFFLOAD_TGT_INC)/../
 OFFLOAD_STACK_INC   = $(OFFLOAD_DRV_INC)../
 ACFG_INC            = $(OFFLOAD_DRV_INC)/../../apps/acfg
 
-OFFLOAD_THIN_INC    = ../../thin_driver
-OFFLOAD_HIF_INC     = ../../hif/
+OFFLOAD_THIN_INC    = ../../../thin_driver
+OFFLOAD_HIF_INC     = ../../../hif/
 
 OFFLOAD_THIN_DRV = ../../../thin_driver
 
@@ -23,6 +24,8 @@ EXTRA_CFLAGS    += -DATD_DEBUG_ENABLE
 
 EXTRA_CFLAGS    += -DWMI_RETRY=1
 
+EXTRA_CFLAGS    += -DBUILD_PARTNER_PLATFORM -DUMAC_SUPPORT_ACL
+
 ifeq ($(BUS), usb)
 EXTRA_CFLAGS    += -DNETDEV_ALLMULTI
 endif
@@ -36,17 +39,14 @@ else
 EXTRA_CFLAGS 		+= -I$(DRIVERS_WLAN_INC)
 endif
 EXTRA_CFLAGS    	+= $(COPTS)
-EXTRA_CFLAGS 		+= -I$(PWD)/$(DRIVERS_WLAN_INC) 
-EXTRA_CFLAGS        += -I$(PWD)/$(DRIVERS_WLAN_INC)/include 
-EXTRA_CFLAGS        += -I$(PWD)/$(DRIVERS_WLAN_INC)/include/sys 
-EXTRA_CFLAGS        += -I$(PWD)/$(DRIVERS_WLAN_INC)/os/linux/include 
-EXTRA_CFLAGS        += -I$(PWD)/$(DRIVERS_WLAN_INC)/lmac/ath_dev
-EXTRA_CFLAGS        += -I$(PWD)/$(DRIVERS_WLAN_INC)/adf/net/linux
+EXTRA_CFLAGS 		+= -I$(PWD)/$(DRIVERS_WLAN_INC)
+EXTRA_CFLAGS        += -I$(WLAN_DRIVER_PATH)/include
+EXTRA_CFLAGS        += -I$(WLAN_DRIVER_PATH)/include/sys
+EXTRA_CFLAGS        += -I$(WLAN_DRIVER_PATH)/os/linux/include
+EXTRA_CFLAGS        += -I$(WLAN_DRIVER_PATH)/lmac/ath_dev
+EXTRA_CFLAGS        += -I$(PWD)/../../../../../adf/net/linux
 EXTRA_CFLAGS    	+= -D_BIG_ENDIAN -D_BYTE_ORDER=_BIG_ENDIAN
 
-ifneq ($(strip ${ATH_SUPPORT_SPECTRAL}),1)
-EXTRA_CFLAGS    	+= -DATH_SUPPORT_SPECTRAL=0
-endif
 ifneq ($(strip ${ATH_WOW}),1)
 EXTRA_CFLAGS    	+= -DATH_WOW=0
 endif
@@ -82,9 +82,6 @@ EXTRA_CFLAGS    	+= -DTARGET_STANDALONE=1
 else
 EXTRA_CFLAGS    	+= -DTARGET_STANDALONE=0
 endif
-ifneq ($(strip ${UMAC_SUPPORT_VI_DBG}),1)
-EXTRA_CFLAGS    	+= -DUMAC_SUPPORT_VI_DBG=0
-endif
 ifneq ($(strip ${ATH_C3_WAR}),1)
 EXTRA_CFLAGS    	+= -DATH_C3_WAR=0
 endif
diff --git a/target/linux/hif/gmac/hif_gmac.c b/target/linux/hif/gmac/hif_gmac.c
index 81f3e26..e70eb1e 100644
--- a/target/linux/hif/gmac/hif_gmac.c
+++ b/target/linux/hif/gmac/hif_gmac.c
@@ -57,6 +57,8 @@ int gmac_dbg_mask = 0x0;
 struct gmac_softc ;
 static char *hst_if = "eth0";
 
+a_uint32_t rom_mode = 0x1;
+
 int __gmac_dev_event(struct notifier_block *nb, unsigned long event, 
                      void *dev);
 int __gmac_recv(struct sk_buff  *skb,  struct net_device  *dev,
@@ -1236,6 +1238,10 @@ void gmac_module_exit(void ){
     return; 
 }
 
+int hif_rom_mode(void)
+{
+    return rom_mode;
+}
 EXPORT_SYMBOL(hif_init);
 EXPORT_SYMBOL(hif_cleanup);
 EXPORT_SYMBOL(hif_start);
@@ -1254,10 +1260,12 @@ EXPORT_SYMBOL(hif_gmac_vlan_wlan_rx);
 EXPORT_SYMBOL(hif_init_dbglog);
 EXPORT_SYMBOL(hif_register_for_dbglog);
 EXPORT_SYMBOL(hif_send_dbglog);
+EXPORT_SYMBOL(hif_rom_mode);
 
 module_init(gmac_module_init);
 module_exit(gmac_module_exit);
 module_param(hst_if, charp, 0600);
+module_param(rom_mode, int, 0600);
 MODULE_PARM_DESC(hst_if, "Interface used to connect host ");
 MODULE_AUTHOR("Atheros Communications, Inc.");
 MODULE_DESCRIPTION("Atheros Device Module");
diff --git a/target/linux/thin_driver/atd/atd_appbr.c b/target/linux/thin_driver/atd/atd_appbr.c
index d7e18c1..254a28d 100644
--- a/target/linux/thin_driver/atd/atd_appbr.c
+++ b/target/linux/thin_driver/atd/atd_appbr.c
@@ -28,6 +28,10 @@
 #include <hif_api.h>
 #include <htc_api.h>
 #include <wmi_api.h>
+
+#include <ieee80211_external_config.h>
+#define EXTERNAL_USE_ONLY
+
 #include <atd_wsupp.h>
 #include <atd_hdr.h>
 #include <atd_cmd.h>
diff --git a/target/linux/thin_driver/atd/atd_byp.c b/target/linux/thin_driver/atd/atd_byp.c
index 353e1c6..5208c49 100644
--- a/target/linux/thin_driver/atd/atd_byp.c
+++ b/target/linux/thin_driver/atd/atd_byp.c
@@ -31,6 +31,10 @@
 #include <hif_api.h>
 #include <htc_api.h>
 #include <wmi_api.h>
+
+#include <ieee80211_external_config.h>
+#define EXTERNAL_USE_ONLY
+
 #include <atd_wsupp.h>
 #include <atd_hdr.h>
 #include <atd_cmd.h>
diff --git a/target/linux/thin_driver/atd/atd_cfg.c b/target/linux/thin_driver/atd/atd_cfg.c
index 862a3ae..dd5a6e5 100644
--- a/target/linux/thin_driver/atd/atd_cfg.c
+++ b/target/linux/thin_driver/atd/atd_cfg.c
@@ -28,8 +28,10 @@
 #include <hif_api.h>
 #include <htc_api.h>
 #include <wmi_api.h>
+
+#include <ieee80211_external_config.h>
+#define EXTERNAL_USE_ONLY
 #include <acfg_api_types.h>
-#include <acfg_drv_if.h>
 #include <atd_hdr.h>
 #include <atd_cmd.h>
 #include <atd_event.h>
@@ -49,7 +51,7 @@ static int
 atd_tgt_acfg2ieee(a_uint16_t param)
 {
     a_uint16_t value;
-    
+
     switch (param)
     {
         case ACFG_PARAM_VAP_SHORT_GI:
@@ -88,30 +90,12 @@ atd_tgt_acfg2ieee(a_uint16_t param)
         case ACFG_PARAM_NO_EDGE_CH:
             value = IEEE80211_PARAM_NO_EDGE_CH;
             break;
-        case ACFG_PARAM_VAP_IND:
-            value = IEEE80211_PARAM_VAP_IND;
-            break;
         case ACFG_PARAM_WPS:
             value = IEEE80211_PARAM_WPS;
             break;
         case ACFG_PARAM_EXTAP:
             value = IEEE80211_PARAM_EXTAP;
             break;
-        case ACFG_PARAM_TDLS_ENABLE:
-            value = IEEE80211_PARAM_TDLS_ENABLE;
-            break;
-        case ACFG_PARAM_SET_TDLS_RMAC:
-            value = IEEE80211_PARAM_SET_TDLS_RMAC;
-            break;
-        case ACFG_PARAM_CLR_TDLS_RMAC:
-            value = IEEE80211_PARAM_CLR_TDLS_RMAC;
-            break;
-        case ACFG_PARAM_TDLS_MACADDR1:
-            value = IEEE80211_PARAM_TDLS_MACADDR1;
-            break;
-        case ACFG_PARAM_TDLS_MACADDR2:
-            value = IEEE80211_PARAM_TDLS_MACADDR2;
-            break;
         case ACFG_PARAM_SW_WOW:
             value = IEEE80211_PARAM_SW_WOW;
             break;
@@ -124,27 +108,18 @@ atd_tgt_acfg2ieee(a_uint16_t param)
         case ACFG_PARAM_SCANBAND:
             value = IEEE80211_PARAM_SCAN_BAND;
             break;
-        case ACFG_PARAM_WMMPARAMS_CWMIN:
-            value = IEEE80211_WMMPARAMS_CWMIN;
-            break;			
-        case ACFG_PARAM_WMMPARAMS_CWMAX:
-            value = IEEE80211_WMMPARAMS_CWMAX;
-            break;	       
-		case ACFG_PARAM_WMMPARAMS_AIFS:
-            value = IEEE80211_WMMPARAMS_AIFS;
-            break;					
         case ACFG_PARAM_WMMPARAMS_TXOPLIMIT:
             value = IEEE80211_WMMPARAMS_TXOPLIMIT;
-            break;	
+            break;
         case ACFG_PARAM_WMMPARAMS_ACM:
             value = IEEE80211_WMMPARAMS_ACM;
-            break;	
+            break;
         case ACFG_PARAM_WMMPARAMS_NOACKPOLICY:
             value = IEEE80211_WMMPARAMS_NOACKPOLICY;
-            break;								
+            break;
         case ACFG_PARAM_PROXYARP_CAP:
             value = IEEE80211_PARAM_PROXYARP_CAP;
-            break;					
+            break;
 		case ACFG_PARAM_HIDE_SSID:
             value = IEEE80211_PARAM_HIDESSID;
             break;
@@ -157,9 +132,6 @@ atd_tgt_acfg2ieee(a_uint16_t param)
         case ACFG_PARAM_APBRIDGE:
             value = IEEE80211_PARAM_APBRIDGE;
             break;
-        case ACFG_PARAM_AMPDU:
-            value = IEEE80211_PARAM_AMPDU;
-            break;
         case ACFG_PARAM_DGAF_DISABLE:
             value = IEEE80211_PARAM_DGAF_DISABLE;
             break;
@@ -184,56 +156,56 @@ atd_tgt_acfg2ieee(a_uint16_t param)
             break;
         case ACFG_PARAM_WNM_BSSMAX:
             value = IEEE80211_PARAM_WNM_BSS_CAP;
-            break;                      
+            break;
         case ACFG_PARAM_WNM_TFS:
             value = IEEE80211_PARAM_WNM_TFS_CAP;
-            break;                      
+            break;
         case ACFG_PARAM_WNM_TIM:
             value = IEEE80211_PARAM_WNM_TIM_CAP;
-            break;                      
+            break;
         case ACFG_PARAM_WNM_SLEEP:
             value = IEEE80211_PARAM_WNM_SLEEP_CAP;
-            break;                      
+            break;
 #endif
         case ACFG_PARAM_CHANBW:
             value = IEEE80211_PARAM_CHANBW;
             break;
         case ACFG_PARAM_BURST:
             value = IEEE80211_PARAM_BURST;
-            break;                      
+            break;
         case ACFG_PARAM_AMSDU:
             value = IEEE80211_PARAM_AMSDU;
-            break;                      
+            break;
         case ACFG_PARAM_MAXSTA:
             value = IEEE80211_PARAM_MAXSTA;
             break;
-        case ACFG_PARAM_SETADDBAOPER:         
-            value = IEEE80211_PARAM_SETADDBAOPER;    
-            break;                      
-        case ACFG_PARAM_OPMODE_NOTIFY:        
+        case ACFG_PARAM_SETADDBAOPER:
+            value = IEEE80211_PARAM_SETADDBAOPER;
+            break;
+        case ACFG_PARAM_OPMODE_NOTIFY:
             value = IEEE80211_PARAM_OPMODE_NOTIFY;
-            break;                      
-        case ACFG_PARAM_WEP_TKIP_HT:          
+            break;
+        case ACFG_PARAM_WEP_TKIP_HT:
             value = IEEE80211_PARAM_WEP_TKIP_HT;
-            break;                      
-        case ACFG_PARAM_CWM_ENABLE:           
+            break;
+        case ACFG_PARAM_CWM_ENABLE:
             value = IEEE80211_PARAM_CWM_ENABLE;
-            break;                      
-        case ACFG_PARAM_MAX_AMPDU:            
+            break;
+        case ACFG_PARAM_MAX_AMPDU:
             value = IEEE80211_PARAM_MAX_AMPDU;
-            break;                      
-        case ACFG_PARAM_VHT_MAX_AMPDU:        
-            value = IEEE80211_PARAM_VHT_MAX_AMPDU;   
-            break;                      
-        case ACFG_PARAM_ENABLE_RTSCTS:        
+            break;
+        case ACFG_PARAM_VHT_MAX_AMPDU:
+            value = IEEE80211_PARAM_VHT_MAX_AMPDU;
+            break;
+        case ACFG_PARAM_ENABLE_RTSCTS:
             value = IEEE80211_PARAM_ENABLE_RTSCTS;
-            break;                      
+            break;
 
         default:
             value = param;
             break;
     }
-    return value;    
+    return value;
 }
 
 /**************WMI function handler ****************************/
@@ -291,11 +263,8 @@ ATD_TGT_CMD_PROTOTYPE(atd_tgt_set_rate);
 ATD_TGT_CMD_PROTOTYPE(atd_tgt_get_stats);
 ATD_TGT_CMD_PROTOTYPE(atd_tgt_set_powmgmt);
 ATD_TGT_CMD_PROTOTYPE(atd_tgt_get_powmgmt);
-ATD_TGT_CMD_PROTOTYPE(atd_tgt_set_reg);
-ATD_TGT_CMD_PROTOTYPE(atd_tgt_get_reg);
 ATD_TGT_CMD_PROTOTYPE(atd_tgt_tx99tool);
 ATD_TGT_CMD_PROTOTYPE(atd_tgt_set_hwaddr);
-ATD_TGT_CMD_PROTOTYPE(atd_tgt_wsupp_request);
 ATD_TGT_CMD_PROTOTYPE(atd_tgt_set_wmmparams);
 ATD_TGT_CMD_PROTOTYPE(atd_tgt_get_wmmparams);
 ATD_TGT_CMD_PROTOTYPE(atd_tgt_nawds_config);
@@ -329,10 +298,10 @@ ATD_TGT_CMD_PROTOTYPE(atd_tgt_get_profile);
 ATD_TGT_CMD_PROTOTYPE(atd_tgt_phyerr);
 ATD_TGT_CMD_PROTOTYPE(atd_tgt_set_vap_vendor_param);
 ATD_TGT_CMD_PROTOTYPE(atd_tgt_get_vap_vendor_param);
-ATD_TGT_CMD_PROTOTYPE(atd_tgt_set_chnwidthswitch); 
-ATD_TGT_CMD_PROTOTYPE(atd_tgt_set_atf_ssid); 
-ATD_TGT_CMD_PROTOTYPE(atd_tgt_set_atf_sta); 
-ATD_TGT_CMD_PROTOTYPE(atd_tgt_set_country); 
+ATD_TGT_CMD_PROTOTYPE(atd_tgt_set_chnwidthswitch);
+ATD_TGT_CMD_PROTOTYPE(atd_tgt_set_atf_ssid);
+ATD_TGT_CMD_PROTOTYPE(atd_tgt_set_atf_sta);
+ATD_TGT_CMD_PROTOTYPE(atd_tgt_set_country);
 
 wmi_dispatch_entry_t  wmidispatchentry[] =
 {
@@ -365,7 +334,7 @@ wmi_dispatch_entry_t  wmidispatchentry[] =
     { atd_tgt_get_ath_stats,        WMI_CMD_ATH_STATS_GET     , 0 },
     { atd_tgt_clr_ath_stats,        WMI_CMD_ATH_STATS_CLR     , 0 },
     { atd_tgt_get_scan_space,       WMI_CMD_SCAN_SPACE_GET    , 0 },
-    { atd_tgt_get_range,            WMI_CMD_RANGE_GET         , 0 },  
+    { atd_tgt_get_range,            WMI_CMD_RANGE_GET         , 0 },
     { atd_tgt_set_freq,             WMI_CMD_FREQ_SET          , 0 },
     { atd_tgt_get_freq,             WMI_CMD_FREQ_GET          , 0 },
     { atd_tgt_set_phymode,          WMI_CMD_PHYMODE_SET       , 0 },
@@ -383,25 +352,25 @@ wmi_dispatch_entry_t  wmidispatchentry[] =
     { atd_tgt_get_stats,            WMI_CMD_STATS_GET         , 0 },
     { atd_tgt_set_powmgmt,          WMI_CMD_POWMGMT_SET       , 0 },
     { atd_tgt_get_powmgmt,          WMI_CMD_POWMGMT_GET       , 0 },
-    { atd_tgt_set_reg,              WMI_CMD_REG_SET           , 0 },
-    { atd_tgt_get_reg,              WMI_CMD_REG_GET           , 0 },
+    { NULL,                         WMI_CMD_REG_SET           , 0 },
+    { NULL,                         WMI_CMD_REG_GET           , 0 },
     { atd_tgt_tx99tool,             WMI_CMD_TX99TOOL          , 0 },
     { atd_tgt_set_hwaddr,           WMI_CMD_HWADDR_SET        , 0 },
     { atd_tgt_doth_chswitch,        WMI_CMD_DOTH_CHSW         , 0 },
     { atd_tgt_addmac,               WMI_CMD_ADDMAC            , 0 },
     { atd_tgt_delmac,               WMI_CMD_DELMAC            , 0 },
     { atd_tgt_kickmac,              WMI_CMD_KICKMAC           , 0 },
-    { atd_tgt_wsupp_request,        WMI_CMD_WSUPP_INIT        , 0 },
-    { atd_tgt_wsupp_request,        WMI_CMD_WSUPP_FINI        , 0 },
-    { atd_tgt_wsupp_request,        WMI_CMD_WSUPP_ADD_IF      , 0 },
-    { atd_tgt_wsupp_request,        WMI_CMD_WSUPP_REMOVE_IF   , 0 },
-    { atd_tgt_wsupp_request,        WMI_CMD_WSUPP_ADD_NW      , 0 },
-    { atd_tgt_wsupp_request,        WMI_CMD_WSUPP_REMOVE_NW   , 0 },
-    { atd_tgt_wsupp_request,        WMI_CMD_WSUPP_SET_NETWORK , 0 },
-    { atd_tgt_wsupp_request,        WMI_CMD_WSUPP_GET_NETWORK , 0 },
-    { atd_tgt_wsupp_request,        WMI_CMD_WSUPP_LIST_NETWORK, 0 },
-    { atd_tgt_wsupp_request,        WMI_CMD_WSUPP_SET_WPS     , 0 },
-    { atd_tgt_wsupp_request,        WMI_CMD_WSUPP_SET         , 0 },
+    { NULL,                         WMI_CMD_WSUPP_INIT        , 0 },
+    { NULL,                         WMI_CMD_WSUPP_FINI        , 0 },
+    { NULL,                         WMI_CMD_WSUPP_ADD_IF      , 0 },
+    { NULL,                         WMI_CMD_WSUPP_REMOVE_IF   , 0 },
+    { NULL,                         WMI_CMD_WSUPP_ADD_NW      , 0 },
+    { NULL,                         WMI_CMD_WSUPP_REMOVE_NW   , 0 },
+    { NULL,                         WMI_CMD_WSUPP_SET_NETWORK , 0 },
+    { NULL,                         WMI_CMD_WSUPP_GET_NETWORK , 0 },
+    { NULL,                         WMI_CMD_WSUPP_LIST_NETWORK, 0 },
+    { NULL,                         WMI_CMD_WSUPP_SET_WPS     , 0 },
+    { NULL,                         WMI_CMD_WSUPP_SET         , 0 },
 	{ atd_tgt_set_wmmparams,        WMI_CMD_WMMPARAMS_SET     , 0 },
 	{ atd_tgt_get_wmmparams,        WMI_CMD_WMMPARAMS_GET     , 0 },
     { atd_tgt_nawds_config,         WMI_CMD_NAWDS_CONFIG      , 0 },
@@ -432,10 +401,10 @@ wmi_dispatch_entry_t  wmidispatchentry[] =
     { atd_tgt_phyerr,               WMI_CMD_PHYERR            , 0 },
     { atd_tgt_set_vap_vendor_param, WMI_CMD_VAP_VENDOR_PARAM_SET, 0},
     { atd_tgt_get_vap_vendor_param, WMI_CMD_VAP_VENDOR_PARAM_GET, 0},
-    { atd_tgt_set_chnwidthswitch,   WMI_CMD_CHNWIDTHSWITCH_SET, 0}, 
-    { atd_tgt_set_atf_ssid,         WMI_CMD_SET_ATF_SSID, 0}, 
-    { atd_tgt_set_atf_sta,          WMI_CMD_SET_ATF_STA, 0}, 
-    { atd_tgt_set_country,          WMI_CMD_COUNTRY_SET, 0}, 
+    { atd_tgt_set_chnwidthswitch,   WMI_CMD_CHNWIDTHSWITCH_SET, 0},
+    { atd_tgt_set_atf_ssid,         WMI_CMD_SET_ATF_SSID, 0},
+    { atd_tgt_set_atf_sta,          WMI_CMD_SET_ATF_STA, 0},
+    { atd_tgt_set_country,          WMI_CMD_COUNTRY_SET, 0},
 };
 
 extern atd_tgt_dev_t     *g_atd_dev;
@@ -443,7 +412,7 @@ extern atd_tgt_dev_t     *g_atd_dev;
 
 /**************WMI function handler end ******************************/
 
-void   
+void
 atd_tgt_wmi_init(atd_tgt_dev_t * atsc)
 {
 
@@ -457,14 +426,14 @@ atd_tgt_wmi_init(atd_tgt_dev_t * atsc)
 
     memset(wmidispatchtable, 0, sizeof(wmi_dispatch_table_t));
 
-    wmidispatchtable->noentries = 
+    wmidispatchtable->noentries =
         wmi_dispatch_entry_count(wmidispatchentry);
 
     wmidispatchtable->disp_entry = &wmidispatchentry[0];
     wmidispatchtable->ctx = atsc;
 
 
-    
+
     atsc->wmi_handle = wmi_init((void *)atsc->htc_handle);
 
     wmi_register_disp_table(atsc->wmi_handle, wmidispatchtable);
@@ -480,8 +449,8 @@ atd_tgt_wmi_set_stopflag(wmi_handle_t wmi_handle, a_uint8_t val)
 
 
 /* target WMI command handler */
-void 
-handle_echo_command(void *ctx, a_uint16_t cmdid, 
+void
+handle_echo_command(void *ctx, a_uint16_t cmdid,
                     a_uint8_t *buffer, a_int32_t len)
 {
         atd_tgt_dev_t *atsc = (atd_tgt_dev_t *)ctx;
@@ -492,24 +461,24 @@ handle_echo_command(void *ctx, a_uint16_t cmdid,
 }
 
 
-void 
+void
 atd_tgt_radio_queury(void *ctx, a_uint16_t cmdid,
                      a_uint8_t *buffer, a_int32_t len)
 {
     a_status_t status = 0;
     atd_tgt_dev_t *atsc = (atd_tgt_dev_t *)ctx;
     atd_radio_query_resp_t resp;
-    
+
     int i;
     struct net_device *netdev;
-    
+
     atd_trace(ATD_DEBUG_FUNCTRACE, ("cmd %d   ",
                     cmdid));
 
     for(i=0;i< atsc->wifi_cnt ;i++){
         if(atsc->wifi_list[i] != NULL){
             netdev = atsc->wifi_list[i]->netdev;
-            memcpy(&resp.mac_addr[i][0], netdev->dev_addr, 
+            memcpy(&resp.mac_addr[i][0], netdev->dev_addr,
                     ACFG_MACADDR_LEN);
 
             memcpy(&resp.ifname[i][0],netdev->name,ACFG_MAX_IFNAME);
@@ -524,12 +493,12 @@ atd_tgt_radio_queury(void *ctx, a_uint16_t cmdid,
 
 }
 
-a_status_t 
-atd_tgt_set_vap_index (atd_tgt_wifi_t * wifisc, 
-                       atd_tgt_vap_t * vap) 
-{ 
+a_status_t
+atd_tgt_set_vap_index (atd_tgt_wifi_t * wifisc,
+                       atd_tgt_vap_t * vap)
+{
     int i ;
-    
+
     for (i = 0; i< MAX_VAP_SUPPORTED; i++) {
         if (wifisc->vap_list[i] == NULL) {
             wifisc->vap_list[i] = vap ;
@@ -548,8 +517,8 @@ atd_tgt_set_vap_index (atd_tgt_wifi_t * wifisc,
 
     return A_STATUS_OK;
 }
-void 
-atd_tgt_vap_open(void *ctx, a_uint16_t cmdid, 
+void
+atd_tgt_vap_open(void *ctx, a_uint16_t cmdid,
                     a_uint8_t *buffer, a_int32_t len)
 {
     a_status_t status = A_STATUS_OK;
@@ -557,7 +526,7 @@ atd_tgt_vap_open(void *ctx, a_uint16_t cmdid,
     atd_tgt_dev_t *atsc = (atd_tgt_dev_t *)ctx;
     atd_tgt_wifi_t *wifisc =NULL;
     atd_tgt_vap_t * vap;
- 
+
 
     atd_trace(ATD_DEBUG_FUNCTRACE,(" cmd %d   ", \
                 cmdid));
@@ -595,10 +564,10 @@ atd_tgt_vap_open(void *ctx, a_uint16_t cmdid,
 #endif
 
 fail:
-    wmi_cmd_rsp(atsc->wmi_handle, cmdid, status, NULL, 0); 
+    wmi_cmd_rsp(atsc->wmi_handle, cmdid, status, NULL, 0);
 }
-void 
-atd_tgt_vap_close(void *ctx, a_uint16_t cmdid, 
+void
+atd_tgt_vap_close(void *ctx, a_uint16_t cmdid,
                     a_uint8_t *buffer, a_int32_t len)
 {
     a_status_t status = A_STATUS_OK;
@@ -606,7 +575,7 @@ atd_tgt_vap_close(void *ctx, a_uint16_t cmdid,
     atd_tgt_dev_t *atsc = (atd_tgt_dev_t *)ctx;
     atd_tgt_wifi_t *wifisc =NULL;
     atd_tgt_vap_t * vap;
- 
+
 
     atd_trace(ATD_DEBUG_FUNCTRACE,(" cmd %d   ", \
                 cmdid));
@@ -648,7 +617,7 @@ fail:
 }
 
 
-void atd_tgt_vap_create(void *ctx, a_uint16_t cmdid, 
+void atd_tgt_vap_create(void *ctx, a_uint16_t cmdid,
                         a_uint8_t *buffer, a_int32_t len)
 {
     atd_vap_create_rsp_t vaprsp;
@@ -668,7 +637,7 @@ void atd_tgt_vap_create(void *ctx, a_uint16_t cmdid,
     atd_assert(len >= sizeof(atd_vap_create_cmd_t));
 
     vapcmd = (atd_vap_create_cmd_t *) buffer;
-    
+
     atd_trace(ATD_DEBUG_CFG,("radio%d:cmd.icp_flags%x cmd.icp_opmode%x \
                 name %s  ", vapcmd->wifi_index, ntohs(vapcmd->icp_flags),\
                 ntohs(vapcmd->icp_opmode), &vapcmd->icp_name[0]));
@@ -718,11 +687,10 @@ void atd_tgt_vap_create(void *ctx, a_uint16_t cmdid,
         goto fail ;
     }
     vap->vap_netdev = netdev;
-
     if(vapcmd->wifi_index)
-	netdev->irq=0x80;
+        netdev->irq=0x80;
     else
-	netdev->irq=0;
+        netdev->irq=0;
 
     status = atd_tgt_set_vap_index(wifisc, vap);
     if(status != A_STATUS_OK){
@@ -743,12 +711,12 @@ void atd_tgt_vap_create(void *ctx, a_uint16_t cmdid,
 
 fail:
     atsc->dont_send_create_event = 0;
-    wmi_cmd_rsp(atsc->wmi_handle, cmdid, status, 
+    wmi_cmd_rsp(atsc->wmi_handle, cmdid, status,
                 (a_uint8_t *)&vaprsp , sizeof (atd_vap_create_rsp_t));
 }
 
-static void 
-atd_tgt_vap_delete(void *ctx, a_uint16_t cmdid, 
+static void
+atd_tgt_vap_delete(void *ctx, a_uint16_t cmdid,
                   a_uint8_t *buffer, a_int32_t len)
 {
     a_status_t status = A_STATUS_OK;
@@ -767,7 +735,7 @@ atd_tgt_vap_delete(void *ctx, a_uint16_t cmdid,
     atdhdr  = (atd_hdr_t *) buffer;
 
 
-    atd_trace((ATD_DEBUG_FUNCTRACE | ATD_DEBUG_CFG), (" uuuuu radio %d vap %d ", 
+    atd_trace((ATD_DEBUG_FUNCTRACE | ATD_DEBUG_CFG), (" uuuuu radio %d vap %d ",
               atdhdr->wifi_index, atdhdr->vap_index ));
 
     wifisc = atsc->wifi_list[atdhdr->wifi_index];
@@ -783,13 +751,13 @@ atd_tgt_vap_delete(void *ctx, a_uint16_t cmdid,
         goto fail;
     }
 
-   
-    /** 
+
+    /**
      * This will send the VAP Delete event to the HOST
      */
 
     status = netdev_ioctl(vap->vap_netdev, &ifr, SIOC80211IFDESTROY);
-    
+
 
     atd_assert(status == A_STATUS_OK);
 
@@ -798,8 +766,8 @@ fail:
 }
 
 
-void 
-atd_tgt_set_ssid(void *ctx, a_uint16_t cmdid, 
+void
+atd_tgt_set_ssid(void *ctx, a_uint16_t cmdid,
                   a_uint8_t *buffer, a_int32_t len)
 {
     a_status_t status = A_STATUS_OK;
@@ -818,13 +786,13 @@ atd_tgt_set_ssid(void *ctx, a_uint16_t cmdid,
                 cmdid));
 
     atd_assert(len >= (sizeof(atd_hdr_t) + sizeof(atd_ssid_t)));
-  
+
     atdhdr  = (atd_hdr_t *) buffer;
     ssid    = (atd_ssid_t  *) (buffer + sizeof(atd_hdr_t)) ;
 
     ssid->len = ntohl(ssid->len);
 
-    atd_trace(ATD_DEBUG_CFG, ("radio %d vap %d ssid %s len %d ", 
+    atd_trace(ATD_DEBUG_CFG, ("radio %d vap %d ssid %s len %d ",
               atdhdr->wifi_index, atdhdr->vap_index, &ssid->name[0],
               ntohl(ssid->len)));
 
@@ -836,7 +804,7 @@ atd_tgt_set_ssid(void *ctx, a_uint16_t cmdid,
     }
 
     vap    = wifisc->vap_list[atdhdr->vap_index];
- 
+
     if(vap == NULL){
         status = A_STATUS_ENXIO;
         goto fail;
@@ -846,12 +814,12 @@ atd_tgt_set_ssid(void *ctx, a_uint16_t cmdid,
 
 
     iwpdata->flags = 1;
-    iwpdata->length = ssid->len; 
+    iwpdata->length = ssid->len;
     memset(tmpssid, 0, (ACFG_MAX_SSID_LEN + 1));
     memcpy(tmpssid, ssid->name, ssid->len);
 
-    status = netdev_wext_handler(vap->vap_netdev, SIOCSIWESSID, &info, 
-                                 &iwreqdata, tmpssid); 
+    status = netdev_wext_handler(vap->vap_netdev, SIOCSIWESSID, &info,
+                                 &iwreqdata, tmpssid);
     if(status != A_STATUS_OK){
         atd_trace(ATD_DEBUG_CFG, ("ssid set erro \n"));
     }
@@ -861,8 +829,8 @@ fail:
 }
 
 
-void 
-atd_tgt_get_ssid(void *ctx, a_uint16_t cmdid, 
+void
+atd_tgt_get_ssid(void *ctx, a_uint16_t cmdid,
                   a_uint8_t *buffer, a_int32_t len)
 {
     a_status_t status = A_STATUS_OK;
@@ -881,7 +849,7 @@ atd_tgt_get_ssid(void *ctx, a_uint16_t cmdid,
                 cmdid));
 
     atd_assert(len >= sizeof(atd_hdr_t));
-  
+
     atdhdr  = (atd_hdr_t *) buffer;
 
 
@@ -902,22 +870,22 @@ atd_tgt_get_ssid(void *ctx, a_uint16_t cmdid,
 
 
 
-    status = netdev_wext_handler(vap->vap_netdev, SIOCGIWESSID, &info, 
-                                 &iwreqdata, tmpssid); 
-    
+    status = netdev_wext_handler(vap->vap_netdev, SIOCGIWESSID, &info,
+                                 &iwreqdata, tmpssid);
+
     ssid.len = htonl(iwpdata->length);
     memcpy(ssid.name, tmpssid, iwpdata->length);
 
     atd_trace(ATD_DEBUG_CFG, ("ssid  %s len %d ", \
               &ssid.name[0], iwpdata->length));
 fail:
-     
-    wmi_cmd_rsp(atsc->wmi_handle, cmdid, status, (a_uint8_t *)&ssid , 
+
+    wmi_cmd_rsp(atsc->wmi_handle, cmdid, status, (a_uint8_t *)&ssid ,
                 sizeof (atd_ssid_t));
 }
 
-void 
-atd_tgt_set_testmode(void *ctx, a_uint16_t cmdid, 
+void
+atd_tgt_set_testmode(void *ctx, a_uint16_t cmdid,
                   a_uint8_t *buffer, a_int32_t len)
 {
     a_status_t status = A_STATUS_OK;
@@ -931,12 +899,12 @@ atd_tgt_set_testmode(void *ctx, a_uint16_t cmdid,
     atd_vendor_t  *vendor;
     atd_testmode_t  *testmode;
     acfg_testmode_t  *test_mode;
-    
+
     atd_trace(ATD_DEBUG_FUNCTRACE,(" cmd %d ", \
                 cmdid));
 
     atd_assert(len >= (sizeof(atd_hdr_t) + sizeof(atd_testmode_t)));
-    
+
     atdhdr  = (atd_hdr_t *) buffer;
     testmode    = (atd_testmode_t  *) (buffer + sizeof(atd_hdr_t)) ;
 
@@ -986,16 +954,16 @@ atd_tgt_set_testmode(void *ctx, a_uint16_t cmdid,
 
 fail:
     wmi_cmd_rsp(atsc->wmi_handle, cmdid, status, NULL, 0);
-    
-    if (results)    
+
+    if (results)
         kfree(results);
 
     atd_trace(ATD_DEBUG_FUNCTRACE,(" End"));
 }
 
 
-void 
-atd_tgt_get_testmode(void *ctx, a_uint16_t cmdid, 
+void
+atd_tgt_get_testmode(void *ctx, a_uint16_t cmdid,
                   a_uint8_t *buffer, a_int32_t len)
 {
     a_status_t status = A_STATUS_OK;
@@ -1009,7 +977,7 @@ atd_tgt_get_testmode(void *ctx, a_uint16_t cmdid,
     atd_vendor_t  *vendor;
     atd_testmode_t  *testmode, resp;
     acfg_testmode_t  *test_mode;
-    
+
     atd_trace(ATD_DEBUG_FUNCTRACE,(" cmd %d ", \
                 cmdid));
 
@@ -1073,17 +1041,17 @@ atd_tgt_get_testmode(void *ctx, a_uint16_t cmdid,
     resp.rssi2 = htonl(test_mode->rssi2);
 
 fail:
-    wmi_cmd_rsp(atsc->wmi_handle, cmdid, status, 
+    wmi_cmd_rsp(atsc->wmi_handle, cmdid, status,
                 (a_uint8_t *)&resp, sizeof(atd_testmode_t));
-    
+
     if (results)
         kfree(results);
 
     atd_trace(ATD_DEBUG_FUNCTRACE,(" End"));
 }
 
-void 
-atd_tgt_get_rssi(void *ctx, a_uint16_t cmdid, 
+void
+atd_tgt_get_rssi(void *ctx, a_uint16_t cmdid,
                   a_uint8_t *buffer, a_int32_t len)
 {
     a_status_t status      = A_STATUS_OK;
@@ -1096,7 +1064,7 @@ atd_tgt_get_rssi(void *ctx, a_uint16_t cmdid,
     atd_hdr_t   *atdhdr;
     atd_vendor_t  *vendor;
     atd_rssi_t  *rssi;
-    
+
     atd_trace(ATD_DEBUG_FUNCTRACE,(" cmd %d ", \
                 cmdid));
 
@@ -1138,16 +1106,16 @@ atd_tgt_get_rssi(void *ctx, a_uint16_t cmdid,
     }
 
 fail:
-    wmi_cmd_rsp(atsc->wmi_handle, cmdid, status, results+sizeof(atd_vendor_t), 
+    wmi_cmd_rsp(atsc->wmi_handle, cmdid, status, results+sizeof(atd_vendor_t),
             req.u.data.length-sizeof(atd_vendor_t));
-    
+
     kfree(results);
 
     atd_trace(ATD_DEBUG_FUNCTRACE,(" End"));
 }
 
-void 
-atd_tgt_get_custdata(void *ctx, a_uint16_t cmdid, 
+void
+atd_tgt_get_custdata(void *ctx, a_uint16_t cmdid,
                   a_uint8_t *buffer, a_int32_t len)
 {
     a_status_t status      = A_STATUS_OK;
@@ -1160,7 +1128,7 @@ atd_tgt_get_custdata(void *ctx, a_uint16_t cmdid,
     atd_hdr_t   *atdhdr;
     atd_vendor_t  *vendor;
     atd_custdata_t  *custdata;
-    
+
     atd_trace(ATD_DEBUG_FUNCTRACE,(" cmd %d ", \
                 cmdid));
 
@@ -1202,16 +1170,16 @@ atd_tgt_get_custdata(void *ctx, a_uint16_t cmdid,
     }
 
 fail:
-    wmi_cmd_rsp(atsc->wmi_handle, cmdid, status, results+sizeof(atd_vendor_t), 
+    wmi_cmd_rsp(atsc->wmi_handle, cmdid, status, results+sizeof(atd_vendor_t),
             req.u.data.length-sizeof(atd_vendor_t));
-    
+
     kfree(results);
 
     atd_trace(ATD_DEBUG_FUNCTRACE,(" End"));
 }
 
-void 
-atd_tgt_set_vap_param(void *ctx, a_uint16_t cmdid, 
+void
+atd_tgt_set_vap_param(void *ctx, a_uint16_t cmdid,
                       a_uint8_t *buffer, a_int32_t len)
 {
 
@@ -1227,7 +1195,7 @@ atd_tgt_set_vap_param(void *ctx, a_uint16_t cmdid,
     atd_trace(ATD_DEBUG_FUNCTRACE, ("cmd %d    ", cmdid));
 
     atd_assert(len >= (sizeof(atd_hdr_t) + sizeof(atd_param_t)));
-  
+
     atdhdr  = (atd_hdr_t *) buffer;
     vap_param    = (atd_param_t  *) (buffer + sizeof(atd_hdr_t)) ;
 
@@ -1264,8 +1232,8 @@ fail:
     wmi_cmd_rsp(atsc->wmi_handle, cmdid, status, NULL, 0);
 }
 
-void 
-atd_tgt_get_vap_param(void *ctx, a_uint16_t cmdid, 
+void
+atd_tgt_get_vap_param(void *ctx, a_uint16_t cmdid,
                       a_uint8_t *buffer, a_int32_t len)
 {
 
@@ -1285,7 +1253,7 @@ atd_tgt_get_vap_param(void *ctx, a_uint16_t cmdid,
                 cmdid));
 
     atd_assert(len >= (sizeof(atd_hdr_t) + sizeof(atd_param_t)));
-  
+
     atdhdr  = (atd_hdr_t *) buffer;
     vap_param    = (atd_param_t  *) (buffer + sizeof(atd_hdr_t)) ;
 
@@ -1323,7 +1291,7 @@ atd_tgt_get_vap_param(void *ctx, a_uint16_t cmdid,
     atd_trace(ATD_DEBUG_FUNCTRACE,("Result val %d \n",vap_param->param));
 
 fail:
-    wmi_cmd_rsp(atsc->wmi_handle, cmdid, status, (a_uint8_t *)&paramresult , 
+    wmi_cmd_rsp(atsc->wmi_handle, cmdid, status, (a_uint8_t *)&paramresult ,
                 sizeof (atd_param_t));
 }
 
@@ -1432,8 +1400,8 @@ fail:
                 sizeof(atd_vendor_param_t));
 }
 
-void 
-atd_tgt_set_wifi_param(void *ctx, a_uint16_t cmdid, 
+void
+atd_tgt_set_wifi_param(void *ctx, a_uint16_t cmdid,
                       a_uint8_t *buffer, a_int32_t len)
 {
 
@@ -1452,7 +1420,7 @@ atd_tgt_set_wifi_param(void *ctx, a_uint16_t cmdid,
                 cmdid));
 
     atd_assert(len >= (sizeof(atd_hdr_t) + sizeof(wifi_param)));
-  
+
     atdhdr  = (atd_hdr_t *) buffer;
     wifi_param    = (atd_param_t  *) (buffer + sizeof(atd_hdr_t)) ;
 
@@ -1477,12 +1445,12 @@ atd_tgt_set_wifi_param(void *ctx, a_uint16_t cmdid,
 
 fail:
 
-    wmi_cmd_rsp(atsc->wmi_handle, cmdid, status, (a_uint8_t *)&rsp , 
+    wmi_cmd_rsp(atsc->wmi_handle, cmdid, status, (a_uint8_t *)&rsp ,
                 sizeof (a_int32_t));
 }
 
-void 
-atd_tgt_get_wifi_param(void *ctx, a_uint16_t cmdid, 
+void
+atd_tgt_get_wifi_param(void *ctx, a_uint16_t cmdid,
                       a_uint8_t *buffer, a_int32_t len)
 {
 
@@ -1521,9 +1489,9 @@ atd_tgt_get_wifi_param(void *ctx, a_uint16_t cmdid,
 
 
 
-    status = netdev_wext_handler(wifisc->netdev, ATH_HAL_IOCTL_GETPARAM, 
+    status = netdev_wext_handler(wifisc->netdev, ATH_HAL_IOCTL_GETPARAM,
                                  &info, &iwreq, (char *)&wifi_param->param);
-   
+
     paramresult.val     = htonl(wifi_param->param );
     paramresult.param   = 0;
 
@@ -1532,13 +1500,13 @@ atd_tgt_get_wifi_param(void *ctx, a_uint16_t cmdid,
 
 fail:
 
-    wmi_cmd_rsp(atsc->wmi_handle, cmdid, status, (a_uint8_t *)&paramresult , 
+    wmi_cmd_rsp(atsc->wmi_handle, cmdid, status, (a_uint8_t *)&paramresult ,
                 sizeof (atd_param_t));
 }
 
 
-void 
-atd_tgt_get_opmode(void *ctx, a_uint16_t cmdid, 
+void
+atd_tgt_get_opmode(void *ctx, a_uint16_t cmdid,
                   a_uint8_t *buffer, a_int32_t len)
 {
     a_status_t status = A_STATUS_OK;
@@ -1554,7 +1522,7 @@ atd_tgt_get_opmode(void *ctx, a_uint16_t cmdid,
     atd_trace(ATD_DEBUG_FUNCTRACE, ("cmd %d    ", cmdid));
 
     atd_assert(len >= sizeof(atd_hdr_t));
-  
+
     atdhdr  = (atd_hdr_t  *) buffer;
 
     wifisc = atsc->wifi_list[atdhdr->wifi_index];
@@ -1570,20 +1538,20 @@ atd_tgt_get_opmode(void *ctx, a_uint16_t cmdid,
         goto fail;
     }
 
-    status = netdev_wext_handler(vap->vap_netdev, SIOCGIWMODE, &info, &iwreq, 
-                                 extra); 
+    status = netdev_wext_handler(vap->vap_netdev, SIOCGIWMODE, &info, &iwreq,
+                                 extra);
 
     atd_trace(ATD_DEBUG_FUNCTRACE , ("mode %x ",iwreq.mode));
     iwreq.mode = htonl(iwreq.mode);
 
 fail:
 
-    wmi_cmd_rsp(atsc->wmi_handle, cmdid, status, (a_uint8_t *) (&iwreq.mode ), 
+    wmi_cmd_rsp(atsc->wmi_handle, cmdid, status, (a_uint8_t *) (&iwreq.mode ),
                 sizeof (a_int32_t));
 }
 
-void 
-atd_tgt_set_chmode(void *ctx, a_uint16_t cmdid, 
+void
+atd_tgt_set_chmode(void *ctx, a_uint16_t cmdid,
                   a_uint8_t *buffer, a_int32_t len)
 {
     a_status_t status = A_STATUS_OK;
@@ -1607,7 +1575,7 @@ atd_tgt_set_chmode(void *ctx, a_uint16_t cmdid,
     mode->len = ntohl(mode->len);
     atd_assert(mode->len <= ACFG_MAX_CHMODE_LEN);
 
-    atd_trace(ATD_DEBUG_CFG, ("radio %d vap %d chmode %s len %d ", 
+    atd_trace(ATD_DEBUG_CFG, ("radio %d vap %d chmode %s len %d ",
               atdhdr->wifi_index, atdhdr->vap_index, &mode->mode[0],
               mode->len));
 
@@ -1631,8 +1599,8 @@ atd_tgt_set_chmode(void *ctx, a_uint16_t cmdid,
     iwpdata->flags = 0;
     iwpdata->pointer = (char *)mode->mode;
 
-    status = netdev_wext_handler(vap->vap_netdev, IEEE80211_IOCTL_SETMODE, &info, 
-                                 &iwreqdata, NULL); 
+    status = netdev_wext_handler(vap->vap_netdev, IEEE80211_IOCTL_SETMODE, &info,
+                                 &iwreqdata, NULL);
     if(status != A_STATUS_OK){
         atd_trace(ATD_DEBUG_CFG, ("chmode set erro \n"));
     }
@@ -1641,8 +1609,8 @@ fail:
     wmi_cmd_rsp(atsc->wmi_handle, cmdid, status, NULL, 0);
 }
 
-void 
-atd_tgt_get_chmode(void *ctx, a_uint16_t cmdid, 
+void
+atd_tgt_get_chmode(void *ctx, a_uint16_t cmdid,
                   a_uint8_t *buffer, a_int32_t len)
 {
 
@@ -1660,7 +1628,7 @@ atd_tgt_get_chmode(void *ctx, a_uint16_t cmdid,
     atd_trace(ATD_DEBUG_FUNCTRACE, ("cmd %d    ", cmdid));
 
     atd_assert(len >= sizeof(atd_hdr_t));
-  
+
     atdhdr      = (atd_hdr_t  *)  buffer;
     wifisc = atsc->wifi_list[atdhdr->wifi_index];
     if(wifisc == NULL){
@@ -1674,8 +1642,8 @@ atd_tgt_get_chmode(void *ctx, a_uint16_t cmdid,
         goto fail;
     }
 
-    status = netdev_wext_handler(vap->vap_netdev, IEEE80211_IOCTL_GETMODE, &info, &iwreq, 
-                                 mode.mode); 
+    status = netdev_wext_handler(vap->vap_netdev, IEEE80211_IOCTL_GETMODE, &info, &iwreq,
+                                 mode.mode);
 
     mode.len = htonl(iwreq.data.length);
 
@@ -1684,8 +1652,8 @@ fail:
 }
 
 
-void 
-atd_tgt_get_wireless_name(void *ctx, a_uint16_t cmdid, 
+void
+atd_tgt_get_wireless_name(void *ctx, a_uint16_t cmdid,
                            a_uint8_t *buffer, a_int32_t len)
 {
     a_status_t status = A_STATUS_OK;
@@ -1702,7 +1670,7 @@ atd_tgt_get_wireless_name(void *ctx, a_uint16_t cmdid,
     atd_trace(ATD_DEBUG_FUNCTRACE, ("cmd %d    ", cmdid));
 
     atd_assert(len >= sizeof(atd_hdr_t));
-  
+
     atdhdr      = (atd_hdr_t  *)  buffer;
     wifisc = atsc->wifi_list[atdhdr->wifi_index];
     if(wifisc == NULL){
@@ -1716,17 +1684,17 @@ atd_tgt_get_wireless_name(void *ctx, a_uint16_t cmdid,
         goto fail;
     }
 
-    status = netdev_wext_handler(vap->vap_netdev, SIOCGIWNAME, &info, &iwreq, 
-                                 extra); 
+    status = netdev_wext_handler(vap->vap_netdev, SIOCGIWNAME, &info, &iwreq,
+                                 extra);
 
     atd_trace(ATD_DEBUG_CFG , (" wireless name %s ",iwreq.name));
 fail:
-    wmi_cmd_rsp(atsc->wmi_handle, cmdid, status, (a_uint8_t *)&iwreq.name[0], 
+    wmi_cmd_rsp(atsc->wmi_handle, cmdid, status, (a_uint8_t *)&iwreq.name[0],
                 ACFG_MAX_IFNAME);
 }
 
-void 
-atd_tgt_set_ap (void *ctx, a_uint16_t cmdid, 
+void
+atd_tgt_set_ap (void *ctx, a_uint16_t cmdid,
                            a_uint8_t *buffer, a_int32_t len)
 {
     a_status_t      status = A_STATUS_OK;
@@ -1759,29 +1727,29 @@ atd_tgt_set_ap (void *ctx, a_uint16_t cmdid,
         status = A_STATUS_ENXIO;
         goto fail;
     }
-	
+
     memcpy(iwreq.ap_addr.sa_data, paddr->addr, ACFG_MACADDR_LEN);
-	
+
     atd_trace(ATD_DEBUG_CFG, ("ap macaddr %02x:%02x:%02x:%02x:%02x:%02x", \
                                iwreq.ap_addr.sa_data[0], iwreq.ap_addr.sa_data[1], \
                                iwreq.ap_addr.sa_data[2], iwreq.ap_addr.sa_data[3], \
                                iwreq.ap_addr.sa_data[4], iwreq.ap_addr.sa_data[5]));
 
     status = netdev_wext_handler(vap->vap_netdev, SIOCSIWAP, &info, &iwreq, NULL);
-	
+
     if (status != A_STATUS_OK) {
         atd_trace(ATD_DEBUG_CFG, ("set encode error, status = %d\n", status));
         rsp = 0xFFFFFFFF;
     }
-		
+
 fail:
 
-    wmi_cmd_rsp(atsc->wmi_handle, cmdid, status, (a_uint8_t *)&rsp, 
+    wmi_cmd_rsp(atsc->wmi_handle, cmdid, status, (a_uint8_t *)&rsp,
                 sizeof (a_int32_t));
 }
 
-void 
-atd_tgt_get_ap (void *ctx, a_uint16_t cmdid, 
+void
+atd_tgt_get_ap (void *ctx, a_uint16_t cmdid,
                            a_uint8_t *buffer, a_int32_t len)
 {
     a_status_t status = A_STATUS_OK;
@@ -1800,7 +1768,7 @@ atd_tgt_get_ap (void *ctx, a_uint16_t cmdid,
                 cmdid));
 
     atd_assert(len >= sizeof(atd_hdr_t));
-  
+
     atdhdr      = (atd_hdr_t  *)  buffer;
 
     wifisc = atsc->wifi_list[atdhdr->wifi_index];
@@ -1815,10 +1783,10 @@ atd_tgt_get_ap (void *ctx, a_uint16_t cmdid,
         goto fail;
     }
 
-    status = netdev_wext_handler(vap->vap_netdev, SIOCGIWAP, &info, &iwreq, 
-                                 extra); 
+    status = netdev_wext_handler(vap->vap_netdev, SIOCGIWAP, &info, &iwreq,
+                                 extra);
+
 
-   
     atd_trace(ATD_DEBUG_CFG, (" ap mac addr %x:%x:%x:%x:%x:%x family %x ", \
               iwreq.ap_addr.sa_data[0], iwreq.ap_addr.sa_data[1], \
               iwreq.ap_addr.sa_data[2], iwreq.ap_addr.sa_data[3], \
@@ -1826,12 +1794,12 @@ atd_tgt_get_ap (void *ctx, a_uint16_t cmdid,
               iwreq.ap_addr.sa_family));
 
 fail:
-    wmi_cmd_rsp(atsc->wmi_handle, cmdid, status, 
+    wmi_cmd_rsp(atsc->wmi_handle, cmdid, status,
                  (a_uint8_t *)&iwreq.ap_addr.sa_data[0], ACFG_MACADDR_LEN);
 }
 
-void 
-atd_tgt_get_rate(void *ctx, a_uint16_t cmdid, 
+void
+atd_tgt_get_rate(void *ctx, a_uint16_t cmdid,
                            a_uint8_t *buffer, a_int32_t len)
 {
     a_status_t status = A_STATUS_OK;
@@ -1848,7 +1816,7 @@ atd_tgt_get_rate(void *ctx, a_uint16_t cmdid,
     atd_trace(ATD_DEBUG_FUNCTRACE, ("cmd %d    ", cmdid));
 
     atd_assert(len >= sizeof(atd_hdr_t));
-  
+
     atdhdr      = (atd_hdr_t  *)  buffer;
     wifisc = atsc->wifi_list[atdhdr->wifi_index];
     if(wifisc == NULL){
@@ -1861,13 +1829,13 @@ atd_tgt_get_rate(void *ctx, a_uint16_t cmdid,
         status = A_STATUS_ENXIO;
         goto fail;
     }
-    status = netdev_wext_handler(vap->vap_netdev, SIOCGIWRATE, &info, &iwreq, 
-                                 extra); 
+    status = netdev_wext_handler(vap->vap_netdev, SIOCGIWRATE, &info, &iwreq,
+                                 extra);
 
 
     atd_trace(ATD_DEBUG_CFG, (" rrq->fixed %d rrq->value %d  ", \
                                   iwreq.bitrate.fixed, iwreq.bitrate.value));
-    
+
     iwreq.bitrate.value = htonl(iwreq.bitrate.value);
 fail:
 
@@ -1876,8 +1844,8 @@ fail:
 }
 
 
-static void 
-atd_tgt_set_scan(void *ctx, a_uint16_t cmdid, 
+static void
+atd_tgt_set_scan(void *ctx, a_uint16_t cmdid,
                   a_uint8_t *buffer, a_int32_t len)
 {
     a_status_t     status = A_STATUS_OK;
@@ -1944,8 +1912,8 @@ atd_tgt_set_scan(void *ctx, a_uint16_t cmdid,
     }
     iwpdata->pointer = scan;
 
-    status = netdev_wext_handler(vap->vap_netdev, SIOCSIWSCAN, &info, 
-                                 &iwreqdata, (a_uint8_t *)extra); 
+    status = netdev_wext_handler(vap->vap_netdev, SIOCSIWSCAN, &info,
+                                 &iwreqdata, (a_uint8_t *)extra);
     if(status != A_STATUS_OK){
         atd_trace(ATD_DEBUG_CFG, ("scan set error \n"));
     }
@@ -1970,7 +1938,7 @@ atd_tgt_get_ath_stats(void *ctx, a_uint16_t cmdid,
     acfg_ath_stats_t ath_stats = {0};
     a_uint32_t resp_size = 0;
     void *resp = NULL;
-    
+
     atd_trace(ATD_DEBUG_FUNCTRACE,(" cmd %d ", cmdid));
 
     atd_assert(len >= (sizeof(atd_hdr_t) + sizeof(atd_ath_stats_t)));
@@ -2019,7 +1987,7 @@ atd_tgt_get_ath_stats(void *ctx, a_uint16_t cmdid,
                 acfg_ath_stats_11n_t *stats = (acfg_ath_stats_11n_t *)(ath_stats.address);
                 atd_ath_stats_11n_t *n_stats = (atd_ath_stats_11n_t *)((a_uint8_t *)resp + sizeof(atd_ath_stats_t));
                 athstats->size = htonl(sizeof(atd_ath_stats_11n_t));
-
+                memcpy(n_stats, stats, athstats->size);
                 n_stats->ast_watchdog = htonl(stats->ast_watchdog);
                 n_stats->ast_resetOnError = htonl(stats->ast_resetOnError);
                 n_stats->ast_mat_ucast_encrypted = htonl(stats->ast_mat_ucast_encrypted);
@@ -2394,6 +2362,7 @@ atd_tgt_get_ath_stats(void *ctx, a_uint16_t cmdid,
                 acfg_ath_stats_11ac_t *stats = (acfg_ath_stats_11ac_t *)(ath_stats.address);
                 atd_ath_stats_11ac_t *ac_stats = (atd_ath_stats_11ac_t *)((a_uint8_t *)resp + sizeof(atd_ath_stats_t));
                 athstats->size = htonl(sizeof(atd_ath_stats_11ac_t));
+                memcpy(ac_stats, stats, athstats->size);
 
                 ac_stats->txrx_stats_level = htonl(stats->txrx_stats_level);
 #ifndef BIG_ENDIAN_HOST
@@ -2454,7 +2423,7 @@ atd_tgt_get_ath_stats(void *ctx, a_uint16_t cmdid,
                 ac_stats->stats.tx.underrun = htonl(stats->stats.tx.underrun);
                 ac_stats->stats.tx.tx_abort = htonl(stats->stats.tx.tx_abort);
                 ac_stats->stats.tx.mpdus_requed = htonl(stats->stats.tx.mpdus_requed);
-                ac_stats->stats.tx.tx_ko = htonl(stats->stats.tx.tx_xretry);
+                ac_stats->stats.tx.tx_xretry = htonl(stats->stats.tx.tx_xretry);
                 ac_stats->stats.tx.data_rc = htonl(stats->stats.tx.data_rc);
                 ac_stats->stats.tx.self_triggers = htonl(stats->stats.tx.self_triggers);
                 ac_stats->stats.tx.sw_retry_failure = htonl(stats->stats.tx.sw_retry_failure);
@@ -2470,7 +2439,6 @@ atd_tgt_get_ath_stats(void *ctx, a_uint16_t cmdid,
                 ac_stats->stats.rx.r0_frags = htonl(stats->stats.rx.r0_frags);
                 ac_stats->stats.rx.r1_frags = htonl(stats->stats.rx.r1_frags);
                 ac_stats->stats.rx.r2_frags = htonl(stats->stats.rx.r2_frags);
-                ac_stats->stats.rx.r3_frags = htonl(stats->stats.rx.r3_frags);
                 ac_stats->stats.rx.htt_msdus = htonl(stats->stats.rx.htt_msdus);
                 ac_stats->stats.rx.htt_mpdus = htonl(stats->stats.rx.htt_mpdus);
                 ac_stats->stats.rx.loc_msdus = htonl(stats->stats.rx.loc_msdus);
@@ -2479,9 +2447,8 @@ atd_tgt_get_ath_stats(void *ctx, a_uint16_t cmdid,
                 ac_stats->stats.rx.phy_errs = htonl(stats->stats.rx.phy_errs);
                 ac_stats->stats.rx.phy_err_drop = htonl(stats->stats.rx.phy_err_drop);
                 ac_stats->stats.rx.mpdu_errs = htonl(stats->stats.rx.mpdu_errs);
-                ac_stats->stats.mem.dram_remain = htonl(stats->stats.mem.dram_free_size);
-                ac_stats->stats.mem.iram_remain = htonl(stats->stats.mem.iram_free_size);
-                ac_stats->stats.peer.dummy = htonl(stats->stats.peer.dummy);
+                ac_stats->stats.mem.dram_free_size = htonl(stats->stats.mem.dram_free_size);
+                ac_stats->stats.mem.iram_free_size = htonl(stats->stats.mem.iram_free_size);
                 ac_stats->interface_stats.tx_beacon = cpu_to_be64(stats->interface_stats.tx_beacon);
                 ac_stats->interface_stats.be_nobuf = htonl(stats->interface_stats.be_nobuf);
                 ac_stats->interface_stats.tx_buf_count = htonl(stats->interface_stats.tx_buf_count);
@@ -2539,15 +2506,12 @@ atd_tgt_get_ath_stats(void *ctx, a_uint16_t cmdid,
             break;
         }
     }
-
 fail:
     wmi_cmd_rsp(atsc->wmi_handle, cmdid, status, resp, resp_size);
 
-    if (ath_stats.address)
-       kfree(ath_stats.address);
     if (resp)
         kfree(resp);
- 
+
     atd_trace(ATD_DEBUG_FUNCTRACE,(" End"));
 }
 
@@ -2560,7 +2524,7 @@ atd_tgt_clr_ath_stats(void *ctx, a_uint16_t cmdid,
     atd_tgt_wifi_t *wifisc = NULL;
     struct ifreq ifr;
     atd_hdr_t   *atdhdr;
-    
+
     atd_trace(ATD_DEBUG_FUNCTRACE,(" cmd %d ", cmdid));
 
     atd_assert(len >= sizeof(atd_hdr_t));
@@ -2591,8 +2555,8 @@ fail:
     atd_trace(ATD_DEBUG_FUNCTRACE,(" End"));
 }
 
-static void 
-atd_tgt_get_scanresults(void *ctx, a_uint16_t cmdid, 
+static void
+atd_tgt_get_scanresults(void *ctx, a_uint16_t cmdid,
                   a_uint8_t *buffer, a_int32_t len)
 {
     a_status_t status      = A_STATUS_OK;
@@ -2647,7 +2611,6 @@ atd_tgt_get_scanresults(void *ctx, a_uint16_t cmdid,
     req.u.data.flags   = 0;
 
 #define IEEE80211_IOCTL_SCAN_RESULTS (SIOCDEVPRIVATE+9)
-
     status = netdev_ioctl(vap->vap_netdev,(struct ifreq *)&req,
                           IEEE80211_IOCTL_SCAN_RESULTS);
 
@@ -2660,7 +2623,7 @@ atd_tgt_get_scanresults(void *ctx, a_uint16_t cmdid,
         while (pos + sizeof(struct ieee80211req_scan_result) <= end) {
             struct ieee80211req_scan_result *sr;
             a_uint8_t *next;
-        
+
             sr = (struct ieee80211req_scan_result *) pos;
             next = pos + sr->isr_len;
             if (next > end)
@@ -2668,7 +2631,7 @@ atd_tgt_get_scanresults(void *ctx, a_uint16_t cmdid,
             pos += sizeof(*sr);
             if (pos + sr->isr_ssid_len + sr->isr_ie_len > end)
                 break;
-           
+
             sl->isr_len = htons(sr->isr_len - sizeof(*sr));
             sl->isr_freq = htons(sr->isr_freq);
             sl->isr_flags = htonl(sr->isr_flags);
@@ -2683,10 +2646,9 @@ atd_tgt_get_scanresults(void *ctx, a_uint16_t cmdid,
             for (i = 0; i < 36; i++)
                 sl->isr_rates[i] = sr->isr_rates[i];
             sl->isr_ssid_len = sr->isr_ssid_len;
-            sl->isr_ie_len = htons(sr->isr_ie_len);    
+            sl->isr_ie_len = htons(sr->isr_ie_len);
             memcpy(sl + 1, sr + 1, sr->isr_len - sizeof(*sr));
-
-            sl = (atd_scan_result_t *)((u_int8_t *)(sl + 1) 
+            sl = (atd_scan_result_t *)((u_int8_t *)(sl + 1)
                                        + sr->isr_len - sizeof(*sr));
             count += sizeof(*sl) + sr->isr_len - sizeof(*sr);
             pos = next;
@@ -2704,17 +2666,17 @@ fail:
     atd_trace(ATD_DEBUG_FUNCTRACE,(" End"));
 }
 
-/** 
+/**
  * @brief Get Scanlist space from Newma
- * 
+ *
  * @param ctx
  * @param cmdid
  * @param seqno
  * @param buffer
  * @param len
  */
-static void 
-atd_tgt_get_scan_space(void *ctx, a_uint16_t cmdid, 
+static void
+atd_tgt_get_scan_space(void *ctx, a_uint16_t cmdid,
                   a_uint8_t *buffer, a_int32_t len)
 {
     a_status_t status      = A_STATUS_OK;
@@ -2765,7 +2727,7 @@ atd_tgt_get_scan_space(void *ctx, a_uint16_t cmdid,
     rlen =  htonl(rlen);
 
 fail:
-    wmi_cmd_rsp(atsc->wmi_handle, cmdid, status, (a_uint8_t *)&rlen, 
+    wmi_cmd_rsp(atsc->wmi_handle, cmdid, status, (a_uint8_t *)&rlen,
             sizeof(a_uint32_t));
 
     kfree(param);
@@ -2774,16 +2736,16 @@ fail:
 }
 
 
-/** 
- * @brief 
- * 
+/**
+ * @brief
+ *
  * @param ctx
  * @param cmdid
  * @param buffer
  * @param len
  */
-static void 
-atd_tgt_get_range (void *ctx, a_uint16_t cmdid, 
+static void
+atd_tgt_get_range (void *ctx, a_uint16_t cmdid,
                    a_uint8_t *buffer, a_int32_t len)
 {
     a_status_t      status = A_STATUS_OK;
@@ -2811,7 +2773,7 @@ atd_tgt_get_range (void *ctx, a_uint16_t cmdid,
     memset(rangebuf, 0, sizeof(struct iw_range));
 
     tmp = (struct iw_range *)rangebuf;
-  
+
     atdhdr      = (atd_hdr_t  *)  buffer;
     wifisc = atsc->wifi_list[atdhdr->wifi_index];
     if(wifisc == NULL){
@@ -2835,8 +2797,8 @@ atd_tgt_get_range (void *ctx, a_uint16_t cmdid,
 
     l = sizeof(atd_range_buf_t);
 
-    status = netdev_wext_handler(vap->vap_netdev, SIOCGIWRANGE, &info, 
-                                 (void *)&iwreq, (a_uint8_t *)rangebuf); 
+    status = netdev_wext_handler(vap->vap_netdev, SIOCGIWRANGE, &info,
+                                 (void *)&iwreq, (a_uint8_t *)rangebuf);
 
     if(status != A_STATUS_OK) {
         atd_trace(ATD_DEBUG_CFG, ("Range Get error \n"));
@@ -2913,15 +2875,15 @@ fail:
         kfree(resp);
     if (rangebuf)
         kfree(rangebuf);
-    
+
     atd_trace(ATD_DEBUG_FUNCTRACE ,(" End"));
 }
 
 
 
-/** 
- * @brief 
- * 
+/**
+ * @brief
+ *
  * @param ctx
  * @param cmdid
  * @param buffer
@@ -2939,7 +2901,7 @@ atd_tgt_set_opmode(void *ctx, a_uint16_t cmdid,
     struct iw_request_info info;
     atd_hdr_t  *atdhdr;
     a_uint32_t *ptr_mode ;
-    
+
     atd_trace((ATD_DEBUG_FUNCTRACE|ATD_DEBUG_CFG) , ("cmd %d ", cmdid));
 
     atd_assert(len >= (sizeof(atd_hdr_t) + sizeof(a_uint32_t)));
@@ -2963,8 +2925,8 @@ atd_tgt_set_opmode(void *ctx, a_uint16_t cmdid,
     info.flags = 0 ;
     iwreqdata.mode = ntohl(*ptr_mode);
 
-    /* 
-     * Convert ACFG_OPMODE_* to IW_MODE_* 
+    /*
+     * Convert ACFG_OPMODE_* to IW_MODE_*
      */
     switch(iwreqdata.mode)
     {
@@ -2974,7 +2936,7 @@ atd_tgt_set_opmode(void *ctx, a_uint16_t cmdid,
         case ACFG_OPMODE_MONITOR: iwreqdata.mode = IW_MODE_MONITOR; break;
         default: iwreqdata.mode = IW_MODE_AUTO; break;
     }
-    
+
     atd_trace((ATD_DEBUG_FUNCTRACE|ATD_DEBUG_CFG), \
                                         ("opmode %d ", iwreqdata.mode));
 
@@ -2988,10 +2950,10 @@ fail:
     wmi_cmd_rsp(atsc->wmi_handle, cmdid, status, NULL, 0);
 }
 
-                                        
-/** 
- * @brief 
- * 
+
+/**
+ * @brief
+ *
  * @param ctx
  * @param cmdid
  * @param buffer
@@ -3032,8 +2994,8 @@ atd_tgt_set_freq (void *ctx, a_uint16_t cmdid,
 
     info.cmd = SIOCSIWFREQ ;
     info.flags = 0 ;
-    iwreq.freq.m = ntohl(freq->m);
-    iwreq.freq.e = ntohs(freq->e);
+    iwreq.freq.m = ntohl(*freq);
+    iwreq.freq.e = 0;
     iwreq.freq.i = 0;
     iwreq.freq.flags = IW_FREQ_FIXED ;
 
@@ -3060,9 +3022,37 @@ fail:
 }
 
 
-/** 
- * @brief 
- * 
+/**
+ * @brief String representations of phy modes
+ *        in capital letters.
+ */
+static const a_uint8_t *phymode_strings[] = {
+    [ACFG_PHYMODE_AUTO]             = (a_uint8_t *)"AUTO",
+    [ACFG_PHYMODE_11A]              = (a_uint8_t *)"11A",
+    [ACFG_PHYMODE_11B]              = (a_uint8_t *)"11B",
+    [ACFG_PHYMODE_11G]              = (a_uint8_t *)"11G" ,
+    [ACFG_PHYMODE_FH]               = (a_uint8_t *)"FH" ,
+    [ACFG_PHYMODE_TURBO_A]               = (a_uint8_t *)"TA" ,
+    [ACFG_PHYMODE_TURBO_G]               = (a_uint8_t *)"TG" ,
+    [ACFG_PHYMODE_11NA_HT20]        = (a_uint8_t *)"11NAHT20" ,
+    [ACFG_PHYMODE_11NG_HT20]        = (a_uint8_t *)"11NGHT20" ,
+    [ACFG_PHYMODE_11NA_HT40PLUS]    = (a_uint8_t *)"11NAHT40PLUS" ,
+    [ACFG_PHYMODE_11NA_HT40MINUS]   = (a_uint8_t *)"11NAHT40MINUS" ,
+    [ACFG_PHYMODE_11NG_HT40PLUS]    = (a_uint8_t *)"11NGHT40PLUS" ,
+    [ACFG_PHYMODE_11NG_HT40MINUS]   = (a_uint8_t *)"11NGHT40MINUS" ,
+    [ACFG_PHYMODE_11NG_HT40]   = (a_uint8_t *)"11NGHT40" ,
+    [ACFG_PHYMODE_11NA_HT40]   = (a_uint8_t *)"11NAHT40" ,
+    [ACFG_PHYMODE_11AC_VHT20]  = (a_uint8_t *)"11ACVHT20" ,
+    [ACFG_PHYMODE_11AC_VHT40PLUS]  = (a_uint8_t *)"11ACVHT40PLUS" ,
+    [ACFG_PHYMODE_11AC_VHT40MINUS]  = (a_uint8_t *)"11ACVHT40MINUS" ,
+    [ACFG_PHYMODE_11AC_VHT40]  = (a_uint8_t *)"11ACVHT40" ,
+    [ACFG_PHYMODE_11AC_VHT80]  = (a_uint8_t *)"11ACVHT80" ,
+    [ACFG_PHYMODE_INVALID]          = NULL ,
+} ;
+
+/**
+ * @brief
+ *
  * @param ctx
  * @param cmdid
  * @param buffer
@@ -3198,9 +3188,9 @@ fail:
     atd_trace(ATD_DEBUG_FUNCTRACE ,(" End"));
 }
 
-/** 
+/**
  * @brief Get info on associated stations
- * 
+ *
  * @param ctx
  * @param cmdid
  * @param buffer
@@ -3243,7 +3233,7 @@ atd_tgt_get_stainfo(void *ctx, a_uint16_t cmdid,
         status = A_STATUS_ENXIO;
         goto fail;
     }
-    
+
     atd_trace(ATD_DEBUG_CFG, ("%s(): hostlen = %d \n",__FUNCTION__,hostlen));
 
     infobuff = kzalloc(hostlen, GFP_KERNEL);
@@ -3315,7 +3305,7 @@ atd_tgt_get_stainfo(void *ctx, a_uint16_t cmdid,
         memcpy(resp + 1, si + 1, si->isi_len - sizeof(*si));
 
         count += sizeof(*resp) + si->isi_len - sizeof(*si);
-        resp = (atd_stainfo_t *)((a_uint8_t *)(resp + 1) 
+        resp = (atd_stainfo_t *)((a_uint8_t *)(resp + 1)
                                  + (si->isi_len - sizeof(*si)));
         pos = next;
     }
@@ -3334,8 +3324,8 @@ fail:
 }
 
 
-void 
-atd_tgt_set_mlme(void *ctx, a_uint16_t cmdid, 
+void
+atd_tgt_set_mlme(void *ctx, a_uint16_t cmdid,
                   a_uint8_t *buffer, a_int32_t len)
 {
     a_status_t status = A_STATUS_OK;
@@ -3356,7 +3346,7 @@ atd_tgt_set_mlme(void *ctx, a_uint16_t cmdid,
     setmlme = (atd_mlme_t *)(buffer + sizeof(atd_hdr_t));
 
 
-    atd_trace(ATD_DEBUG_CFG, ("radio %d vap %d ", 
+    atd_trace(ATD_DEBUG_CFG, ("radio %d vap %d ",
               atdhdr->wifi_index, atdhdr->vap_index));
 
 
@@ -3379,17 +3369,19 @@ atd_tgt_set_mlme(void *ctx, a_uint16_t cmdid,
     if(mlme == NULL){
         printk("\n %s : allocation failed\n", __FUNCTION__);
         status = A_STATUS_ENOMEM;
-        goto fail; 
+        goto fail;
     }
 
-    mlme->im_op = setmlme->op;
-    mlme->im_ssid_len = setmlme->ssid_len;
-    mlme->im_reason = ntohs(setmlme->reason);
-    mlme->im_seq = ntohs(setmlme->seq);
-    memcpy(mlme->im_macaddr, setmlme->macaddr, ACFG_MACADDR_LEN);
-    memcpy(mlme->im_ssid, setmlme->ssid, ACFG_MAX_SSID_LEN);
-    memcpy(mlme->im_optie, setmlme->optie, ACFG_MAX_IELEN * 2);
-    mlme->im_optie_len = ntohs(setmlme->optie_len);
+    memcpy(mlme, setmlme, sizeof(*mlme));
+
+    mlme->im_op = setmlme->im_op;
+    mlme->im_ssid_len = setmlme->im_ssid_len;
+    mlme->im_reason = ntohs(setmlme->im_reason);
+    mlme->im_seq = ntohs(setmlme->im_seq);
+    memcpy(mlme->im_macaddr, setmlme->im_macaddr, ACFG_MACADDR_LEN);
+    memcpy(mlme->im_ssid, setmlme->im_ssid, ACFG_MAX_SSID_LEN);
+    memcpy(mlme->im_optie, setmlme->im_optie, ACFG_MAX_IELEN * 2);
+    mlme->im_optie_len = ntohs(setmlme->im_optie_len);
 
     info.cmd = IEEE80211_IOCTL_SETMLME;
     info.flags = 0;
@@ -3397,8 +3389,8 @@ atd_tgt_set_mlme(void *ctx, a_uint16_t cmdid,
     iwpdata->flags = 0;
     iwpdata->pointer = (char *)mlme;
 
-    status = netdev_wext_handler(vap->vap_netdev, IEEE80211_IOCTL_SETMLME, &info, 
-                                 &iwreqdata, (char *)mlme); 
+    status = netdev_wext_handler(vap->vap_netdev, IEEE80211_IOCTL_SETMLME, &info,
+                                 &iwreqdata, (char *)mlme);
     if(status != A_STATUS_OK){
         atd_trace(ATD_DEBUG_CFG, ("mlme set erro \n"));
     }
@@ -3411,9 +3403,9 @@ fail:
 
 
 
-/** 
+/**
  * @brief Set Opt IE
- * 
+ *
  * @param ctx
  * @param cmdid
  * @param buffer
@@ -3436,7 +3428,7 @@ atd_tgt_set_optie(void *ctx, a_uint16_t cmdid,
     atd_trace(ATD_DEBUG_FUNCTRACE, ("Start..."));
 
     atd_assert(len >= (sizeof(atd_hdr_t) + sizeof(a_uint32_t)));
-    
+
     atdhdr      = (atd_hdr_t  *)  buffer;
 
     wifisc = atsc->wifi_list[atdhdr->wifi_index];
@@ -3478,16 +3470,16 @@ fail:
 
 
 
-/** 
+/**
  * @brief Get WPAIE
- * 
+ *
  * @param ctx
  * @param cmdid
  * @param buffer
  * @param len
  */
-void 
-atd_tgt_get_wpa_ie(void *ctx, a_uint16_t cmdid, 
+void
+atd_tgt_get_wpa_ie(void *ctx, a_uint16_t cmdid,
                   a_uint8_t *buffer, a_int32_t len)
 {
     a_status_t status = A_STATUS_OK;
@@ -3498,12 +3490,12 @@ atd_tgt_get_wpa_ie(void *ctx, a_uint16_t cmdid,
     void *wpaiebuff = NULL, *p_wpa_ie = NULL;
     struct iwreq req = {{{0}}};
     uint32_t pldlen = 0;
-    
+
     atd_trace(ATD_DEBUG_FUNCTRACE, ("cmd %d    ",\
                 cmdid));
 
     atd_assert(len >= (sizeof(atd_hdr_t) + sizeof(a_uint32_t)));
-  
+
     atdhdr     = (atd_hdr_t *) buffer;
     p_wpa_ie   = (acfg_opaque_t *) (buffer + sizeof(atd_hdr_t)) ;
     pldlen     = ntohl(*(a_uint32_t *)p_wpa_ie);
@@ -3542,7 +3534,7 @@ atd_tgt_get_wpa_ie(void *ctx, a_uint16_t cmdid,
     atd_trace(ATD_DEBUG_FUNCTRACE,("wpaie %p \n", p_wpa_ie));
 
 fail:
-    wmi_cmd_rsp(atsc->wmi_handle, cmdid, status, (a_uint8_t *)wpaiebuff, 
+    wmi_cmd_rsp(atsc->wmi_handle, cmdid, status, (a_uint8_t *)wpaiebuff,
                 req.u.data.length);
 
     if(wpaiebuff)
@@ -3550,16 +3542,16 @@ fail:
 
 }
 
-/** 
+/**
  * @brief Set AC Params
- * 
+ *
  * @param ctx
  * @param cmdid
  * @param buffer
  * @param len
  */
-void 
-atd_tgt_set_acparams(void *ctx, a_uint16_t cmdid, 
+void
+atd_tgt_set_acparams(void *ctx, a_uint16_t cmdid,
                   a_uint8_t *buffer, a_int32_t len)
 {
     a_status_t status = A_STATUS_OK;
@@ -3602,15 +3594,15 @@ atd_tgt_set_acparams(void *ctx, a_uint16_t cmdid,
       printk(" %d ",*ac);
     }
     printk("\n");
-    
+
     info.cmd = IEEE80211_IOCTL_SET_ACPARAMS;
     info.flags = 0;
     iwpdata->length = ACFG_MAX_ACPARAMS * sizeof(*ac);
     iwpdata->flags = 0;
     iwpdata->pointer = (char *)ac;
 
-    status = netdev_wext_handler(vap->vap_netdev, IEEE80211_IOCTL_SET_ACPARAMS, &info, 
-                                 &iwreqdata, (char *)ac); 
+    status = netdev_wext_handler(vap->vap_netdev, IEEE80211_IOCTL_SET_ACPARAMS, &info,
+                                 &iwreqdata, (char *)ac);
     if(status != A_STATUS_OK){
         atd_trace(ATD_DEBUG_CFG, ("set AC params error \n"));
     }
@@ -3666,7 +3658,7 @@ atd_tgt_send_mgmt(void *ctx, a_uint16_t cmdid,
         status = A_STATUS_ENXIO;
         goto fail;
     }
-    
+
     l = ntohl(mgmt->buflen);
     vzalloc(sizeof(struct ieee80211req_mgmtbuf) + l, mgmt_buf);
     if(mgmt_buf == NULL){
@@ -4057,40 +4049,48 @@ atd_tgt_dbgreq(void *ctx, a_uint16_t cmdid,
             acsdbg->chan_load = ntohl(acs_dbg->chan_load);
             acsdbg->sec_chan = acs_dbg->sec_chan;
             break;
-#if 0
-        case ACFG_DBGREQ_BSTEERING_SET_PARAMS:
-            dbgreq->data.bsteering_param.inactivity_timeout_normal = ntohl(req->data.bst.inactivity_timeout_normal);
-            dbgreq->data.bsteering_param.inactivity_timeout_overload = ntohl(req->data.bst.inactivity_timeout_overload);
-            dbgreq->data.bsteering_param.inactivity_check_period = ntohl(req->data.bst.inactivity_check_period);
-            dbgreq->data.bsteering_param.utilization_sample_period = ntohl(req->data.bst.utilization_sample_period);
-            dbgreq->data.bsteering_param.utilization_average_num_samples = ntohl(req->data.bst.utilization_average_num_samples);
-            dbgreq->data.bsteering_param.inactive_rssi_crossing_threshold = ntohl(req->data.bst.inactive_rssi_crossing_threshold);
-            dbgreq->data.bsteering_param.low_rssi_crossing_threshold = ntohl(req->data.bst.low_rssi_crossing_threshold);
+        case IEEE80211_DBGREQ_BSTEERING_SET_PARAMS:
+	    memcpy(&dbgreq->data.bsteering_param, &req->data.bsteering_param, sizeof(dbgreq->data.bsteering_param));
+            dbgreq->data.bsteering_param.inactivity_timeout_normal = ntohl(req->data.bsteering_param.inactivity_timeout_normal);
+            dbgreq->data.bsteering_param.inactivity_timeout_overload = ntohl(req->data.bsteering_param.inactivity_timeout_overload);
+            dbgreq->data.bsteering_param.inactivity_check_period = ntohl(req->data.bsteering_param.inactivity_check_period);
+            dbgreq->data.bsteering_param.utilization_sample_period = ntohl(req->data.bsteering_param.utilization_sample_period);
+            dbgreq->data.bsteering_param.utilization_average_num_samples = ntohl(req->data.bsteering_param.utilization_average_num_samples);
+            dbgreq->data.bsteering_param.low_rssi_crossing_threshold = ntohl(req->data.bsteering_param.low_rssi_crossing_threshold);
             break;
-        case ACFG_DBGREQ_BSTEERING_GET_PARAMS:
+        case IEEE80211_DBGREQ_BSTEERING_GET_PARAMS:
             break;
-        case ACFG_DBGREQ_BSTEERING_SET_DBG_PARAMS:
-            dbgreq->data.bsteering_dbg_param.raw_chan_util_log_enable = 
-              (req->data.bst_dbg.raw_log_enable & 0x1) ? 1 : 0;
-            dbgreq->data.bsteering_dbg_param.raw_rssi_log_enable = 
-              (req->data.bst_dbg.raw_log_enable & 0x2) ? 1 : 0;
+        case IEEE80211_DBGREQ_BSTEERING_SET_DBG_PARAMS:
+            dbgreq->data.bsteering_dbg_param.raw_chan_util_log_enable =
+              (req->data.bsteering_dbg_param.raw_chan_util_log_enable & 0x1) ? 1 : 0;
+            dbgreq->data.bsteering_dbg_param.raw_rssi_log_enable =
+              (req->data.bsteering_dbg_param.raw_rssi_log_enable & 0x1) ? 1 : 0;
             break;
-        case ACFG_DBGREQ_BSTEERING_GET_DBG_PARAMS:
+        case IEEE80211_DBGREQ_BSTEERING_GET_DBG_PARAMS:
             break;
-        case ACFG_DBGREQ_BSTEERING_ENABLE:
+        case IEEE80211_DBGREQ_BSTEERING_ENABLE:
+        case IEEE80211_DBGREQ_BSTEERING_ENABLE_EVENTS: // Notice Fall through
             dbgreq->data.bsteering_enable = req->data.bsteering_enable;
             break;
-        case ACFG_DBGREQ_BSTEERING_SET_OVERLOAD:
+        case IEEE80211_DBGREQ_BSTEERING_SET_OVERLOAD:
             dbgreq->data.bsteering_overload = req->data.bsteering_overload;
             break;
-        case ACFG_DBGREQ_BSTEERING_GET_OVERLOAD:
+        case IEEE80211_DBGREQ_BSTEERING_GET_OVERLOAD:
             break;
-        case ACFG_DBGREQ_BSTEERING_GET_RSSI:
+        case IEEE80211_DBGREQ_BSTEERING_GET_RSSI:
             break;
-        case ACFG_DBGREQ_BSTEERING_SET_PROBE_RESP_WH:
+        case IEEE80211_DBGREQ_BSTEERING_SET_PROBE_RESP_WH:
             dbgreq->data.bsteering_probe_resp_wh = req->data.bsteering_probe_resp_wh;
             break;
-#endif
+         case IEEE80211_DBGREQ_BSTEERING_GET_DATARATE_INFO:
+            dbgreq->data.bsteering_datarate_info.max_chwidth = req->data.bsteering_datarate_info.max_chwidth;
+            dbgreq->data.bsteering_datarate_info.num_streams =  req->data.bsteering_datarate_info.num_streams;
+            dbgreq->data.bsteering_datarate_info.phymode =  req->data.bsteering_datarate_info.phymode;
+            dbgreq->data.bsteering_datarate_info.max_MCS =  req->data.bsteering_datarate_info.max_MCS;
+            dbgreq->data.bsteering_datarate_info.max_txpower =  req->data.bsteering_datarate_info.max_txpower;
+            dbgreq->data.bsteering_datarate_info.is_static_smps =  req->data.bsteering_datarate_info.is_static_smps;
+            dbgreq->data.bsteering_datarate_info.is_mu_mimo_supported =  req->data.bsteering_datarate_info.is_mu_mimo_supported;
+            break;
         default:
             break;
     }
@@ -4404,41 +4404,48 @@ atd_tgt_dbgreq(void *ctx, a_uint16_t cmdid,
             acs_dbg->chan_load = htonl(acsdbg->chan_load);
             acs_dbg->sec_chan = acsdbg->sec_chan;
             break;
-#if 0
-        case ACFG_DBGREQ_BSTEERING_SET_PARAMS:
+        case IEEE80211_DBGREQ_BSTEERING_SET_PARAMS:
             break;
-        case ACFG_DBGREQ_BSTEERING_GET_PARAMS:
-            resp->data.bst.inactivity_timeout_normal = htonl(dbgreq->data.bsteering_param.inactivity_timeout_normal);
-            resp->data.bst.inactivity_timeout_overload = htonl(dbgreq->data.bsteering_param.inactivity_timeout_overload);
-            resp->data.bst.inactivity_check_period = htonl(dbgreq->data.bsteering_param.inactivity_check_period);
-            resp->data.bst.utilization_sample_period = htonl(dbgreq->data.bsteering_param.utilization_sample_period);
-            resp->data.bst.utilization_average_num_samples = htonl(dbgreq->data.bsteering_param.utilization_average_num_samples);
-            resp->data.bst.inactive_rssi_crossing_threshold = htonl(dbgreq->data.bsteering_param.inactive_rssi_crossing_threshold);
-            resp->data.bst.low_rssi_crossing_threshold = htonl(dbgreq->data.bsteering_param.low_rssi_crossing_threshold);
+        case IEEE80211_DBGREQ_BSTEERING_GET_PARAMS:
+            memcpy(&resp->data.bsteering_param, &dbgreq->data.bsteering_param, sizeof(dbgreq->data.bsteering_param));
+            resp->data.bsteering_param.inactivity_timeout_normal = htonl(dbgreq->data.bsteering_param.inactivity_timeout_normal);
+            resp->data.bsteering_param.inactivity_timeout_overload = htonl(dbgreq->data.bsteering_param.inactivity_timeout_overload);
+            resp->data.bsteering_param.inactivity_check_period = htonl(dbgreq->data.bsteering_param.inactivity_check_period);
+            resp->data.bsteering_param.utilization_sample_period = htonl(dbgreq->data.bsteering_param.utilization_sample_period);
+            resp->data.bsteering_param.utilization_average_num_samples = htonl(dbgreq->data.bsteering_param.utilization_average_num_samples);
+            resp->data.bsteering_param.low_rssi_crossing_threshold = htonl(dbgreq->data.bsteering_param.low_rssi_crossing_threshold);
             break;
-        case ACFG_DBGREQ_BSTEERING_SET_DBG_PARAMS:
+        case IEEE80211_DBGREQ_BSTEERING_SET_DBG_PARAMS:
             break;
-        case ACFG_DBGREQ_BSTEERING_GET_DBG_PARAMS:
-            resp->data.bst_dbg.raw_log_enable = 0;
+        case IEEE80211_DBGREQ_BSTEERING_GET_DBG_PARAMS:
           if (dbgreq->data.bsteering_dbg_param.raw_chan_util_log_enable)
-            resp->data.bst_dbg.raw_log_enable += 0x1;
+            resp->data.bsteering_dbg_param.raw_chan_util_log_enable = 0x1;
           if (dbgreq->data.bsteering_dbg_param.raw_rssi_log_enable)
-            resp->data.bst_dbg.raw_log_enable += 0x2;
+            resp->data.bsteering_dbg_param.raw_rssi_log_enable = 0x1;
             break;
-        case ACFG_DBGREQ_BSTEERING_ENABLE:
+	case IEEE80211_DBGREQ_BSTEERING_ENABLE:
+        case IEEE80211_DBGREQ_BSTEERING_ENABLE_EVENTS: // Notice Fall through
             break;
-        case ACFG_DBGREQ_BSTEERING_SET_OVERLOAD:
+        case IEEE80211_DBGREQ_BSTEERING_SET_OVERLOAD:
             break;
-        case ACFG_DBGREQ_BSTEERING_GET_OVERLOAD:
+        case IEEE80211_DBGREQ_BSTEERING_GET_OVERLOAD:
             resp->data.bsteering_overload = dbgreq->data.bsteering_overload;
             break;
-        case ACFG_DBGREQ_BSTEERING_GET_RSSI:
-            memcpy(resp->data.bst_rssi_req.sender_addr, dbgreq->data.bsteering_rssi_req.sender_addr, 6);
-            resp->data.bst_rssi_req.num_measurements = htons(dbgreq->data.bsteering_rssi_req.num_measurements);
+        case IEEE80211_DBGREQ_BSTEERING_GET_RSSI:
+            memcpy(resp->data.bsteering_rssi_req.sender_addr, dbgreq->data.bsteering_rssi_req.sender_addr, 6);
+            resp->data.bsteering_rssi_req.num_measurements = htons(dbgreq->data.bsteering_rssi_req.num_measurements);
             break;
-        case ACFG_DBGREQ_BSTEERING_SET_PROBE_RESP_WH:
+        case IEEE80211_DBGREQ_BSTEERING_SET_PROBE_RESP_WH:
+            break;
+        case IEEE80211_DBGREQ_BSTEERING_GET_DATARATE_INFO:
+            resp->data.bsteering_datarate_info.max_chwidth = dbgreq->data.bsteering_datarate_info.max_chwidth;
+            resp->data.bsteering_datarate_info.num_streams =  dbgreq->data.bsteering_datarate_info.num_streams;
+            resp->data.bsteering_datarate_info.phymode =  dbgreq->data.bsteering_datarate_info.phymode;
+            resp->data.bsteering_datarate_info.max_MCS =  dbgreq->data.bsteering_datarate_info.max_MCS;
+            resp->data.bsteering_datarate_info.max_txpower =  dbgreq->data.bsteering_datarate_info.max_txpower;
+            resp->data.bsteering_datarate_info.is_static_smps =  dbgreq->data.bsteering_datarate_info.is_static_smps;
+            resp->data.bsteering_datarate_info.is_mu_mimo_supported =  dbgreq->data.bsteering_datarate_info.is_mu_mimo_supported;
             break;
-#endif
         default:
             break;
     }
@@ -4455,16 +4462,16 @@ fail:
 }
 
 
-/** 
- * @brief Set Filterframe 
- * 
+/**
+ * @brief Set Filterframe
+ *
  * @param ctx
  * @param cmdid
  * @param buffer
  * @param len
  */
-void 
-atd_tgt_set_filterframe(void *ctx, a_uint16_t cmdid, 
+void
+atd_tgt_set_filterframe(void *ctx, a_uint16_t cmdid,
                   a_uint8_t *buffer, a_int32_t len)
 {
     a_status_t status = A_STATUS_OK;
@@ -4485,7 +4492,7 @@ atd_tgt_set_filterframe(void *ctx, a_uint16_t cmdid,
     filterframe = (atd_filter_t *)(buffer + sizeof(atd_hdr_t));
 
 
-    atd_trace(ATD_DEBUG_CFG, ("radio %d vap %d ", 
+    atd_trace(ATD_DEBUG_CFG, ("radio %d vap %d ",
               atdhdr->wifi_index, atdhdr->vap_index));
 
     wifisc = atsc->wifi_list[atdhdr->wifi_index];
@@ -4506,7 +4513,7 @@ atd_tgt_set_filterframe(void *ctx, a_uint16_t cmdid,
     if(fltrfrm == NULL){
         atd_trace(ATD_DEBUG_CFG, ("\n %s : allocation failed\n", __FUNCTION__));
         status = A_STATUS_ENOMEM;
-        goto fail; 
+        goto fail;
     }
 
     fltrfrm->app_filterype = ntohl(filterframe->filter);
@@ -4517,8 +4524,8 @@ atd_tgt_set_filterframe(void *ctx, a_uint16_t cmdid,
     iwpdata->flags = 0;
     iwpdata->pointer = (char *)fltrfrm;
 
-    status = netdev_wext_handler(vap->vap_netdev, IEEE80211_IOCTL_FILTERFRAME, &info, 
-                                 &iwreqdata, (char *)fltrfrm); 
+    status = netdev_wext_handler(vap->vap_netdev, IEEE80211_IOCTL_FILTERFRAME, &info,
+                                 &iwreqdata, (char *)fltrfrm);
     if(status != A_STATUS_OK){
         atd_trace(ATD_DEBUG_CFG, ("filter frame set erro \n"));
     }
@@ -4530,16 +4537,16 @@ fail:
 }
 
 
-/** 
+/**
  * @brief Set Appiebuf
- * 
+ *
  * @param ctx
  * @param cmdid
  * @param buffer
  * @param len
  */
-void 
-atd_tgt_set_appiebuf(void *ctx, a_uint16_t cmdid, 
+void
+atd_tgt_set_appiebuf(void *ctx, a_uint16_t cmdid,
                   a_uint8_t *buffer, a_int32_t len)
 {
     a_status_t status = A_STATUS_OK;
@@ -4567,7 +4574,7 @@ atd_tgt_set_appiebuf(void *ctx, a_uint16_t cmdid,
     atdhdr = (atd_hdr_t *) buffer;
     appie = (atd_appie_t *)(buffer + sizeof(atd_hdr_t));
 
-    atd_trace(ATD_DEBUG_CFG, ("radio %d vap %d ", 
+    atd_trace(ATD_DEBUG_CFG, ("radio %d vap %d ",
               atdhdr->wifi_index, atdhdr->vap_index));
 
 
@@ -4585,26 +4592,26 @@ atd_tgt_set_appiebuf(void *ctx, a_uint16_t cmdid,
         goto fail;
     }
 
-    l = ntohl(appie->buflen);
+    l = ntohl(appie->app_buflen);
     vzalloc(sizeof(struct ieee80211req_getset_appiebuf) + l, appie_buf);
     if(appie_buf == NULL){
         atd_trace(ATD_DEBUG_CFG, ("\n %s : allocation failed\n", __FUNCTION__));
         status = A_STATUS_ENOMEM;
-        goto fail; 
+        goto fail;
     }
 
-    appie_buf->app_frmtype = ntohl(appie->frmtype);
-    appie_buf->app_buflen = ntohl(appie->buflen);
-    memcpy(appie_buf->app_buf, appie->buf, l);
+    appie_buf->app_frmtype = ntohl(appie->app_frmtype);
+    appie_buf->app_buflen = ntohl(appie->app_buflen);
+    memcpy(appie_buf->app_buf, appie->app_buf, l);
 
     info.cmd = IEEE80211_IOCTL_SET_APPIEBUF;
     info.flags = 0;
-    iwpdata->length = sizeof(struct ieee80211req_getset_appiebuf) + l; 
+    iwpdata->length = sizeof(struct ieee80211req_getset_appiebuf) + l;
     iwpdata->flags = 0;
     iwpdata->pointer = (char *)appie_buf;
 
-    status = netdev_wext_handler(vap->vap_netdev, IEEE80211_IOCTL_SET_APPIEBUF, &info, 
-                                 &iwreqdata, (char *)appie_buf); 
+    status = netdev_wext_handler(vap->vap_netdev, IEEE80211_IOCTL_SET_APPIEBUF, &info,
+                                 &iwreqdata, (char *)appie_buf);
     if(status != A_STATUS_OK){
         atd_trace(ATD_DEBUG_CFG, ("appiebuf set erro \n"));
     }
@@ -4617,16 +4624,16 @@ fail:
 
 
 
-/** 
+/**
  * @brief Del Key
- * 
+ *
  * @param ctx
  * @param cmdid
  * @param buffer
  * @param len
  */
-void 
-atd_tgt_del_key(void *ctx, a_uint16_t cmdid, 
+void
+atd_tgt_del_key(void *ctx, a_uint16_t cmdid,
                   a_uint8_t *buffer, a_int32_t len)
 {
     a_status_t status = A_STATUS_OK;
@@ -4647,7 +4654,7 @@ atd_tgt_del_key(void *ctx, a_uint16_t cmdid,
     delkey = (atd_delkey_t *)(buffer + sizeof(atd_hdr_t));
 
 
-    atd_trace(ATD_DEBUG_CFG, ("radio %d vap %d ", 
+    atd_trace(ATD_DEBUG_CFG, ("radio %d vap %d ",
               atdhdr->wifi_index, atdhdr->vap_index));
 
     wifisc = atsc->wifi_list[atdhdr->wifi_index];
@@ -4668,7 +4675,7 @@ atd_tgt_del_key(void *ctx, a_uint16_t cmdid,
     if(del_key == NULL){
             printk("\n %s : allocation failed\n", __FUNCTION__);
             status = A_STATUS_ENOMEM;
-            goto fail; 
+            goto fail;
     }
 
     del_key->idk_keyix = delkey->idx;
@@ -4676,12 +4683,12 @@ atd_tgt_del_key(void *ctx, a_uint16_t cmdid,
 
     info.cmd = IEEE80211_IOCTL_DELKEY;
     info.flags = 0;
-    iwpdata->length = sizeof(struct ieee80211req_del_key); 
+    iwpdata->length = sizeof(struct ieee80211req_del_key);
     iwpdata->flags = 0;
     iwpdata->pointer = (char *)del_key;
 
-    status = netdev_wext_handler(vap->vap_netdev, IEEE80211_IOCTL_DELKEY, &info, 
-                                 &iwreqdata, (char *)del_key); 
+    status = netdev_wext_handler(vap->vap_netdev, IEEE80211_IOCTL_DELKEY, &info,
+                                 &iwreqdata, (char *)del_key);
     if(status != A_STATUS_OK){
         atd_trace(ATD_DEBUG_CFG, ("del key set erro \n"));
     }
@@ -4694,16 +4701,16 @@ fail:
 
 
 
-/** 
+/**
  * @brief Set Key
- * 
+ *
  * @param ctx
  * @param cmdid
  * @param buffer
  * @param len
  */
-void 
-atd_tgt_set_key(void *ctx, a_uint16_t cmdid, 
+void
+atd_tgt_set_key(void *ctx, a_uint16_t cmdid,
                   a_uint8_t *buffer, a_int32_t len)
 {
     a_status_t status = A_STATUS_OK;
@@ -4724,7 +4731,7 @@ atd_tgt_set_key(void *ctx, a_uint16_t cmdid,
     atdhdr = (atd_hdr_t *) buffer;
     setkey = (atd_key_t *)(buffer + sizeof(atd_hdr_t));
 
-    atd_trace(ATD_DEBUG_CFG, ("radio %d vap %d ", 
+    atd_trace(ATD_DEBUG_CFG, ("radio %d vap %d ",
               atdhdr->wifi_index, atdhdr->vap_index));
 
     wifisc = atsc->wifi_list[atdhdr->wifi_index];
@@ -4745,18 +4752,20 @@ atd_tgt_set_key(void *ctx, a_uint16_t cmdid,
     if(ik == NULL){
         atd_trace(ATD_DEBUG_CFG, ("\n %s : allocation failed\n", __FUNCTION__));
         status = A_STATUS_ENOMEM;
-        goto fail; 
+        goto fail;
     }
 
-    ik->ik_type = setkey->type;
-    ik->ik_pad = setkey->pad;
-    ik->ik_keyix = ntohs(setkey->keyix);
-    ik->ik_keylen = setkey->keylen;
-    ik->ik_flags = setkey->flags;
-    memcpy(ik->ik_macaddr, setkey->macaddr, ACFG_MACADDR_LEN);
-    ik->ik_keyrsc = be64_to_cpu(setkey->keyrsc);
-    ik->ik_keytsc = be64_to_cpu(setkey->keytsc);
-    memcpy(ik->ik_keydata, setkey->keydata, ACFG_KEYDATA_LEN);
+    memcpy(ik, setkey, sizeof(*ik));
+
+    ik->ik_type = setkey->ik_type;
+    ik->ik_pad = setkey->ik_pad;
+    ik->ik_keyix = ntohs(setkey->ik_keyix);
+    ik->ik_keylen = setkey->ik_keylen;
+    ik->ik_flags = setkey->ik_flags;
+    memcpy(ik->ik_macaddr, setkey->ik_macaddr, ACFG_MACADDR_LEN);
+    ik->ik_keyrsc = be64_to_cpu(setkey->ik_keyrsc);
+    ik->ik_keytsc = be64_to_cpu(setkey->ik_keytsc);
+    memcpy(ik->ik_keydata, setkey->ik_keydata, ACFG_KEYDATA_LEN);
 
     info.cmd = IEEE80211_IOCTL_SETKEY;
     info.flags = 0;
@@ -4764,8 +4773,8 @@ atd_tgt_set_key(void *ctx, a_uint16_t cmdid,
     iwpdata->flags = 0;
     iwpdata->pointer = (char *)ik;
 
-    status = netdev_wext_handler(vap->vap_netdev, IEEE80211_IOCTL_SETKEY, &info, 
-                                 &iwreqdata, (char *)ik); 
+    status = netdev_wext_handler(vap->vap_netdev, IEEE80211_IOCTL_SETKEY, &info,
+                                 &iwreqdata, (char *)ik);
     if(status != A_STATUS_OK){
         atd_trace(ATD_DEBUG_CFG, ("set key set erro \n"));
     }
@@ -4776,16 +4785,16 @@ fail:
     wmi_cmd_rsp(atsc->wmi_handle, cmdid, status, NULL, 0);
 }
 
-/** 
+/**
  * @brief Get Key
- * 
+ *
  * @param ctx
  * @param cmdid
  * @param buffer
  * @param len
  */
-void 
-atd_tgt_get_key(void *ctx, a_uint16_t cmdid, 
+void
+atd_tgt_get_key(void *ctx, a_uint16_t cmdid,
                   a_uint8_t *buffer, a_int32_t len)
 {
     a_status_t status = A_STATUS_OK;
@@ -4796,12 +4805,12 @@ atd_tgt_get_key(void *ctx, a_uint16_t cmdid,
     struct iwreq req = {{{0}}};
     atd_key_t *getkey, *result = NULL;
     struct ieee80211req_key *ik = NULL;
-    
+
     atd_trace(ATD_DEBUG_FUNCTRACE, ("cmd %d    ",\
                 cmdid));
 
     atd_assert(len >= (sizeof(atd_hdr_t) + sizeof(atd_key_t)));
-  
+
     atdhdr = (atd_hdr_t *) buffer;
     getkey = (atd_key_t *)(buffer + sizeof(atd_hdr_t)) ;
 
@@ -4824,25 +4833,27 @@ atd_tgt_get_key(void *ctx, a_uint16_t cmdid,
     if(ik == NULL){
         atd_trace(ATD_DEBUG_CFG, ("\n %s : allocation failed\n", __FUNCTION__));
         status = A_STATUS_ENOMEM;
-        goto fail; 
+        goto fail;
     }
 
     vzalloc(sizeof(atd_key_t), result);
     if(result == NULL){
         atd_trace(ATD_DEBUG_CFG, ("\n %s : allocation failed\n", __FUNCTION__));
         status = A_STATUS_ENOMEM;
-        goto fail; 
+        goto fail;
     }
 
-    ik->ik_type = getkey->type;
-    ik->ik_pad = getkey->pad;
-    ik->ik_keyix = ntohs(getkey->keyix);
-    ik->ik_keylen = getkey->keylen;
-    ik->ik_flags = getkey->flags;
-    memcpy(ik->ik_macaddr, getkey->macaddr, ACFG_MACADDR_LEN);
-    ik->ik_keyrsc = be64_to_cpu(getkey->keyrsc);
-    ik->ik_keytsc = be64_to_cpu(getkey->keytsc);
-    memcpy(ik->ik_keydata, getkey->keydata, ACFG_KEYDATA_LEN);
+    memcpy(ik, getkey, sizeof(*ik));
+
+    ik->ik_type = getkey->ik_type;
+    ik->ik_pad = getkey->ik_pad;
+    ik->ik_keyix = ntohs(getkey->ik_keyix);
+    ik->ik_keylen = getkey->ik_keylen;
+    ik->ik_flags = getkey->ik_flags;
+    memcpy(ik->ik_macaddr, getkey->ik_macaddr, ACFG_MACADDR_LEN);
+    ik->ik_keyrsc = be64_to_cpu(getkey->ik_keyrsc);
+    ik->ik_keytsc = be64_to_cpu(getkey->ik_keytsc);
+    memcpy(ik->ik_keydata, getkey->ik_keydata, ACFG_KEYDATA_LEN);
 
     req.u.data.pointer  = (a_uint8_t *)ik;
     req.u.data.length   = sizeof(struct ieee80211req_key);
@@ -4851,22 +4862,24 @@ atd_tgt_get_key(void *ctx, a_uint16_t cmdid,
 #define IOCTL_GET_KEY (SIOCDEVPRIVATE + 3)
     status = netdev_ioctl(vap->vap_netdev, (struct ifreq *)&req, IOCTL_GET_KEY);
 
-    result->type = ik->ik_type;
-    result->pad = ik->ik_pad;
-    result->keyix = htons(ik->ik_keyix);
-    result->keylen = ik->ik_keylen;
-    result->flags = ik->ik_flags;
-    memcpy(result->macaddr, ik->ik_macaddr, ACFG_MACADDR_LEN);
-    result->keyrsc = cpu_to_be64(ik->ik_keyrsc);
-    result->keytsc = cpu_to_be64(ik->ik_keytsc);
-    memcpy(result->keydata, ik->ik_keydata, ACFG_KEYDATA_LEN);
+    memcpy(result, ik, sizeof(*result));
+
+    result->ik_type = ik->ik_type;
+    result->ik_pad = ik->ik_pad;
+    result->ik_keyix = htons(ik->ik_keyix);
+    result->ik_keylen = ik->ik_keylen;
+    result->ik_flags = ik->ik_flags;
+    memcpy(result->ik_macaddr, ik->ik_macaddr, ACFG_MACADDR_LEN);
+    result->ik_keyrsc = cpu_to_be64(ik->ik_keyrsc);
+    result->ik_keytsc = cpu_to_be64(ik->ik_keytsc);
+    memcpy(result->ik_keydata, ik->ik_keydata, ACFG_KEYDATA_LEN);
 
     req.u.data.length = sizeof(atd_key_t);
-   
+
     atd_trace(ATD_DEBUG_FUNCTRACE,("getkey %p \n", getkey));
- 
+
 fail:
-    wmi_cmd_rsp(atsc->wmi_handle, cmdid, status, (a_uint8_t *)result, 
+    wmi_cmd_rsp(atsc->wmi_handle, cmdid, status, (a_uint8_t *)result,
                 req.u.data.length);
     if (result)
         vfree(result);
@@ -4875,8 +4888,8 @@ fail:
 }
 
 
-void 
-atd_tgt_get_sta_stats(void *ctx, a_uint16_t cmdid, 
+void
+atd_tgt_get_sta_stats(void *ctx, a_uint16_t cmdid,
                   a_uint8_t *buffer, a_int32_t len)
 {
     a_status_t status = A_STATUS_OK;
@@ -4888,7 +4901,7 @@ atd_tgt_get_sta_stats(void *ctx, a_uint16_t cmdid,
     void *p_stats;
     struct iwreq req = {{{0}}};
     uint32_t pldlen = 0;
-    
+
     atd_trace(ATD_DEBUG_FUNCTRACE, ("cmd %d    ",\
                 cmdid));
 
@@ -4922,14 +4935,14 @@ atd_tgt_get_sta_stats(void *ctx, a_uint16_t cmdid,
         if(statsbuff == NULL){
             atd_trace(ATD_DEBUG_CFG, ("\n %s : allocation failed\n", __FUNCTION__));
             status = A_STATUS_ENOMEM;
-            goto fail; 
+            goto fail;
         }
 
         memcpy((a_uint8_t *)statsbuff, (char *)p_stats + sizeof(a_uint32_t), VALID_PAYLOAD_SIZE);
     }
 
     req.u.data.pointer  = (a_uint8_t *)statsbuff;
-    req.u.data.length   = pldlen; 
+    req.u.data.length   = pldlen;
     req.u.data.flags    = 1;
 
 #define IOCTL_STA_STATS (SIOCDEVPRIVATE + 5)
@@ -4939,7 +4952,7 @@ atd_tgt_get_sta_stats(void *ctx, a_uint16_t cmdid,
     atd_trace(ATD_DEBUG_FUNCTRACE,("stats %p \n", p_stats));
 
 fail:
-    wmi_cmd_rsp(atsc->wmi_handle, cmdid, status, (a_uint8_t *)statsbuff, 
+    wmi_cmd_rsp(atsc->wmi_handle, cmdid, status, (a_uint8_t *)statsbuff,
                 req.u.data.length);
     if(statsbuff)
         vfree(statsbuff);
@@ -4947,7 +4960,7 @@ fail:
 
 
 /**
- * ATD Events 
+ * ATD Events
  */
 #define PROTO_EVENT(name)   \
     static void atd_tgt_##name(struct net_device  *dev, \
@@ -4965,7 +4978,7 @@ PROTO_EVENT(if_running_sta);
 PROTO_EVENT(if_not_running_sta);
 PROTO_EVENT(leave_ap);
 PROTO_EVENT(gen_ie);
-//PROTO_EVENT(assoc_req_ie);
+PROTO_EVENT(assoc_req_ie);
 PROTO_EVENT(iw_custom);
 PROTO_EVENT(iw_assocreqie);
 
@@ -4985,7 +4998,7 @@ PROTO_EVENT(iw_deauth_ind_ap);
 PROTO_EVENT(iw_disassoc_ind_ap);
 PROTO_EVENT(iw_wapi);
 
-typedef void (*__atd_event_fn_t)(struct net_device *dev, 
+typedef void (*__atd_event_fn_t)(struct net_device *dev,
                                  union iwreq_data  *wreq, const int8_t  *buf);
 
 typedef struct custom_event {
@@ -5011,7 +5024,7 @@ const __atd_event_fn_t     atd_events[] = {
     EVENT_IDX(WMI_EVENT_IF_NOT_RUNNING_STA) = atd_tgt_if_not_running_sta,
     EVENT_IDX(WMI_EVENT_LEAVE_AP)       = atd_tgt_leave_ap,
     EVENT_IDX(WMI_EVENT_GEN_IE)         = atd_tgt_gen_ie,
-    //EVENT_IDX(WMI_EVENT_ASSOC_REQ_IE)   = atd_tgt_assoc_req_ie,
+    EVENT_IDX(WMI_EVENT_ASSOC_REQ_IE)   = atd_tgt_assoc_req_ie,
     EVENT_IDX(WMI_EVENT_IW_CUSTOM)      = atd_tgt_iw_custom,
     EVENT_IDX(WMI_EVENT_IW_ASSOCREQIE)  = atd_tgt_iw_assocreqie,
 
@@ -5053,12 +5066,12 @@ custom_event_t      iw_custom_events[] = {
 #define iw_custom_events_sz  \
     (sizeof(iw_custom_events)/sizeof(iw_custom_events[0]))
 
-/** 
+/**
  * @brief Convert a Custom IW event into a WMI_EVENT
- * 
+ *
  * @param extra
- * 
- * @return 
+ *
+ * @return
  */
 wmi_id_t
 custom_to_wmi(union iwreq_data      *wreq, const int8_t  *extra)
@@ -5104,7 +5117,7 @@ custom_to_wmi(union iwreq_data      *wreq, const int8_t  *extra)
         return WMI_EVENT_DISASSOC_IND_AP;
     else if (wreq->data.flags == IEEE80211_EV_WAPI)
         return WMI_EVENT_WAPI;
-		
+
     if(!extra){
         if (wreq->data.flags == IEEE80211_EV_IF_RUNNING){
             return WMI_EVENT_IF_RUNNING_STA;
@@ -5123,13 +5136,13 @@ custom_to_wmi(union iwreq_data      *wreq, const int8_t  *extra)
     return WMI_EVENT_START;
 }
 
-/** 
+/**
  * @brief Convert the IW Command into a WMI event
- * 
+ *
  * @param iw_cmd    (IW Command)
  * @param extra     (Command specific data)
- * 
- * @return 
+ *
+ * @return
  */
 static inline wmi_id_t
 iw_to_wmi_event(int iw_cmd, union iwreq_data      *wreq, const int8_t  *extra)
@@ -5140,16 +5153,16 @@ iw_to_wmi_event(int iw_cmd, union iwreq_data      *wreq, const int8_t  *extra)
         case SIOCGIWAP:         return WMI_EVENT_ASSOC_STA;
         case IWEVCUSTOM:        return custom_to_wmi(wreq, extra);
         case IWEVEXPIRED:       return WMI_EVENT_LEAVE_AP;
-        //case IWEVASSOCREQIE:    return WMI_EVENT_ASSOC_REQ_IE;
+        case IWEVASSOCREQIE:    return WMI_EVENT_ASSOC_REQ_IE;
         case IWEVGENIE:         return WMI_EVENT_GEN_IE;
-        case IWEVASSOCREQIE:    return custom_to_wmi(wreq, extra);
+//        case IWEVASSOCREQIE:    return custom_to_wmi(wreq, extra);
         default:                return WMI_EVENT_START;
     }
 }
 
-/** 
+/**
  * @brief ATD Event handler function called from the WLAN driver
- * 
+ *
  * @param dev   (Netdevice handle)
  * @param cmd   (IW Command)
  * @param wreq  (Wireless request)
@@ -5160,31 +5173,30 @@ atd_event_handler(struct net_device     *dev, unsigned int  cmd,
 			      union iwreq_data      *wreq, char *extra)
 {
     a_uint32_t  index;
-    
+
     atd_trace(ATD_DEBUG_FUNCTRACE, (".START"));
 
     index = EVENT_NUM(iw_to_wmi_event(cmd, wreq, extra));
-    
+
     atd_trace(ATD_DEBUG_CFG, ("index = %x",index));
 
     atd_trace(ATD_DEBUG_CFG, (">>> Events %d\n",index));
-    if(atd_events[index]) atd_events[index](dev, wreq, extra); 
+    if(atd_events[index]) atd_events[index](dev, wreq, extra);
 
     wireless_send_event(dev, cmd, wreq, extra);
 
     atd_trace(ATD_DEBUG_FUNCTRACE, (".END"));
 }
-EXPORT_SYMBOL(atd_event_handler);
 
-/** 
- * @brief 
- * 
+/**
+ * @brief
+ *
  * @param dev
  * @param wreq
  * @param buf
  */
-static void 
-atd_tgt_noevent(struct net_device  *dev, union iwreq_data  *wreq, 
+static void
+atd_tgt_noevent(struct net_device  *dev, union iwreq_data  *wreq,
                const int8_t   *buf)
 {
     atd_trace(ATD_DEBUG_CFG, ("%s:No event mapping with WMI \n", __func__));
@@ -5192,15 +5204,15 @@ atd_tgt_noevent(struct net_device  *dev, union iwreq_data  *wreq,
 }
 
 
-/** 
- * @brief 
- * 
+/**
+ * @brief
+ *
  * @param dev
  * @param dev_sc
  * @param skb
  * @param payload_len
- * 
- * @return 
+ *
+ * @return
  */
 atd_tgt_vap_t *
 atd_tgt_vap_event_alloc(struct net_device  *dev, atd_tgt_dev_t  *dev_sc,
@@ -5217,7 +5229,7 @@ atd_tgt_vap_event_alloc(struct net_device  *dev, atd_tgt_dev_t  *dev_sc,
         atd_trace(ATD_DEBUG_CFG, ("%s:unknown interface %s", __func__, dev->name));
         return NULL;
     }
-    
+
     payload_len += sizeof(struct atd_hdr);
 
     *skb = wmi_alloc_event(dev_sc->wmi_handle, payload_len);
@@ -5226,22 +5238,22 @@ atd_tgt_vap_event_alloc(struct net_device  *dev, atd_tgt_dev_t  *dev_sc,
     }
 
     hdr = (void *)skb_put(*skb, sizeof(struct atd_hdr));
-    
+
     hdr->wifi_index = vap->wifisc->wifi_index;
     hdr->vap_index  = vap->vap_index;
 
     return vap;
 }
 
-/** 
- * @brief 
- * 
+/**
+ * @brief
+ *
  * @param dev
  * @param dev_sc
  * @param skb
  * @param payload_len
- * 
- * @return 
+ *
+ * @return
  */
 atd_tgt_wifi_t *
 atd_tgt_wifi_event_alloc(struct net_device  *dev, atd_tgt_dev_t  *dev_sc,
@@ -5255,7 +5267,7 @@ atd_tgt_wifi_event_alloc(struct net_device  *dev, atd_tgt_dev_t  *dev_sc,
         atd_trace(ATD_DEBUG_CFG, ("%s:unknown interface %s", __func__, dev->name));
         return NULL;
     }
-    
+
     payload_len += sizeof(struct atd_hdr);
 
     *skb = wmi_alloc_event(dev_sc->wmi_handle, payload_len);
@@ -5265,16 +5277,16 @@ atd_tgt_wifi_event_alloc(struct net_device  *dev, atd_tgt_dev_t  *dev_sc,
     }
 
     hdr = (void *)skb_put(*skb, sizeof(struct atd_hdr));
-    
+
     hdr->wifi_index = wifi->wifi_index;
     hdr->vap_index  = 0xFF;
 
     return wifi;
 }
 
-/** 
+/**
  * @brief Send a VAP Specific event
- * 
+ *
  * @param vap
  * @param event
  */
@@ -5289,18 +5301,18 @@ atd_tgt_vap_event(atd_tgt_vap_t  *vap, wmi_id_t  event)
     payload_len = sizeof(struct atd_hdr);
 
     skb = wmi_alloc_event(dev_sc->wmi_handle, payload_len);
-    
+
     hdr = (void *)skb_put(skb, payload_len);
-    
+
     hdr->wifi_index = vap->wifisc->wifi_index;
     hdr->vap_index  = vap->vap_index;
 
     wmi_send_event(dev_sc->wmi_handle, skb, event);
 }
 
-/** 
+/**
  * @brief Send a WIFI Specific event
- * 
+ *
  * @param vap
  * @param event
  */
@@ -5315,22 +5327,22 @@ atd_tgt_wifi_event(atd_tgt_wifi_t  *wifi, wmi_id_t  event)
     payload_len = sizeof(struct atd_hdr);
 
     skb = wmi_alloc_event(dev_sc->wmi_handle, payload_len);
-    
+
     hdr = (void *)skb_put(skb, payload_len);
-    
+
     hdr->wifi_index = wifi->wifi_index;
     hdr->vap_index  = 0xFF;
 
     wmi_send_event(dev_sc->wmi_handle, skb, event);
 }
-/** 
- * @brief 
- * 
+/**
+ * @brief
+ *
  * @param dev
  * @param wreq
  * @param buf
  */
-void 
+void
 atd_tgt_create_vap(atd_tgt_vap_t  *vap, wmi_id_t  event)
 {
     atd_tgt_dev_t      *dev_sc = g_atd_dev;
@@ -5347,17 +5359,17 @@ atd_tgt_create_vap(atd_tgt_vap_t  *vap, wmi_id_t  event)
     payload->vap_index = vap->vap_index;
     strncpy(payload->if_name, vap->vap_netdev->name, ACFG_MAX_IFNAME);
     memcpy(payload->mac_addr, vap->mac_addr, ACFG_MACADDR_LEN);
-    
+
     wmi_send_event(dev_sc->wmi_handle, skb, event);
 done:
     return;
-} 
+}
 
 /**
  * @brief
  *
- * @param wifi 
- * @param event 
+ * @param wifi
+ * @param event
  */
 void
 atd_tgt_restore_wifi(atd_tgt_wifi_t  *wifi, wmi_id_t  event)
@@ -5369,7 +5381,7 @@ atd_tgt_restore_wifi(atd_tgt_wifi_t  *wifi, wmi_id_t  event)
 
     if (!atd_tgt_wifi_event_alloc(wifi->netdev, dev_sc, &skb, payload_len))
         goto done;
-    
+
     payload = (void *)skb_put(skb, payload_len);
 
     payload->wifi_index = wifi->wifi_index;
@@ -5406,11 +5418,10 @@ atd_proxy_arp_send(struct sk_buff *wbuf)
     wmi_send_event(dev_sc->wmi_handle, skb, WMI_EVENT_PROXYARP_SEND);
 
 done:
-    return;    
-} 
+    return;
+}
 
-EXPORT_SYMBOL(atd_proxy_arp_send);
-void atd_convert_spectral_samp_msg_hton(atd_spectral_samp_msg_t *out, 
+void atd_convert_spectral_samp_msg_hton(atd_spectral_samp_msg_t *out,
         atd_spectral_samp_msg_t *in)
 {
     int i;
@@ -5472,8 +5483,8 @@ void atd_convert_spectral_samp_msg_hton(atd_spectral_samp_msg_t *out,
 }
 
 void
-atd_spectral_msg_send(struct net_device *dev, 
-        SPECTRAL_SAMP_MSG *msg, 
+atd_spectral_msg_send(struct net_device *dev,
+        SPECTRAL_SAMP_MSG *msg,
         a_uint16_t msg_len)
 {
     atd_tgt_dev_t       *dev_sc = g_atd_dev;
@@ -5484,9 +5495,9 @@ atd_spectral_msg_send(struct net_device *dev,
 
     atd_trace(ATD_DEBUG_FUNCTRACE,(" Start"));
 
-    skb = wmi_alloc_event(dev_sc->wmi_handle, 
+    skb = wmi_alloc_event(dev_sc->wmi_handle,
             sizeof(struct atd_hdr) + msg_len);
-    hdr = (void *)skb_put(skb, 
+    hdr = (void *)skb_put(skb,
             sizeof(struct atd_hdr) + msg_len);
     payload = (atd_spectral_samp_msg_t *)(hdr + 1);
 
@@ -5501,8 +5512,6 @@ atd_spectral_msg_send(struct net_device *dev,
     wmi_send_event(dev_sc->wmi_handle, skb, WMI_EVENT_SPECTRAL_MSG_SEND);
 }
 
-EXPORT_SYMBOL(atd_spectral_msg_send);
-
 /**
  * @brief
  *
@@ -5586,6 +5595,7 @@ atd_bsteer_event_send(struct net_device *dev,
     atd_hdr_t           *hdr;
     atd_bsteering_event_t *payload;
     struct sk_buff      *skb   = NULL;
+    atd_tgt_vap_t       *vap   = NULL;
 
     atd_trace(ATD_DEBUG_FUNCTRACE,(" Start"));
 
@@ -5595,27 +5605,31 @@ atd_bsteer_event_send(struct net_device *dev,
             sizeof(struct atd_hdr) + msg_len);
     payload = (atd_bsteering_event_t *)(hdr + 1);
 
-    wifi = atd_tgt_find_wifi(dev_sc, dev);
+    vap = atd_tgt_find_vap(dev_sc, dev);
+    if(!vap) {
+        atd_trace(ATD_DEBUG_CFG, ("%s:unknown interface %s", __func__, dev->name));
+        return NULL;
+    }
 
+    wifi = vap->wifisc;
+    hdr->vap_index  = vap->vap_index;
     hdr->wifi_index = wifi->wifi_index;
-    hdr->vap_index  = 0xFF;
 
     /* Its time todo hton convertion */
     atd_convert_bsteer_event_hton(payload, event);
 
     wmi_send_event(dev_sc->wmi_handle, skb, WMI_EVENT_BSTEER_SEND);
 }
-EXPORT_SYMBOL(atd_bsteer_event_send);
 
-/** 
- * @brief 
- * 
+/**
+ * @brief
+ *
  * @param dev
  * @param wreq
  * @param buf
  */
-static void 
-atd_tgt_chan_start(struct net_device  *dev, union iwreq_data  *wreq, 
+static void
+atd_tgt_chan_start(struct net_device  *dev, union iwreq_data  *wreq,
                   const int8_t   *buf)
 {
     atd_tgt_dev_t      *dev_sc = g_atd_dev;
@@ -5623,7 +5637,7 @@ atd_tgt_chan_start(struct net_device  *dev, union iwreq_data  *wreq,
     struct sk_buff     *skb = NULL;
     atd_chan_start_t   *payload;
     acfg_chan_start_t  *chan_start = (acfg_chan_start_t *)buf;
-    
+
     atd_trace(ATD_DEBUG_FUNCTRACE, (".START"));
 
     if (!atd_tgt_vap_event_alloc(dev, dev_sc, &skb, payload_len))
@@ -5641,17 +5655,17 @@ atd_tgt_chan_start(struct net_device  *dev, union iwreq_data  *wreq,
 done:
     return;
 
-} 
+}
 
-/** 
- * @brief 
- * 
- * @param dev
- * @param wreq
+/**
+ * @brief
+ *
+ * @param dev
+ * @param wreq
  * @param buf
  */
-static void 
-atd_tgt_chan_end(struct net_device  *dev, union iwreq_data  *wreq, 
+static void
+atd_tgt_chan_end(struct net_device  *dev, union iwreq_data  *wreq,
                   const int8_t   *buf)
 {
     atd_tgt_dev_t      *dev_sc = g_atd_dev;
@@ -5659,14 +5673,14 @@ atd_tgt_chan_end(struct net_device  *dev, union iwreq_data  *wreq,
     struct sk_buff     *skb = NULL;
     atd_chan_end_t     *payload;
     acfg_chan_end_t    *chan_end = (acfg_chan_end_t *)buf;
-    
+
     atd_trace(ATD_DEBUG_FUNCTRACE, (".START"));
 
     if (!atd_tgt_vap_event_alloc(dev, dev_sc, &skb, payload_len))
         goto done;
 
     payload = (atd_chan_end_t *)skb_put(skb, payload_len);
-    
+
     payload->freq = htonl(chan_end->freq);
     payload->reason = htonl(chan_end->reason);
     payload->duration = htonl(chan_end->duration);
@@ -5678,23 +5692,23 @@ atd_tgt_chan_end(struct net_device  *dev, union iwreq_data  *wreq,
 done:
     return;
 
-} 
+}
 
-/** 
- * @brief 
- * 
+/**
+ * @brief
+ *
  * @param dev
  * @param wreq
  * @param buf
  */
-static void 
-atd_tgt_rx_mgmt(struct net_device  *dev, union iwreq_data  *wreq, 
+static void
+atd_tgt_rx_mgmt(struct net_device  *dev, union iwreq_data  *wreq,
                   const int8_t   *buf)
 {
     atd_tgt_dev_t      *dev_sc = g_atd_dev;
     a_uint32_t          payload_len = wreq->data.length;
     struct sk_buff     *skb = NULL;
-    
+
     atd_trace(ATD_DEBUG_FUNCTRACE, (".START"));
 
     if (!atd_tgt_vap_event_alloc(dev, dev_sc, &skb, payload_len))
@@ -5706,23 +5720,23 @@ atd_tgt_rx_mgmt(struct net_device  *dev, union iwreq_data  *wreq,
 done:
     return;
 
-} 
+}
 
-/** 
- * @brief 
- * 
+/**
+ * @brief
+ *
  * @param dev
  * @param wreq
  * @param buf
  */
-static void 
-atd_tgt_sent_action(struct net_device  *dev, union iwreq_data  *wreq, 
+static void
+atd_tgt_sent_action(struct net_device  *dev, union iwreq_data  *wreq,
                   const int8_t   *buf)
 {
     atd_tgt_dev_t      *dev_sc = g_atd_dev;
     a_uint32_t          payload_len = wreq->data.length;
     struct sk_buff     *skb = NULL;
-    
+
     atd_trace(ATD_DEBUG_FUNCTRACE, (".START"));
 
     if (!atd_tgt_vap_event_alloc(dev, dev_sc, &skb, payload_len))
@@ -5734,23 +5748,23 @@ atd_tgt_sent_action(struct net_device  *dev, union iwreq_data  *wreq,
 done:
     return;
 
-} 
+}
 
-/** 
- * @brief 
- * 
+/**
+ * @brief
+ *
  * @param dev
  * @param wreq
  * @param buf
  */
 static void
-atd_tgt_leave_ap(struct net_device  *dev, union iwreq_data  *wreq, 
+atd_tgt_leave_ap(struct net_device  *dev, union iwreq_data  *wreq,
                   const int8_t   *buf)
 {
     atd_tgt_dev_t      *dev_sc = g_atd_dev;
     struct sk_buff     *skb = NULL;
     void               *payload;
-    
+
     atd_trace(ATD_DEBUG_FUNCTRACE, (".START"));
 
     if (!atd_tgt_vap_event_alloc(dev, dev_sc, &skb, IEEE80211_ADDR_LEN))
@@ -5766,24 +5780,24 @@ atd_tgt_leave_ap(struct net_device  *dev, union iwreq_data  *wreq,
 
 done:
     return;
-} 
+}
 
-/** 
- * @brief 
- * 
+/**
+ * @brief
+ *
  * @param dev
  * @param wreq
  * @param buf
  */
 static void
-atd_tgt_gen_ie(struct net_device  *dev, union iwreq_data  *wreq, 
+atd_tgt_gen_ie(struct net_device  *dev, union iwreq_data  *wreq,
                   const int8_t   *buf)
 {
     atd_tgt_dev_t      *dev_sc = g_atd_dev;
     struct sk_buff     *skb = NULL;
     void               *payload;
     a_uint32_t          payload_len = wreq->data.length;
-    
+
     atd_trace(ATD_DEBUG_FUNCTRACE, (".START"));
 
     if (!atd_tgt_vap_event_alloc(dev, dev_sc, &skb, payload_len))
@@ -5799,25 +5813,24 @@ atd_tgt_gen_ie(struct net_device  *dev, union iwreq_data  *wreq,
 
 done:
     return;
-} 
+}
 
-#if 0
-/** 
- * @brief 
- * 
+/**
+ * @brief
+ *
  * @param dev
  * @param wreq
  * @param buf
  */
 static void
-atd_tgt_assoc_req_ie(struct net_device  *dev, union iwreq_data  *wreq, 
+atd_tgt_assoc_req_ie(struct net_device  *dev, union iwreq_data  *wreq,
                   const int8_t   *buf)
 {
     atd_tgt_dev_t      *dev_sc = g_atd_dev;
     struct sk_buff     *skb = NULL;
     void               *payload;
     a_uint32_t          payload_len = wreq->data.length;
-    
+
     atd_trace(ATD_DEBUG_FUNCTRACE, (".START"));
 
     if (!atd_tgt_vap_event_alloc(dev, dev_sc, &skb, payload_len))
@@ -5833,18 +5846,17 @@ atd_tgt_assoc_req_ie(struct net_device  *dev, union iwreq_data  *wreq,
 
 done:
     return;
-} 
-#endif
+}
 
-/** 
- * @brief 
- * 
+/**
+ * @brief
+ *
  * @param dev
  * @param wreq
  * @param buf
  */
-static void 
-atd_tgt_assoc_ap(struct net_device  *dev, union iwreq_data  *wreq, 
+static void
+atd_tgt_assoc_ap(struct net_device  *dev, union iwreq_data  *wreq,
                  const int8_t   *buf)
 {
     atd_tgt_dev_t      *dev_sc = g_atd_dev;
@@ -5859,28 +5871,28 @@ atd_tgt_assoc_ap(struct net_device  *dev, union iwreq_data  *wreq,
 
     payload->status = htonl(ACFG_ASSOC_SUCCESS);
     memcpy(payload->bssid, wreq->addr.sa_data, ACFG_MACADDR_LEN);
-    
+
     wmi_send_event(dev_sc->wmi_handle, skb, WMI_EVENT_ASSOC_AP);
 done:
     return;
-} 
+}
 
-/** 
- * @brief 
- * 
+/**
+ * @brief
+ *
  * @param dev
  * @param wreq
  * @param buf
  */
-static void 
-atd_tgt_assoc_sta(struct net_device  *dev, union iwreq_data  *wreq, 
+static void
+atd_tgt_assoc_sta(struct net_device  *dev, union iwreq_data  *wreq,
                   const int8_t   *buf)
 {
     atd_tgt_dev_t      *dev_sc = g_atd_dev;
     atd_assoc_sta_t    *payload;
     a_uint32_t          payload_len = sizeof(*payload);
     struct sk_buff     *skb = NULL;
-    
+
     atd_trace(ATD_DEBUG_FUNCTRACE, (".START"));
 
     if (!atd_tgt_vap_event_alloc(dev, dev_sc, &skb, payload_len))
@@ -5891,35 +5903,35 @@ atd_tgt_assoc_sta(struct net_device  *dev, union iwreq_data  *wreq,
     payload->status = htonl(ACFG_ASSOC_SUCCESS);
     memcpy(payload->bssid, wreq->addr.sa_data, ACFG_MACADDR_LEN);
     memset(&payload->ssid, 0, sizeof(atd_ssid_t));
-    
+
     atd_trace(ATD_DEBUG_FUNCTRACE, (".END"));
 
     wmi_send_event(dev_sc->wmi_handle, skb, WMI_EVENT_ASSOC_STA);
 done:
     return;
 
-} 
+}
 
-/** 
- * @brief 
- * 
+/**
+ * @brief
+ *
  * @param dev
  * @param wreq
  * @param buf
  */
-static void 
-atd_tgt_iw_custom(struct net_device  *dev, union iwreq_data  *wreq, 
+static void
+atd_tgt_iw_custom(struct net_device  *dev, union iwreq_data  *wreq,
                   const int8_t   *buf)
 {
     atd_tgt_dev_t      *dev_sc = g_atd_dev;
     acfg_wsupp_custom_message_t *payload;
     a_uint32_t          payload_len = sizeof(*payload);
     struct sk_buff     *skb = NULL;
-    
+
     atd_trace(ATD_DEBUG_FUNCTRACE, (".START"));
 
-    /* 
-     * buf len should be less than raw message. 
+    /*
+     * buf len should be less than raw message.
      * This is to leave atleast a byte to null terminate in the following memset.
      * XXX: Assumes the custom message is always a string.
      */
@@ -5933,29 +5945,29 @@ atd_tgt_iw_custom(struct net_device  *dev, union iwreq_data  *wreq,
     memset(payload->raw_message,0,sizeof(payload->raw_message));
 
     memcpy(payload->raw_message, buf, strlen(buf));
-    
+
     atd_trace(ATD_DEBUG_FUNCTRACE, (".END"));
 
     wmi_send_event(dev_sc->wmi_handle, skb, WMI_EVENT_IW_CUSTOM);
 done:
     return;
 
-} 
+}
 
 
-/** 
- * @brief 
+/**
+ * @brief
  * IWEVASSOCREQIE is used for sending probe request frames
  * This is HACK to overcome limitations of 256 bytes of
  * IWEVCUSTOM
- * 
+ *
  * @param dev
  * @param wreq
  * @param buf
  */
 
-static void 
-atd_tgt_iw_assocreqie(struct net_device  *dev, union iwreq_data  *wreq, 
+static void
+atd_tgt_iw_assocreqie(struct net_device  *dev, union iwreq_data  *wreq,
                   const int8_t   *buf)
 {
     atd_tgt_dev_t      *dev_sc = g_atd_dev;
@@ -5980,8 +5992,8 @@ done:
 }
 
 
-static void 
-atd_tgt_iw_auth_comp_ap(struct net_device  *dev, union iwreq_data  *wreq, 
+static void
+atd_tgt_iw_auth_comp_ap(struct net_device  *dev, union iwreq_data  *wreq,
                   const int8_t   *buf)
 {
     atd_tgt_dev_t      *dev_sc = g_atd_dev;
@@ -5989,7 +6001,7 @@ atd_tgt_iw_auth_comp_ap(struct net_device  *dev, union iwreq_data  *wreq,
     a_uint32_t          payload_len = sizeof(*auth);
     struct sk_buff     *skb = NULL;
 	struct ev_msg *msg;
-    
+
     atd_trace(ATD_DEBUG_FUNCTRACE, (".START"));
 
     if (!atd_tgt_vap_event_alloc(dev, dev_sc, &skb, payload_len))
@@ -6000,14 +6012,14 @@ atd_tgt_iw_auth_comp_ap(struct net_device  *dev, union iwreq_data  *wreq,
 	auth->frame_send = 1;
 
     atd_trace(ATD_DEBUG_FUNCTRACE, (".END"));
-	
+
     wmi_send_event(dev_sc->wmi_handle, skb, WMI_EVENT_AUTH_COMP_AP);
 done:
     return;
 }
 
-static void 
-atd_tgt_iw_assoc_comp_ap(struct net_device  *dev, union iwreq_data  *wreq, 
+static void
+atd_tgt_iw_assoc_comp_ap(struct net_device  *dev, union iwreq_data  *wreq,
                   const int8_t   *buf)
 {
     atd_tgt_dev_t      *dev_sc = g_atd_dev;
@@ -6015,7 +6027,7 @@ atd_tgt_iw_assoc_comp_ap(struct net_device  *dev, union iwreq_data  *wreq,
     a_uint32_t          payload_len = sizeof(*assoc);
     struct sk_buff     *skb = NULL;
 	struct ev_msg *msg;
-    
+
     atd_trace(ATD_DEBUG_FUNCTRACE, (".START"));
     if (!atd_tgt_vap_event_alloc(dev, dev_sc, &skb, payload_len))
         goto done;
@@ -6025,14 +6037,14 @@ atd_tgt_iw_assoc_comp_ap(struct net_device  *dev, union iwreq_data  *wreq,
 	assoc->frame_send = 1;
 
     atd_trace(ATD_DEBUG_FUNCTRACE, (".END"));
-	
+
     wmi_send_event(dev_sc->wmi_handle, skb, WMI_EVENT_ASSOC_COMP_AP);
 done:
     return;
 }
 
-static void 
-atd_tgt_iw_deauth_comp_ap(struct net_device  *dev, union iwreq_data  *wreq, 
+static void
+atd_tgt_iw_deauth_comp_ap(struct net_device  *dev, union iwreq_data  *wreq,
                   const int8_t   *buf)
 {
     atd_tgt_dev_t      *dev_sc = g_atd_dev;
@@ -6040,7 +6052,7 @@ atd_tgt_iw_deauth_comp_ap(struct net_device  *dev, union iwreq_data  *wreq,
     a_uint32_t          payload_len = sizeof(*deauth);
     struct sk_buff     *skb = NULL;
 	struct ev_msg *msg;
-    
+
     atd_trace(ATD_DEBUG_FUNCTRACE, (".START"));
     if (!atd_tgt_vap_event_alloc(dev, dev_sc, &skb, payload_len))
         goto done;
@@ -6051,15 +6063,15 @@ atd_tgt_iw_deauth_comp_ap(struct net_device  *dev, union iwreq_data  *wreq,
 	deauth->frame_send = 1;
 
     atd_trace(ATD_DEBUG_FUNCTRACE, (".END"));
-	
+
     wmi_send_event(dev_sc->wmi_handle, skb, WMI_EVENT_DEAUTH_COMP_AP);
 done:
     return;
 }
 
 
-static void 
-atd_tgt_iw_auth_ind_ap(struct net_device  *dev, union iwreq_data  *wreq, 
+static void
+atd_tgt_iw_auth_ind_ap(struct net_device  *dev, union iwreq_data  *wreq,
                   const int8_t   *buf)
 {
     atd_tgt_dev_t      *dev_sc = g_atd_dev;
@@ -6067,7 +6079,7 @@ atd_tgt_iw_auth_ind_ap(struct net_device  *dev, union iwreq_data  *wreq,
     a_uint32_t          payload_len = sizeof(*auth);
     struct sk_buff     *skb = NULL;
 	struct ev_msg *msg;
-    
+
     atd_trace(ATD_DEBUG_FUNCTRACE, (".START"));
     if (!atd_tgt_vap_event_alloc(dev, dev_sc, &skb, payload_len))
         goto done;
@@ -6078,14 +6090,14 @@ atd_tgt_iw_auth_ind_ap(struct net_device  *dev, union iwreq_data  *wreq,
 	auth->frame_send = 0;
 
     atd_trace(ATD_DEBUG_FUNCTRACE, (".END"));
-	
+
     wmi_send_event(dev_sc->wmi_handle, skb, WMI_EVENT_AUTH_IND_AP);
 done:
     return;
 }
 
-static void 
-atd_tgt_iw_auth_comp_sta(struct net_device  *dev, union iwreq_data  *wreq, 
+static void
+atd_tgt_iw_auth_comp_sta(struct net_device  *dev, union iwreq_data  *wreq,
                   const int8_t   *buf)
 {
     atd_tgt_dev_t      *dev_sc = g_atd_dev;
@@ -6093,7 +6105,7 @@ atd_tgt_iw_auth_comp_sta(struct net_device  *dev, union iwreq_data  *wreq,
     a_uint32_t          payload_len = sizeof(*auth);
     struct sk_buff     *skb = NULL;
 	struct ev_msg *msg;
-    
+
     atd_trace(ATD_DEBUG_FUNCTRACE, (".START"));
     if (!atd_tgt_vap_event_alloc(dev, dev_sc, &skb, payload_len))
         goto done;
@@ -6103,14 +6115,14 @@ atd_tgt_iw_auth_comp_sta(struct net_device  *dev, union iwreq_data  *wreq,
 	auth->frame_send = 1;
 
     atd_trace(ATD_DEBUG_FUNCTRACE, (".END"));
-	
+
     wmi_send_event(dev_sc->wmi_handle, skb, WMI_EVENT_AUTH_COMP_STA);
 done:
     return;
 }
 
-static void 
-atd_tgt_iw_assoc_comp_sta(struct net_device  *dev, union iwreq_data  *wreq, 
+static void
+atd_tgt_iw_assoc_comp_sta(struct net_device  *dev, union iwreq_data  *wreq,
                   const int8_t   *buf)
 {
     atd_tgt_dev_t      *dev_sc = g_atd_dev;
@@ -6118,7 +6130,7 @@ atd_tgt_iw_assoc_comp_sta(struct net_device  *dev, union iwreq_data  *wreq,
     a_uint32_t          payload_len = sizeof(*assoc);
     struct sk_buff     *skb = NULL;
 	struct ev_msg *msg;
-    
+
     atd_trace(ATD_DEBUG_FUNCTRACE, (".START"));
     if (!atd_tgt_vap_event_alloc(dev, dev_sc, &skb, payload_len))
         goto done;
@@ -6128,14 +6140,14 @@ atd_tgt_iw_assoc_comp_sta(struct net_device  *dev, union iwreq_data  *wreq,
 	assoc->frame_send = 1;
 
     atd_trace(ATD_DEBUG_FUNCTRACE, (".END"));
-	
+
     wmi_send_event(dev_sc->wmi_handle, skb, WMI_EVENT_ASSOC_COMP_STA);
 done:
     return;
 }
 
-static void 
-atd_tgt_iw_deauth_comp_sta(struct net_device  *dev, union iwreq_data  *wreq, 
+static void
+atd_tgt_iw_deauth_comp_sta(struct net_device  *dev, union iwreq_data  *wreq,
                   const int8_t   *buf)
 {
     atd_tgt_dev_t      *dev_sc = g_atd_dev;
@@ -6143,7 +6155,7 @@ atd_tgt_iw_deauth_comp_sta(struct net_device  *dev, union iwreq_data  *wreq,
     a_uint32_t          payload_len = sizeof(*deauth);
     struct sk_buff     *skb = NULL;
 	struct ev_msg *msg;
-    
+
     atd_trace(ATD_DEBUG_FUNCTRACE, (".START"));
     if (!atd_tgt_vap_event_alloc(dev, dev_sc, &skb, payload_len))
         goto done;
@@ -6154,14 +6166,14 @@ atd_tgt_iw_deauth_comp_sta(struct net_device  *dev, union iwreq_data  *wreq,
 	deauth->frame_send = 1;
 
     atd_trace(ATD_DEBUG_FUNCTRACE, (".END"));
-	
+
     wmi_send_event(dev_sc->wmi_handle, skb, WMI_EVENT_DEAUTH_COMP_STA);
 done:
     return;
 }
 
-static void 
-atd_tgt_iw_disassoc_comp_sta(struct net_device  *dev, union iwreq_data  *wreq, 
+static void
+atd_tgt_iw_disassoc_comp_sta(struct net_device  *dev, union iwreq_data  *wreq,
                   const int8_t   *buf)
 {
     atd_tgt_dev_t      *dev_sc = g_atd_dev;
@@ -6169,7 +6181,7 @@ atd_tgt_iw_disassoc_comp_sta(struct net_device  *dev, union iwreq_data  *wreq,
     a_uint32_t          payload_len = sizeof(*disassoc);
     struct sk_buff     *skb = NULL;
 	struct ev_msg *msg;
-    
+
     atd_trace(ATD_DEBUG_FUNCTRACE, (".START"));
     if (!atd_tgt_vap_event_alloc(dev, dev_sc, &skb, payload_len))
         goto done;
@@ -6181,14 +6193,14 @@ atd_tgt_iw_disassoc_comp_sta(struct net_device  *dev, union iwreq_data  *wreq,
 	disassoc->frame_send = 1;
 
     atd_trace(ATD_DEBUG_FUNCTRACE, (".END"));
-	
+
     wmi_send_event(dev_sc->wmi_handle, skb, WMI_EVENT_DISASSOC_COMP_STA);
 done:
     return;
 }
 
-static void 
-atd_tgt_iw_auth_ind_sta(struct net_device  *dev, union iwreq_data  *wreq, 
+static void
+atd_tgt_iw_auth_ind_sta(struct net_device  *dev, union iwreq_data  *wreq,
                   const int8_t   *buf)
 {
     atd_tgt_dev_t      *dev_sc = g_atd_dev;
@@ -6196,7 +6208,7 @@ atd_tgt_iw_auth_ind_sta(struct net_device  *dev, union iwreq_data  *wreq,
     a_uint32_t          payload_len = sizeof(*auth);
     struct sk_buff     *skb = NULL;
 	struct ev_msg *msg;
-    
+
     atd_trace(ATD_DEBUG_FUNCTRACE, (".START"));
     if (!atd_tgt_vap_event_alloc(dev, dev_sc, &skb, payload_len))
         goto done;
@@ -6207,15 +6219,15 @@ atd_tgt_iw_auth_ind_sta(struct net_device  *dev, union iwreq_data  *wreq,
 	auth->frame_send = 1;
 
     atd_trace(ATD_DEBUG_FUNCTRACE, (".END"));
-	
+
     wmi_send_event(dev_sc->wmi_handle, skb, WMI_EVENT_AUTH_IND_STA);
 done:
     return;
 }
 
 
-static void 
-atd_tgt_iw_deauth_ind_sta(struct net_device  *dev, union iwreq_data  *wreq, 
+static void
+atd_tgt_iw_deauth_ind_sta(struct net_device  *dev, union iwreq_data  *wreq,
                   const int8_t   *buf)
 {
     atd_tgt_dev_t      *dev_sc = g_atd_dev;
@@ -6223,7 +6235,7 @@ atd_tgt_iw_deauth_ind_sta(struct net_device  *dev, union iwreq_data  *wreq,
     a_uint32_t          payload_len = sizeof(*deauth);
     struct sk_buff     *skb = NULL;
 	struct ev_msg *msg;
-    
+
     atd_trace(ATD_DEBUG_FUNCTRACE, (".START"));
     if (!atd_tgt_vap_event_alloc(dev, dev_sc, &skb, payload_len))
         goto done;
@@ -6234,14 +6246,14 @@ atd_tgt_iw_deauth_ind_sta(struct net_device  *dev, union iwreq_data  *wreq,
 	deauth->frame_send = 1;
 
     atd_trace(ATD_DEBUG_FUNCTRACE, (".END"));
-	
+
     wmi_send_event(dev_sc->wmi_handle, skb, WMI_EVENT_DEAUTH_IND_STA);
 done:
     return;
 }
 
-static void 
-atd_tgt_iw_assoc_ind_sta(struct net_device  *dev, union iwreq_data  *wreq, 
+static void
+atd_tgt_iw_assoc_ind_sta(struct net_device  *dev, union iwreq_data  *wreq,
                   const int8_t   *buf)
 {
     atd_tgt_dev_t      *dev_sc = g_atd_dev;
@@ -6249,7 +6261,7 @@ atd_tgt_iw_assoc_ind_sta(struct net_device  *dev, union iwreq_data  *wreq,
     a_uint32_t          payload_len = sizeof(*assoc);
     struct sk_buff     *skb = NULL;
 	struct ev_msg *msg;
-    
+
     atd_trace(ATD_DEBUG_FUNCTRACE, (".START"));
     if (!atd_tgt_vap_event_alloc(dev, dev_sc, &skb, payload_len))
         goto done;
@@ -6260,14 +6272,14 @@ atd_tgt_iw_assoc_ind_sta(struct net_device  *dev, union iwreq_data  *wreq,
 	assoc->frame_send = 1;
 
     atd_trace(ATD_DEBUG_FUNCTRACE, (".END"));
-	
+
     wmi_send_event(dev_sc->wmi_handle, skb, WMI_EVENT_ASSOC_IND_STA);
 done:
     return;
 }
 
-static void 
-atd_tgt_iw_disassoc_ind_sta(struct net_device  *dev, union iwreq_data  *wreq, 
+static void
+atd_tgt_iw_disassoc_ind_sta(struct net_device  *dev, union iwreq_data  *wreq,
                   const int8_t   *buf)
 {
     atd_tgt_dev_t      *dev_sc = g_atd_dev;
@@ -6275,7 +6287,7 @@ atd_tgt_iw_disassoc_ind_sta(struct net_device  *dev, union iwreq_data  *wreq,
     a_uint32_t          payload_len = sizeof(*disassoc);
     struct sk_buff     *skb = NULL;
 	struct ev_msg *msg;
-    
+
     atd_trace(ATD_DEBUG_FUNCTRACE, (".START"));
     if (!atd_tgt_vap_event_alloc(dev, dev_sc, &skb, payload_len))
         goto done;
@@ -6286,14 +6298,14 @@ atd_tgt_iw_disassoc_ind_sta(struct net_device  *dev, union iwreq_data  *wreq,
 	disassoc->frame_send = 1;
 
     atd_trace(ATD_DEBUG_FUNCTRACE, (".END"));
-	
+
     wmi_send_event(dev_sc->wmi_handle, skb, WMI_EVENT_DISASSOC_IND_STA);
 done:
     return;
 }
 
-static void 
-atd_tgt_iw_deauth_ind_ap(struct net_device  *dev, union iwreq_data  *wreq, 
+static void
+atd_tgt_iw_deauth_ind_ap(struct net_device  *dev, union iwreq_data  *wreq,
                   const int8_t   *buf)
 {
     atd_tgt_dev_t      *dev_sc = g_atd_dev;
@@ -6301,7 +6313,7 @@ atd_tgt_iw_deauth_ind_ap(struct net_device  *dev, union iwreq_data  *wreq,
     a_uint32_t          payload_len = sizeof(*deauth);
     struct sk_buff     *skb = NULL;
 	struct ev_msg *msg;
-    
+
     atd_trace(ATD_DEBUG_FUNCTRACE, (".START"));
     if (!atd_tgt_vap_event_alloc(dev, dev_sc, &skb, payload_len))
         goto done;
@@ -6312,14 +6324,14 @@ atd_tgt_iw_deauth_ind_ap(struct net_device  *dev, union iwreq_data  *wreq,
 	deauth->frame_send = 0;
 
     atd_trace(ATD_DEBUG_FUNCTRACE, (".END"));
-	
+
     wmi_send_event(dev_sc->wmi_handle, skb, WMI_EVENT_DEAUTH_IND_AP);
 done:
     return;
 }
 
-static void 
-atd_tgt_iw_disassoc_ind_ap(struct net_device  *dev, union iwreq_data  *wreq, 
+static void
+atd_tgt_iw_disassoc_ind_ap(struct net_device  *dev, union iwreq_data  *wreq,
                   const int8_t   *buf)
 {
     atd_tgt_dev_t      *dev_sc = g_atd_dev;
@@ -6327,7 +6339,7 @@ atd_tgt_iw_disassoc_ind_ap(struct net_device  *dev, union iwreq_data  *wreq,
     a_uint32_t          payload_len = sizeof(*disassoc);
     struct sk_buff     *skb = NULL;
 	struct ev_msg *msg;
-    
+
     atd_trace(ATD_DEBUG_FUNCTRACE, (".START"));
     if (!atd_tgt_vap_event_alloc(dev, dev_sc, &skb, payload_len))
         goto done;
@@ -6338,29 +6350,29 @@ atd_tgt_iw_disassoc_ind_ap(struct net_device  *dev, union iwreq_data  *wreq,
 	disassoc->frame_send = 0;
 
     atd_trace(ATD_DEBUG_FUNCTRACE, (".END"));
-	
+
     wmi_send_event(dev_sc->wmi_handle, skb, WMI_EVENT_DISASSOC_IND_AP);
 done:
     return;
 }
 
 
-/** 
- * @brief 
- * 
+/**
+ * @brief
+ *
  * @param dev
  * @param wreq
  * @param buf
  */
-static void 
-atd_tgt_iw_wapi(struct net_device  *dev, union iwreq_data  *wreq, 
+static void
+atd_tgt_iw_wapi(struct net_device  *dev, union iwreq_data  *wreq,
                   const int8_t   *buf)
 {
     atd_tgt_dev_t      *dev_sc = g_atd_dev;
     acfg_wsupp_custom_message_t *payload;
     a_uint32_t          payload_len = sizeof(*payload);
     struct sk_buff     *skb = NULL;
-    
+
     atd_trace(ATD_DEBUG_FUNCTRACE, (".START"));
 
     payload_len =  wreq->data.length;
@@ -6372,32 +6384,32 @@ atd_tgt_iw_wapi(struct net_device  *dev, union iwreq_data  *wreq,
 
     payload = (void *)skb_put(skb, payload_len);
 
-    memcpy(payload->raw_message, buf, payload_len); 
+    memcpy(payload->raw_message, buf, payload_len);
     atd_trace(ATD_DEBUG_FUNCTRACE, (".END"));
 
     wmi_send_event(dev_sc->wmi_handle, skb, WMI_EVENT_WAPI);
 done:
     return;
 
-} 
+}
 
 
-/** 
- * @brief 
- * 
+/**
+ * @brief
+ *
  * @param dev
  * @param wreq
  * @param buf
  */
-static void 
-atd_tgt_if_running_sta(struct net_device  *dev, union iwreq_data  *wreq, 
+static void
+atd_tgt_if_running_sta(struct net_device  *dev, union iwreq_data  *wreq,
                   const int8_t   *buf)
 {
     atd_tgt_dev_t      *dev_sc = g_atd_dev;
     atd_assoc_sta_t    *payload;
     a_uint32_t          payload_len = sizeof(*payload);
     struct sk_buff     *skb = NULL;
-    
+
     atd_trace(ATD_DEBUG_FUNCTRACE, (".START"));
 
     if (!atd_tgt_vap_event_alloc(dev, dev_sc, &skb, payload_len))
@@ -6408,31 +6420,31 @@ atd_tgt_if_running_sta(struct net_device  *dev, union iwreq_data  *wreq,
     payload->status = htonl(ACFG_ASSOC_SUCCESS);
     memcpy(payload->bssid, wreq->addr.sa_data, ACFG_MACADDR_LEN);
     memset(&payload->ssid, 0, sizeof(atd_ssid_t));
-    
+
     atd_trace(ATD_DEBUG_FUNCTRACE, (".END"));
 
     wmi_send_event(dev_sc->wmi_handle, skb, WMI_EVENT_IF_RUNNING_STA);
 done:
     return;
 
-} 
+}
 
-/** 
- * @brief 
- * 
+/**
+ * @brief
+ *
  * @param dev
  * @param wreq
  * @param buf
  */
-static void 
-atd_tgt_if_not_running_sta(struct net_device  *dev, union iwreq_data  *wreq, 
+static void
+atd_tgt_if_not_running_sta(struct net_device  *dev, union iwreq_data  *wreq,
                   const int8_t   *buf)
 {
     atd_tgt_dev_t      *dev_sc = g_atd_dev;
     atd_assoc_sta_t    *payload;
     a_uint32_t          payload_len = sizeof(*payload);
     struct sk_buff     *skb = NULL;
-    
+
     atd_trace(ATD_DEBUG_FUNCTRACE, (".START"));
 
     if (!atd_tgt_vap_event_alloc(dev, dev_sc, &skb, payload_len))
@@ -6443,7 +6455,7 @@ atd_tgt_if_not_running_sta(struct net_device  *dev, union iwreq_data  *wreq,
     payload->status = htonl(ACFG_ASSOC_SUCCESS);
     memcpy(payload->bssid, wreq->addr.sa_data, ACFG_MACADDR_LEN);
     memset(&payload->ssid, 0, sizeof(atd_ssid_t));
-    
+
     atd_trace(ATD_DEBUG_FUNCTRACE, (".END"));
 
     wmi_send_event(dev_sc->wmi_handle, skb, WMI_EVENT_IF_NOT_RUNNING_STA);
@@ -6452,15 +6464,15 @@ done:
 
 }
 
-/** 
- * @brief 
- * 
+/**
+ * @brief
+ *
  * @param dev
  * @param wreq
  * @param buf
  */
-static void 
-atd_tgt_scan_done(struct net_device  *dev, union iwreq_data  *wreq, 
+static void
+atd_tgt_scan_done(struct net_device  *dev, union iwreq_data  *wreq,
                         const int8_t   *buf)
 {
     atd_tgt_dev_t       *dev_sc = g_atd_dev;
@@ -6472,7 +6484,7 @@ atd_tgt_scan_done(struct net_device  *dev, union iwreq_data  *wreq,
     struct sk_buff     *skb   = NULL;
     atd_tgt_vap_t      *vap   = NULL;
     a_uint8_t          *param = NULL;
-    
+
     atd_trace(ATD_DEBUG_FUNCTRACE,(">> SCAN DONE RECVD\n"));
     atd_trace(ATD_DEBUG_FUNCTRACE,(" Start"));
 
@@ -6507,11 +6519,11 @@ atd_tgt_scan_done(struct net_device  *dev, union iwreq_data  *wreq,
 done:
     return;
 
-} 
+}
 
 
-void 
-atd_tgt_get_freq(void *ctx, a_uint16_t cmdid,  
+void
+atd_tgt_get_freq(void *ctx, a_uint16_t cmdid,
                   a_uint8_t *buffer, a_int32_t len)
 {
     a_status_t status = A_STATUS_OK;
@@ -6553,20 +6565,19 @@ atd_tgt_get_freq(void *ctx, a_uint16_t cmdid,
     atd_trace(ATD_DEBUG_CFG, ("iwreq->freq.m %d iwreq->freq.e %d", \
                                iwreqdata.freq.m, iwreqdata.freq.e));
 
-    freq.m = htonl(iwreqdata.freq.m);
-    freq.e = htons(iwreqdata.freq.e);
-	
+    freq = htonl(iwreqdata.freq.m);
+
 fail:
-	
-    wmi_cmd_rsp(atsc->wmi_handle, cmdid, status, (a_uint8_t *)&freq, 
+
+    wmi_cmd_rsp(atsc->wmi_handle, cmdid, status, (a_uint8_t *)&freq,
                 sizeof (acfg_freq_t));
 }
 
 
 
-/** 
+/**
  * @brief Set RTS threshold
- * 
+ *
  * @param ctx
  * @param cmdid
  * @param buffer
@@ -6605,29 +6616,28 @@ atd_tgt_set_rts(void *ctx, a_uint16_t cmdid,
         goto fail;
     }
 
-    rts->val = ntohl(rts->val);
-    rts->flags = ntohl(rts->flags);
+    rts = ntohl(rts);
 
     info.cmd = SIOCSIWRTS ;
     info.flags = 0 ;
-    iwreq.rts.value = rts->val;
+    iwreq.rts.value = rts;
     iwreq.rts.disabled = 0;
     iwreq.rts.fixed = 0;
     iwreq.rts.flags = 0;
 
-    if(rts->flags & ACFG_RTS_DISABLED)
+    if(rts == 0)
         iwreq.rts.disabled = 1;
 
-    if(rts->flags & ACFG_RTS_FIXED)
+    if(rts > 0)
         iwreq.rts.fixed = 1;
-    
+
     atd_trace(ATD_DEBUG_CFG, ("%s(): cmdid=%d; rts= %d; disabled= %d; fixed= %d \n",
-                __FUNCTION__,cmdid,iwreq.rts.value, 
+                __FUNCTION__,cmdid,iwreq.rts.value,
 		iwreq.rts.disabled, iwreq.rts.fixed));
 
     status = netdev_wext_handler(vap->vap_netdev, SIOCSIWRTS, &info,
                                               (void *)&iwreq, NULL);
-    
+
 fail:
     if(status != A_STATUS_OK){
         resp = 1;
@@ -6641,8 +6651,8 @@ fail:
 
 
 
-void 
-atd_tgt_get_rts(void *ctx, a_uint16_t cmdid,  
+void
+atd_tgt_get_rts(void *ctx, a_uint16_t cmdid,
                   a_uint8_t *buffer, a_int32_t len)
 {
     a_status_t status = A_STATUS_OK;
@@ -6685,17 +6695,11 @@ atd_tgt_get_rts(void *ctx, a_uint16_t cmdid,
     atd_trace(ATD_DEBUG_CFG, ("value %d disabled %d fixed %d", \
                                param->value, param->disabled, param->fixed));
 
-    rts.val = htonl(param->value);
-    rts.flags = 0;
-    if (param->disabled)
-        rts.flags |= ACFG_RTS_DISABLED;
-    if (param->fixed)
-        rts.flags |= ACFG_RTS_FIXED;
-    rts.flags = htonl(rts.flags);
+    rts = htonl(param->value);
 
 fail:
-	
-    wmi_cmd_rsp(atsc->wmi_handle, cmdid, status, (a_uint8_t *)&rts, 
+
+    wmi_cmd_rsp(atsc->wmi_handle, cmdid, status, (a_uint8_t *)&rts,
                 sizeof (atd_rts_t));
 }
 
@@ -6703,9 +6707,9 @@ fail:
 
 
 
-/** 
+/**
  * @brief Set fragmentation threshold
- * 
+ *
  * @param ctx
  * @param cmdid
  * @param buffer
@@ -6744,29 +6748,28 @@ atd_tgt_set_frag(void *ctx, a_uint16_t cmdid,
         goto fail;
     }
 
-    frag->val = ntohl(frag->val);
-    frag->flags = ntohl(frag->flags);
+    frag = ntohl(frag);
 
     info.cmd = SIOCSIWFRAG ;
     info.flags = 0 ;
-    iwreq.frag.value = frag->val;
+    iwreq.frag.value = frag;
     iwreq.frag.disabled = 0;
     iwreq.frag.fixed = 0;
     iwreq.frag.flags = 0;
 
-    if(frag->flags & ACFG_FRAG_DISABLED)
+    if(frag == 0)
         iwreq.frag.disabled = 1;
 
-    if(frag->flags & ACFG_FRAG_FIXED)
+    if(frag > 0)
         iwreq.frag.fixed = 1;
-    
+
     atd_trace(ATD_DEBUG_CFG, ("%s(): cmdid=%d; frag= %d; disabled= %d; fixed= %d \n",
-                __FUNCTION__,cmdid,iwreq.frag.value, 
+                __FUNCTION__,cmdid,iwreq.frag.value,
 		iwreq.frag.disabled, iwreq.frag.fixed));
 
     status = netdev_wext_handler(vap->vap_netdev, SIOCSIWFRAG, &info,
                                               (void *)&iwreq, NULL);
-    
+
 fail:
     if(status != A_STATUS_OK){
         resp = 1;
@@ -6780,8 +6783,8 @@ fail:
 
 
 
-void 
-atd_tgt_get_frag(void *ctx, a_uint16_t cmdid,  
+void
+atd_tgt_get_frag(void *ctx, a_uint16_t cmdid,
                   a_uint8_t *buffer, a_int32_t len)
 {
     a_status_t status = A_STATUS_OK;
@@ -6801,7 +6804,7 @@ atd_tgt_get_frag(void *ctx, a_uint16_t cmdid,
     atd_assert(len >= (sizeof(atd_hdr_t)));
 
     atdhdr = (atd_hdr_t *) buffer;
-	
+
     wifisc = atsc->wifi_list[atdhdr->wifi_index];
     if(wifisc == NULL){
         status = A_STATUS_ENXIO;
@@ -6823,26 +6826,19 @@ atd_tgt_get_frag(void *ctx, a_uint16_t cmdid,
 
     atd_trace(ATD_DEBUG_CFG, ("value %d disabled %d fixed %d", \
                                param->value, param->disabled, param->fixed));
-	
-    frag.val = htonl(param->value);
-    frag.flags = 0;
-    if (param->disabled)
-        frag.flags |= ACFG_FRAG_DISABLED;
-    if (param->fixed)
-        frag.flags |= ACFG_FRAG_FIXED;
-    frag.flags = htonl(frag.flags);
-	
+
+    frag = htonl(param->value);
 fail:
-	
-	wmi_cmd_rsp(atsc->wmi_handle, cmdid, status, (a_uint8_t *)&frag, 
+
+	wmi_cmd_rsp(atsc->wmi_handle, cmdid, status, (a_uint8_t *)&frag,
 		        sizeof (atd_frag_t));
 }
 
 
 
-/** 
+/**
  * @brief Set default TxPower
- * 
+ *
  * @param ctx
  * @param cmdid
  * @param buffer
@@ -6881,31 +6877,30 @@ atd_tgt_set_txpow(void *ctx, a_uint16_t cmdid,
         goto fail;
     }
 
-    txpow->val = ntohl(txpow->val);
-    txpow->flags = ntohl(txpow->flags);
+    txpow = ntohl(txpow);
 
     info.cmd = SIOCSIWTXPOW ;
     info.flags = 0 ;
-    iwreq.txpower.value = txpow->val;
+    iwreq.txpower.value = txpow;
     iwreq.txpower.disabled = 0;
     iwreq.txpower.fixed = 0;
 
     /* Assume Tx power is in dBm */
     iwreq.txpower.flags = 0;
 
-    if(txpow->flags & ACFG_TXPOW_DISABLED)
+    if(txpow == 0)
         iwreq.txpower.disabled = 1;
 
-    if(txpow->flags & ACFG_TXPOW_FIXED)
+    if(txpow > 0)
         iwreq.txpower.fixed = 1;
-    
+
     atd_trace(ATD_DEBUG_CFG, ("%s(): cmdid=%d; txpow= %ddBm; disabled= %d; fixed= %d \n",
-                __FUNCTION__,cmdid,iwreq.txpower.value, 
+                __FUNCTION__,cmdid,iwreq.txpower.value,
 		iwreq.frag.disabled, iwreq.frag.fixed));
 
     status = netdev_wext_handler(vap->vap_netdev, SIOCSIWTXPOW, &info,
                                               (void *)&iwreq, NULL);
-    
+
 fail:
     if(status != A_STATUS_OK){
         resp = 1;
@@ -6920,8 +6915,8 @@ fail:
 
 
 
-void 
-atd_tgt_get_txpow(void *ctx, a_uint16_t cmdid,  
+void
+atd_tgt_get_txpow(void *ctx, a_uint16_t cmdid,
                   a_uint8_t *buffer, a_int32_t len)
 {
     a_status_t status = A_STATUS_OK;
@@ -6941,7 +6936,7 @@ atd_tgt_get_txpow(void *ctx, a_uint16_t cmdid,
     atd_assert(len >= (sizeof(atd_hdr_t)));
 
     atdhdr = (atd_hdr_t *) buffer;
-	
+
     wifisc = atsc->wifi_list[atdhdr->wifi_index];
     if(wifisc == NULL){
         status = A_STATUS_ENXIO;
@@ -6964,22 +6959,15 @@ atd_tgt_get_txpow(void *ctx, a_uint16_t cmdid,
     atd_trace(ATD_DEBUG_CFG, ("value %d disabled %d fixed %d", \
                                param->value, param->disabled, param->fixed));
 
-    txpow.val = htonl(param->value);
-    txpow.flags = 0;
-    if (param->disabled)
-        txpow.flags |= ACFG_TXPOW_DISABLED;
-    if (param->fixed)
-        txpow.flags |= ACFG_TXPOW_FIXED;
-    txpow.flags = htonl(txpow.flags);
-	
+    txpow = htonl(param->value);
 fail:
-	
-    wmi_cmd_rsp(atsc->wmi_handle, cmdid, status, (a_uint8_t *)&txpow, 
+
+    wmi_cmd_rsp(atsc->wmi_handle, cmdid, status, (a_uint8_t *)&txpow,
                 sizeof (atd_txpow_t));
 }
 
-void 
-atd_tgt_set_powmgmt(void *ctx, a_uint16_t cmdid, 
+void
+atd_tgt_set_powmgmt(void *ctx, a_uint16_t cmdid,
                       a_uint8_t *buffer, a_int32_t len)
 {
     a_status_t status = A_STATUS_OK;
@@ -7019,22 +7007,22 @@ atd_tgt_set_powmgmt(void *ctx, a_uint16_t cmdid,
 
     atd_trace(ATD_DEBUG_CFG, ("value %d disabled %d flags 0x%04x", \
                                iwreq.power.value, iwreq.power.disabled, iwreq.power.flags));
-	
+
     status = netdev_wext_handler(vap->vap_netdev, SIOCSIWPOWER, &info, &iwreq, NULL);
 
     if (status != A_STATUS_OK) {
         atd_trace(ATD_DEBUG_CFG, ("set power mgmt error, status = %d\n", status));
         rsp = 0xFFFFFFFF;
     }
-	
+
 fail:
 
-    wmi_cmd_rsp(atsc->wmi_handle, cmdid, status, (a_uint8_t *)&rsp, 
+    wmi_cmd_rsp(atsc->wmi_handle, cmdid, status, (a_uint8_t *)&rsp,
                 sizeof (a_int32_t));
 }
 
-void 
-atd_tgt_get_powmgmt(void *ctx, a_uint16_t cmdid,  
+void
+atd_tgt_get_powmgmt(void *ctx, a_uint16_t cmdid,
                   a_uint8_t *buffer, a_int32_t len)
 {
     a_status_t status = A_STATUS_OK;
@@ -7054,7 +7042,7 @@ atd_tgt_get_powmgmt(void *ctx, a_uint16_t cmdid,
     atd_assert(len >= (sizeof(atd_hdr_t)));
 
     atdhdr = (atd_hdr_t *) buffer;
-	
+
     wifisc = atsc->wifi_list[atdhdr->wifi_index];
     if(wifisc == NULL){
         status = A_STATUS_ENXIO;
@@ -7081,15 +7069,15 @@ atd_tgt_get_powmgmt(void *ctx, a_uint16_t cmdid,
     powmgmt.val = htonl(param->value);
     powmgmt.flags = htons(param->flags);
     powmgmt.disabled = param->disabled;
-		
+
 fail:
-	
-    wmi_cmd_rsp(atsc->wmi_handle, cmdid, status, (a_uint8_t *)&powmgmt, 
+
+    wmi_cmd_rsp(atsc->wmi_handle, cmdid, status, (a_uint8_t *)&powmgmt,
                 sizeof (atd_powmgmt_t));
 }
 
-void 
-atd_tgt_set_encode(void *ctx, a_uint16_t cmdid, 
+void
+atd_tgt_set_encode(void *ctx, a_uint16_t cmdid,
                       a_uint8_t *buffer, a_int32_t len)
 {
     a_status_t status = A_STATUS_OK;
@@ -7128,22 +7116,22 @@ atd_tgt_set_encode(void *ctx, a_uint16_t cmdid,
 
     atd_trace(ATD_DEBUG_CFG, ("len %d flags 0x%04x", \
                                iwreq.data.length, iwreq.data.flags));
-    status = netdev_wext_handler(vap->vap_netdev, SIOCSIWENCODE, &info, &iwreq, 
+    status = netdev_wext_handler(vap->vap_netdev, SIOCSIWENCODE, &info, &iwreq,
                                 (char *)pencode->key);
 
     if (status != A_STATUS_OK) {
         atd_trace(ATD_DEBUG_CFG, ("set encode error, status = %d\n", status));
         rsp = 0xFFFFFFFF;
     }
-	
+
 fail:
 
-    wmi_cmd_rsp(atsc->wmi_handle, cmdid, status, (a_uint8_t *)&rsp, 
+    wmi_cmd_rsp(atsc->wmi_handle, cmdid, status, (a_uint8_t *)&rsp,
                 sizeof (a_int32_t));
 }
 
-void 
-atd_tgt_get_encode(void *ctx, a_uint16_t cmdid, 
+void
+atd_tgt_get_encode(void *ctx, a_uint16_t cmdid,
                   a_uint8_t *buffer, a_int32_t len)
 {
     a_status_t status = A_STATUS_OK;
@@ -7163,7 +7151,7 @@ atd_tgt_get_encode(void *ctx, a_uint16_t cmdid,
     atd_assert(len >= (sizeof(atd_hdr_t)));
 
     atdhdr = (atd_hdr_t *) buffer;
-	
+
     wifisc = atsc->wifi_list[atdhdr->wifi_index];
     if(wifisc == NULL){
         status = A_STATUS_ENXIO;
@@ -7178,7 +7166,7 @@ atd_tgt_get_encode(void *ctx, a_uint16_t cmdid,
 
     iwreqdata.data.length = IW_ENCODING_TOKEN_MAX;
     iwreqdata.data.flags = 0;
-    status = netdev_wext_handler(vap->vap_netdev, SIOCGIWENCODE, &info, &iwreqdata, 
+    status = netdev_wext_handler(vap->vap_netdev, SIOCGIWENCODE, &info, &iwreqdata,
                                 (char *)&encode.key[0]);
 
     if (status != A_STATUS_OK) {
@@ -7193,13 +7181,13 @@ atd_tgt_get_encode(void *ctx, a_uint16_t cmdid,
     encode.len = htons(pencode->length);
 
 fail:
-	
-    wmi_cmd_rsp(atsc->wmi_handle, cmdid, status, (a_uint8_t *)&encode, 
+
+    wmi_cmd_rsp(atsc->wmi_handle, cmdid, status, (a_uint8_t *)&encode,
                 sizeof (atd_encode_rsp_t));
 }
 
-void 
-atd_tgt_set_rate(void *ctx, a_uint16_t cmdid, 
+void
+atd_tgt_set_rate(void *ctx, a_uint16_t cmdid,
                       a_uint8_t *buffer, a_int32_t len)
 {
     a_status_t status = A_STATUS_OK;
@@ -7245,15 +7233,15 @@ atd_tgt_set_rate(void *ctx, a_uint16_t cmdid,
         atd_trace(ATD_DEBUG_CFG, ("set rate error, status = %d\n", status));
         rsp = 0xFFFFFFFF;
     }
-	
+
 fail:
 
-    wmi_cmd_rsp(atsc->wmi_handle, cmdid, status, (a_uint8_t *)&rsp, 
+    wmi_cmd_rsp(atsc->wmi_handle, cmdid, status, (a_uint8_t *)&rsp,
                 sizeof (a_int32_t));
 }
 
-void 
-atd_tgt_get_stats(void *ctx, a_uint16_t cmdid, 
+void
+atd_tgt_get_stats(void *ctx, a_uint16_t cmdid,
                   a_uint8_t *buffer, a_int32_t len)
 {
     a_status_t status = A_STATUS_OK;
@@ -7272,7 +7260,7 @@ atd_tgt_get_stats(void *ctx, a_uint16_t cmdid,
     atd_assert(len >= (sizeof(atd_hdr_t)));
 
     atdhdr = (atd_hdr_t *) buffer;
-	
+
     wifisc = atsc->wifi_list[atdhdr->wifi_index];
     if(wifisc == NULL){
         status = A_STATUS_ENXIO;
@@ -7297,15 +7285,15 @@ atd_tgt_get_stats(void *ctx, a_uint16_t cmdid,
     resp.discard_nwid = htonl(stats->discard.nwid);
     resp.discard_code = htonl(stats->discard.code);
     resp.missed_beacon = htonl(stats->miss.beacon);
-	
+
 fail:
 
-    wmi_cmd_rsp(atsc->wmi_handle, cmdid, status, (a_uint8_t *)&resp, 
+    wmi_cmd_rsp(atsc->wmi_handle, cmdid, status, (a_uint8_t *)&resp,
                 sizeof (atd_stats_t));
 }
 
-void 
-atd_tgt_tx99tool(void *ctx, a_uint16_t cmdid, 
+void
+atd_tgt_tx99tool(void *ctx, a_uint16_t cmdid,
                       a_uint8_t *buffer, a_int32_t len)
 {
     a_status_t status = A_STATUS_OK;
@@ -7321,7 +7309,7 @@ atd_tgt_tx99tool(void *ctx, a_uint16_t cmdid,
     atd_trace(ATD_DEBUG_FUNCTRACE, ("cmd %d    ", \
                 cmdid));
 
-    atd_assert(len >= (sizeof(atd_hdr_t) + sizeof(atd_tx99_t)));  
+    atd_assert(len >= (sizeof(atd_hdr_t) + sizeof(atd_tx99_t)));
     atdhdr = (atd_hdr_t *) buffer;
     tx99_param = (atd_tx99_t *)(buffer + sizeof(atd_hdr_t)) ;
 
@@ -7353,12 +7341,12 @@ atd_tgt_tx99tool(void *ctx, a_uint16_t cmdid,
 
 fail:
 
-    wmi_cmd_rsp(atsc->wmi_handle, cmdid, status, (a_uint8_t *)&rsp , 
+    wmi_cmd_rsp(atsc->wmi_handle, cmdid, status, (a_uint8_t *)&rsp ,
                 sizeof (a_int32_t));
 }
 
-void 
-atd_tgt_nawds_config(void *ctx, a_uint16_t cmdid, 
+void
+atd_tgt_nawds_config(void *ctx, a_uint16_t cmdid,
                       a_uint8_t *buffer, a_int32_t len)
 {
     a_status_t status = A_STATUS_OK;
@@ -7381,12 +7369,12 @@ atd_tgt_nawds_config(void *ctx, a_uint16_t cmdid,
 
     switch(nawds.cmdtype)
     {
-        case NAWDS_SET_MODE:
-        case NAWDS_SET_DEFCAPS:
-        case NAWDS_SET_OVERRIDE:
-        case NAWDS_SET_ADDR:
-        case NAWDS_CLR_ADDR:
-        case NAWDS_GET:
+        case IEEE80211_WLANCONFIG_NAWDS_SET_MODE:
+        case IEEE80211_WLANCONFIG_NAWDS_SET_DEFCAPS:
+        case IEEE80211_WLANCONFIG_NAWDS_SET_OVERRIDE:
+        case IEEE80211_WLANCONFIG_NAWDS_SET_ADDR:
+        case IEEE80211_WLANCONFIG_NAWDS_CLR_ADDR:
+        case IEEE80211_WLANCONFIG_NAWDS_GET:
             nawds.data.nawds.num = nawds_config->data.nawds.num;
             nawds.data.nawds.mode = nawds_config->data.nawds.mode;
             nawds.data.nawds.defcaps = nawds_config->data.nawds.defcaps;
@@ -7394,14 +7382,6 @@ atd_tgt_nawds_config(void *ctx, a_uint16_t cmdid,
             memcpy(nawds.data.nawds.mac, nawds_config->data.nawds.mac, ACFG_MACADDR_LEN);
             nawds.data.nawds.caps = nawds_config->data.nawds.caps;
             break;
-        case WNM_SET_BSSMAX:
-        case WNM_GET_BSSMAX:
-        case WNM_TFS_ADD:
-        case WNM_TFS_DELETE:
-        case WNM_SET_TIMBCAST:
-        case WNM_GET_TIMBCAST:
-            memcpy(&nawds.data.wnm, &nawds_config->data.wnm, sizeof(struct acfg_wnm_cfg));
-            break;
         default:
             status = A_STATUS_EINVAL;
             goto fail;
@@ -7428,55 +7408,27 @@ atd_tgt_nawds_config(void *ctx, a_uint16_t cmdid,
     }
 
     status  = netdev_ioctl(vap->vap_netdev,(struct ifreq *)&req, SIOCIOCTLNAWDS);
-
 fail:
-    
-    if(nawds.cmdtype == NAWDS_GET 
-        || nawds.cmdtype == WNM_GET_BSSMAX 
-        || nawds.cmdtype == WNM_GET_TIMBCAST)
-    {
-        resp.cmdtype = htonl(nawds.cmdtype);
-        resp.status = htonl(nawds.status);
-        if (nawds.cmdtype == NAWDS_GET) {
-            resp.data.nawds.num = nawds.data.nawds.num;
-            resp.data.nawds.mode = nawds.data.nawds.mode;
-            resp.data.nawds.defcaps = nawds.data.nawds.defcaps;
-            resp.data.nawds.override = nawds.data.nawds.override;
-            memcpy(resp.data.nawds.mac, nawds.data.nawds.mac, ACFG_MACADDR_LEN);
-            resp.data.nawds.caps = nawds.data.nawds.caps;
-        } else {
-            memcpy(&resp.data.wnm, &nawds.data.wnm, sizeof(struct acfg_wnm_cfg));
-        }
-        wmi_cmd_rsp(atsc->wmi_handle, cmdid, status, (a_uint8_t *)&resp, 
-                sizeof(atd_nawds_cfg_t));
-    }
-    else
-        wmi_cmd_rsp(atsc->wmi_handle, cmdid, status, 
-                NULL , 0);
+    return;
 }
 
 
 /* security APIs */
 static void
-atd_tgt_wsupp_response_wmi(atd_tgt_dev_t *atsc, 
+atd_tgt_wsupp_response_wmi(atd_tgt_dev_t *atsc,
         wsupp_msg_t *wmsg, int len)
 {
     wsupp_wmi_reply_t *wmi_reply;
     a_int32_t rsplen;;
-    
+
     wmi_reply = (wsupp_wmi_reply_t *) wmsg->wm_data;
     rsplen = len - sizeof(wsupp_msg_t) - sizeof(wmi_reply->status);
-    wmi_cmd_rsp(atsc->wmi_handle, wmsg->wm_wmi, wmi_reply->status, 
+    wmi_cmd_rsp(atsc->wmi_handle, wmsg->wm_wmi, wmi_reply->status,
         (a_uint8_t *) wmi_reply->data, rsplen);
-#if 0
-    wmi_reply->data[rsplen] = '\0';
-    atd_trace(ATD_DEBUG_CFG,("%s: status: %d len: %d: %s\n", __func__, 
-        wmi_reply->status, rsplen, wmi_reply->data));
-#endif
 }
 
 static void
-atd_tgt_wsupp_response_wmi_event(atd_tgt_dev_t *atsc, 
+atd_tgt_wsupp_response_wmi_event(atd_tgt_dev_t *atsc,
         wsupp_msg_t *wmsg, int len)
 {
     char *data;
@@ -7485,7 +7437,7 @@ atd_tgt_wsupp_response_wmi_event(atd_tgt_dev_t *atsc,
 
     dev = dev_get_by_name(&init_net, wmsg->wm_ifname);
     if (dev == NULL) {
-        atd_trace(ATD_DEBUG_CFG, ("failed to deliver wmi event: %d if: %s\n", 
+        atd_trace(ATD_DEBUG_CFG, ("failed to deliver wmi event: %d if: %s\n",
                     wmsg->wm_wmi, wmsg->wm_ifname));
         return;
     }
@@ -7520,151 +7472,8 @@ atd_tgt_wsupp_response(void *ctx, char *buf, int len)
     return 0;
 }
 
-void 
-atd_tgt_wsupp_request(void *ctx, a_uint16_t cmdid, 
-                      a_uint8_t *buffer, a_int32_t len)
-{
-    a_status_t status = A_STATUS_FAILED;
-    atd_tgt_dev_t *atsc = (atd_tgt_dev_t *)ctx;
-    atd_hdr_t *atdhdr;
-    a_uint32_t rsp = 0;
-    acfg_wsupp_info_t *winfo;
-    wsupp_msg_t *wmsg = NULL;
-
-    atd_trace((ATD_DEBUG_FUNCTRACE | ATD_DEBUG_CFG), ("cmd: %d", cmdid));
-
-    atd_assert(len >= (sizeof(atd_hdr_t) + sizeof(acfg_wsupp_info_t)));
-
-    atdhdr = (atd_hdr_t *) buffer;
-    winfo = (acfg_wsupp_info_t *) (buffer + sizeof(atd_hdr_t)) ;
-
-    wmsg = kmalloc(sizeof(wsupp_msg_t) + sizeof(winfo->u), GFP_ATOMIC);
-    if (wmsg == NULL) {
-        atd_trace(ATD_DEBUG_CFG, ("%s: failed to alloc: %d\n", __func__, cmdid));
-        goto error;
-    }
-
-    wmsg->wm_type = ntohl(WSUPP_MSG_TYPE_WMI);
-    wmsg->wm_wmi = ntohl(cmdid);
-    memcpy(wmsg->wm_unique, winfo->unique, WSUPP_MSG_UNIQUE_BIN_LEN);
-    strncpy(wmsg->wm_ifname, winfo->ifname, WSUPP_MSG_IFNAME_LEN);
-    wmsg->wm_len = ntohl(sizeof(winfo->u));
-    memcpy(wmsg->wm_data, &winfo->u, sizeof(winfo->u));
-
-#if 1
-    /* send request to wsupp helper */
-    if (atd_tgt_wsupp_helper_wmi_send(atsc->wsupp_handle, cmdid, 
-        (char *) wmsg, sizeof(wsupp_msg_t) + sizeof(winfo->u))) {
-        atd_trace(ATD_DEBUG_CFG, ("%s: failed to send wmi: %d\n", __func__, cmdid));
-        goto error;
-    }
-#else
-    /* reply directly for WMI debugging */
-    status = A_STATUS_OK;
-    wmi_cmd_rsp(atsc->wmi_handle, cmdid, status, (a_uint8_t *)&rsp, 
-        sizeof (a_int32_t));
-#endif
-
-    kfree(wmsg);
-
-    return;
-error:
-    wmi_cmd_rsp(atsc->wmi_handle, cmdid, status, (a_uint8_t *)&rsp, 
-        sizeof (a_int32_t));
-    if (wmsg)
-        kfree(wmsg);
-}
-
-void 
-atd_tgt_set_reg(void *ctx, a_uint16_t cmdid, 
-                      a_uint8_t *buffer, a_int32_t len)
-{
-    a_status_t status = A_STATUS_OK;
-    atd_tgt_dev_t *atsc = (atd_tgt_dev_t *)ctx;
-    atd_tgt_wifi_t *wifisc =NULL;
-    atd_hdr_t   *atdhdr;
-
-    atd_param_t  *wifi_param;
-    a_uint32_t rsp = 0 ;
-
-    atd_trace(ATD_DEBUG_FUNCTRACE, ("cmd %d    ", \
-                cmdid));
-
-    atd_assert(len >= (sizeof(atd_hdr_t) + sizeof(atd_param_t)));
-
-    atdhdr = (atd_hdr_t *) buffer;
-    wifi_param = (atd_param_t  *)(buffer + sizeof(atd_hdr_t));
-
-    wifi_param->param = ntohl(wifi_param->param);
-    wifi_param->val   = ntohl(wifi_param->val);
-
-    atd_trace(ATD_DEBUG_FUNCTRACE, (" radio %d vap %d offset %x  val %x", \
-                                 atdhdr->wifi_index, atdhdr->vap_index,\
-                                 wifi_param->param, wifi_param->val));
-
-    wifisc = atsc->wifi_list[atdhdr->wifi_index];
-    if(wifisc == NULL){
-        status = A_STATUS_ENXIO;
-        goto fail;
-    }
-
-#ifndef BUILD_PARTNER_PLATFORM
-    ar7240_reg_wr(wifi_param->param, wifi_param->val);
-#endif
-
-fail:
-
-    wmi_cmd_rsp(atsc->wmi_handle, cmdid, status, (a_uint8_t *)&rsp, 
-                sizeof (a_int32_t));
-}
-
-void 
-atd_tgt_get_reg(void *ctx, a_uint16_t cmdid, 
-                      a_uint8_t *buffer, a_int32_t len)
-{
-    a_status_t status = A_STATUS_OK;
-    atd_tgt_dev_t *atsc = (atd_tgt_dev_t *)ctx;
-    atd_tgt_wifi_t *wifisc =NULL;
-    atd_hdr_t   *atdhdr;
-
-    atd_param_t  *wifi_param;
-    atd_param_t   paramresult;
-
-    atd_trace(ATD_DEBUG_FUNCTRACE, ("cmd %d    ", cmdid));
-
-    atd_assert(len >= (sizeof(atd_hdr_t)));
-
-    atdhdr = (atd_hdr_t *) buffer;
-    wifi_param = (atd_param_t *)(buffer + sizeof(atd_hdr_t));
-
-    wifi_param->param = ntohl(wifi_param->param);
-
-    atd_trace(ATD_DEBUG_FUNCTRACE, (" radio %d vap %d param %x val %x", \
-                                 atdhdr->wifi_index, atdhdr->vap_index,\
-                                 wifi_param->param, wifi_param->val));
-
-    wifisc = atsc->wifi_list[atdhdr->wifi_index];
-
-    if(wifisc == NULL){
-        status = A_STATUS_ENXIO;
-        goto fail;
-    }
-
-#ifndef BUILD_PARTNER_PLATFORM
-    wifi_param->val = ar7240_reg_rd(wifi_param->param);
-    paramresult.val = htonl(wifi_param->val);
-#endif
-
-    atd_trace(ATD_DEBUG_FUNCTRACE ,("Result val %x \n",wifi_param->val));
-
-fail:
-
-    wmi_cmd_rsp(atsc->wmi_handle, cmdid, status, (a_uint8_t *)&paramresult, 
-                sizeof (atd_param_t));
-}
-
-void 
-atd_tgt_set_hwaddr(void *ctx, a_uint16_t cmdid, 
+void
+atd_tgt_set_hwaddr(void *ctx, a_uint16_t cmdid,
                       a_uint8_t *buffer, a_int32_t len)
 {
     a_status_t status = A_STATUS_OK;
@@ -7705,12 +7514,12 @@ atd_tgt_set_hwaddr(void *ctx, a_uint16_t cmdid,
 
 fail:
 
-    wmi_cmd_rsp(atsc->wmi_handle, cmdid, status, (a_uint8_t *)&resp, 
+    wmi_cmd_rsp(atsc->wmi_handle, cmdid, status, (a_uint8_t *)&resp,
                 sizeof (a_uint32_t));
 }
 
-void 
-atd_tgt_set_wmmparams(void *ctx, a_uint16_t cmdid, 
+void
+atd_tgt_set_wmmparams(void *ctx, a_uint16_t cmdid,
                       a_uint8_t *buffer, a_int32_t len)
 {
 
@@ -7726,13 +7535,13 @@ atd_tgt_set_wmmparams(void *ctx, a_uint16_t cmdid,
     atd_trace(ATD_DEBUG_FUNCTRACE, ("cmd %d    ", cmdid));
 
     atd_assert(len >= (sizeof(atd_hdr_t) + sizeof(atd_wmmparams_t)));
-  
+
     atdhdr  = (atd_hdr_t *) buffer;
     vap_param    = (atd_wmmparams_t  *) (buffer + sizeof(atd_hdr_t)) ;
 
-    vap_param->param[0] = atd_tgt_acfg2ieee(ntohl ( vap_param->param[0] ));
+    vap_param->param[0] = ntohl ( vap_param->param[0] );
 	vap_param->param[1] = ntohl ( vap_param->param[1] );
-	vap_param->param[2] = ntohl ( vap_param->param[2] );	
+	vap_param->param[2] = ntohl ( vap_param->param[2] );
     vap_param->val   = ntohl ( vap_param->val );
 
 
@@ -7760,8 +7569,8 @@ fail:
     wmi_cmd_rsp(atsc->wmi_handle, cmdid, status, NULL, 0);
 }
 
-void 
-atd_tgt_get_wmmparams(void *ctx, a_uint16_t cmdid, 
+void
+atd_tgt_get_wmmparams(void *ctx, a_uint16_t cmdid,
                   a_uint8_t *buffer, a_int32_t len)
 {
     a_status_t status = A_STATUS_OK;
@@ -7780,11 +7589,11 @@ atd_tgt_get_wmmparams(void *ctx, a_uint16_t cmdid,
                 cmdid));
 
     atd_assert(len >= (sizeof(atd_hdr_t) + sizeof(atd_wmmparams_t)));
-  
+
     atdhdr  = (atd_hdr_t *) buffer;
     vap_param    = (atd_wmmparams_t  *) (buffer + sizeof(atd_hdr_t)) ;
 
-    vap_param->param[0] = atd_tgt_acfg2ieee(ntohl ( vap_param->param[0] ));
+    vap_param->param[0] = ntohl ( vap_param->param[0] );
 	vap_param->param[1] = ntohl ( vap_param->param[1] );
 	vap_param->param[2] = ntohl ( vap_param->param[2] );
     vap_param->val   = 0;
@@ -7814,14 +7623,14 @@ atd_tgt_get_wmmparams(void *ctx, a_uint16_t cmdid,
     atd_trace(ATD_DEBUG_FUNCTRACE,("Result val %d \n",vap_param->param[0]));
 
 fail:
-    wmi_cmd_rsp(atsc->wmi_handle, cmdid, status, (a_uint8_t *)&paramresult , 
+    wmi_cmd_rsp(atsc->wmi_handle, cmdid, status, (a_uint8_t *)&paramresult ,
                 sizeof (atd_param_t));
 }
 
 
 
-void 
-atd_tgt_doth_chswitch(void *ctx, a_uint16_t cmdid, 
+void
+atd_tgt_doth_chswitch(void *ctx, a_uint16_t cmdid,
                       a_uint8_t *buffer, a_int32_t len)
 {
     a_status_t status = A_STATUS_OK;
@@ -7862,32 +7671,32 @@ atd_tgt_doth_chswitch(void *ctx, a_uint16_t cmdid,
     atd_trace(ATD_DEBUG_CFG, ("channel %d time %d", \
                                i[0],i[1]));
 
-    status = netdev_wext_handler(vap->vap_netdev, 
+    status = netdev_wext_handler(vap->vap_netdev,
             IEEE80211_IOCTL_CHANSWITCH, &info, &iwreq, (a_uint8_t *)i);
 
     if (status != A_STATUS_OK) {
         atd_trace(ATD_DEBUG_CFG, ("error, status = %d\n", status));
         rsp = 0xFFFFFFFF;
     }
-	
+
 fail:
 
-    wmi_cmd_rsp(atsc->wmi_handle, cmdid, status, (a_uint8_t *)&rsp, 
+    wmi_cmd_rsp(atsc->wmi_handle, cmdid, status, (a_uint8_t *)&rsp,
                 sizeof (a_int32_t));
 }
 
 
 
-/** 
+/**
  * @brief Add Mac address to ACL list
- * 
+ *
  * @param ctx
  * @param cmdid
  * @param buffer
  * @param len
  */
-void 
-atd_tgt_addmac(void *ctx, a_uint16_t cmdid, 
+void
+atd_tgt_addmac(void *ctx, a_uint16_t cmdid,
                       a_uint8_t *buffer, a_int32_t len)
 {
     a_status_t status = A_STATUS_OK;
@@ -7924,40 +7733,34 @@ atd_tgt_addmac(void *ctx, a_uint16_t cmdid,
 
     sa.sa_family = AF_INET ;
     memcpy(sa.sa_data, paddr->addr, ACFG_MACADDR_LEN) ;
-#if 0
-    printk("%s(): Got addr - %x:%x:%x:%x:%x:%x \n",__FUNCTION__,(unsigned int)paddr->addr[0],
-            (unsigned int)paddr->addr[1],
-                (unsigned int)paddr->addr[2],(unsigned int)paddr->addr[3],
-                (unsigned int)paddr->addr[4],(unsigned int)paddr->addr[5]);
-#endif
 
-    status = netdev_wext_handler(vap->vap_netdev, 
+    status = netdev_wext_handler(vap->vap_netdev,
             IEEE80211_IOCTL_ADDMAC, &info, &iwreq, (a_uint8_t *)&sa);
 
     if (status != A_STATUS_OK) {
         atd_trace(ATD_DEBUG_CFG, ("error, status = %d\n", status));
         rsp = 0xFFFFFFFF;
     }
-	
+
 fail:
 
-    wmi_cmd_rsp(atsc->wmi_handle, cmdid, status, (a_uint8_t *)&rsp, 
+    wmi_cmd_rsp(atsc->wmi_handle, cmdid, status, (a_uint8_t *)&rsp,
                 sizeof (a_int32_t));
 }
 
 
-    
-    
-/** 
+
+
+/**
  * @brief Delete Mac address from ACL list
- * 
+ *
  * @param ctx
  * @param cmdid
  * @param buffer
  * @param len
  */
-void 
-atd_tgt_delmac(void *ctx, a_uint16_t cmdid, 
+void
+atd_tgt_delmac(void *ctx, a_uint16_t cmdid,
                       a_uint8_t *buffer, a_int32_t len)
 {
     a_status_t status = A_STATUS_OK;
@@ -7995,40 +7798,32 @@ atd_tgt_delmac(void *ctx, a_uint16_t cmdid,
     sa.sa_family = AF_INET ;
     memcpy(sa.sa_data, paddr->addr, ACFG_MACADDR_LEN) ;
 
-#if 0
-    printk("%s(): Got addr - %x:%x:%x:%x:%x:%x \n",
-            __FUNCTION__,(unsigned int)paddr->addr[0],
-                (unsigned int)paddr->addr[1],
-                (unsigned int)paddr->addr[2],(unsigned int)paddr->addr[3],
-                (unsigned int)paddr->addr[4],(unsigned int)paddr->addr[5]);
-#endif
-
-    status = netdev_wext_handler(vap->vap_netdev, 
+    status = netdev_wext_handler(vap->vap_netdev,
             IEEE80211_IOCTL_DELMAC, &info, &iwreq, (a_uint8_t *)&sa);
 
     if (status != A_STATUS_OK) {
         atd_trace(ATD_DEBUG_CFG, ("error, status = %d\n", status));
         rsp = 0xFFFFFFFF;
     }
-	
+
 fail:
 
-    wmi_cmd_rsp(atsc->wmi_handle, cmdid, status, (a_uint8_t *)&rsp, 
+    wmi_cmd_rsp(atsc->wmi_handle, cmdid, status, (a_uint8_t *)&rsp,
                 sizeof (a_int32_t));
 }
 
 
 
-/** 
+/**
  * @brief Disassociate station
- * 
+ *
  * @param ctx
  * @param cmdid
  * @param buffer
  * @param len
  */
-void 
-atd_tgt_kickmac(void *ctx, a_uint16_t cmdid, 
+void
+atd_tgt_kickmac(void *ctx, a_uint16_t cmdid,
                       a_uint8_t *buffer, a_int32_t len)
 {
     a_status_t status = A_STATUS_OK;
@@ -8068,31 +7863,31 @@ atd_tgt_kickmac(void *ctx, a_uint16_t cmdid,
 
     atd_print_mac_addr(paddr->addr, "Got kickmac address- ");
 
-    status = netdev_wext_handler(vap->vap_netdev, 
+    status = netdev_wext_handler(vap->vap_netdev,
             IEEE80211_IOCTL_KICKMAC, &info, &iwreq, (a_uint8_t *)&sa);
 
     if (status != A_STATUS_OK) {
         atd_trace(ATD_DEBUG_CFG, ("error, status = %d\n", status));
         rsp = 0xFFFFFFFF;
     }
-	
+
 fail:
     rsp = htonl(rsp);
-    wmi_cmd_rsp(atsc->wmi_handle, cmdid, status, (a_uint8_t *)&rsp, 
+    wmi_cmd_rsp(atsc->wmi_handle, cmdid, status, (a_uint8_t *)&rsp,
                 sizeof (a_int32_t));
 }
 
-void 
-atd_tgt_pwrdown(void *ctx, a_uint16_t cmdid, 
+void
+atd_tgt_pwrdown(void *ctx, a_uint16_t cmdid,
                       a_uint8_t *buffer, a_int32_t len)
 {
 
     a_status_t status = 0;
     a_uint32_t tmp = 0 ;
     atd_tgt_dev_t *atsc = (atd_tgt_dev_t *)ctx;
-    
+
     wmi_cmd_rsp(atsc->wmi_handle, cmdid, status, NULL, 0);
-               
+
     printk("Received WMI Power down request \n");
 
 #ifndef BUILD_PARTNER_PLATFORM
@@ -8128,16 +7923,16 @@ atd_tgt_pwrdown(void *ctx, a_uint16_t cmdid,
 }
 
 
-/** 
+/**
  * @brief Get Chan List
- * 
+ *
  * @param ctx
  * @param cmdid
  * @param buffer
  * @param len
  */
-void 
-atd_tgt_get_chan_list(void *ctx, a_uint16_t cmdid, 
+void
+atd_tgt_get_chan_list(void *ctx, a_uint16_t cmdid,
                   a_uint8_t *buffer, a_int32_t len)
 {
     a_status_t status = A_STATUS_OK;
@@ -8149,11 +7944,11 @@ atd_tgt_get_chan_list(void *ctx, a_uint16_t cmdid,
     uint32_t length = 0;
     struct iw_request_info info;
     union  iwreq_data iwreq = {{0}};
-    
+
     atd_trace(ATD_DEBUG_FUNCTRACE, ("cmd %d    ", cmdid));
 
     atd_assert(len >= (sizeof(atd_hdr_t) + sizeof(uint32_t)));
-  
+
     atdhdr     = (atd_hdr_t *)buffer;
     length     = ntohl(*(uint32_t *)(buffer + sizeof(atd_hdr_t)));
 
@@ -8181,7 +7976,7 @@ atd_tgt_get_chan_list(void *ctx, a_uint16_t cmdid,
     iwreq.data.flags = 0;
     iwreq.data.pointer = chan_list;
 
-    status = netdev_wext_handler(vap->vap_netdev, IEEE80211_IOCTL_GETCHANLIST, 
+    status = netdev_wext_handler(vap->vap_netdev, IEEE80211_IOCTL_GETCHANLIST,
                                     &info, (void *)&iwreq, iwreq.data.pointer);
 
     atd_trace(ATD_DEBUG_FUNCTRACE,("chan list %d\n", iwreq.data.length));
@@ -8194,16 +7989,16 @@ fail:
 }
 
 
-/** 
+/**
  * @brief Get Chan Info
- * 
+ *
  * @param ctx
  * @param cmdid
  * @param buffer
  * @param len
  */
-void 
-atd_tgt_get_chan_info(void *ctx, a_uint16_t cmdid, 
+void
+atd_tgt_get_chan_info(void *ctx, a_uint16_t cmdid,
                   a_uint8_t *buffer, a_int32_t len)
 {
     a_status_t status = A_STATUS_OK;
@@ -8216,11 +8011,11 @@ atd_tgt_get_chan_info(void *ctx, a_uint16_t cmdid,
     atd_chan_info_t *chan = NULL;
     struct ieee80211req_chaninfo *chan_info = NULL;
     a_uint32_t i = 0;
-    
+
     atd_trace(ATD_DEBUG_FUNCTRACE, ("cmd %d    ", cmdid));
 
     atd_assert(len >= (sizeof(atd_hdr_t)));
-  
+
     atdhdr     = (atd_hdr_t *)buffer;
 
     atd_trace(ATD_DEBUG_FUNCTRACE, (" radio %d vap %d ",
@@ -8237,7 +8032,7 @@ atd_tgt_get_chan_info(void *ctx, a_uint16_t cmdid,
     if(chan_info == NULL){
         atd_trace(ATD_DEBUG_CFG, ("\n %s : allocation failed\n", __FUNCTION__));
         status = A_STATUS_ENOMEM;
-        goto fail; 
+        goto fail;
     }
 
     vzalloc(sizeof(atd_chan_info_t), chan);
@@ -8252,7 +8047,7 @@ atd_tgt_get_chan_info(void *ctx, a_uint16_t cmdid,
     iwreq.data.flags = 0;
     iwreq.data.pointer = chan_info;
 
-    status = netdev_wext_handler(vap->vap_netdev, IEEE80211_IOCTL_GETCHANINFO, 
+    status = netdev_wext_handler(vap->vap_netdev, IEEE80211_IOCTL_GETCHANINFO,
                                     &info, (void *)&iwreq, iwreq.data.pointer);
 
     if (status == A_STATUS_OK) {
@@ -8277,7 +8072,7 @@ atd_tgt_get_chan_info(void *ctx, a_uint16_t cmdid,
     atd_trace(ATD_DEBUG_FUNCTRACE,("chan info %d\n", iwreq.data.length));
 
 fail:
-    wmi_cmd_rsp(atsc->wmi_handle, cmdid, status, 
+    wmi_cmd_rsp(atsc->wmi_handle, cmdid, status,
                 (uint8_t *)chan, iwreq.data.length);
 
     if (chan)
@@ -8287,16 +8082,16 @@ fail:
 }
 
 
-/** 
+/**
  * @brief Get ACL MAC Address List
- * 
+ *
  * @param ctx
  * @param cmdid
  * @param buffer
  * @param len
  */
-void 
-atd_tgt_get_mac_address(void *ctx, a_uint16_t cmdid, 
+void
+atd_tgt_get_mac_address(void *ctx, a_uint16_t cmdid,
                   a_uint8_t *buffer, a_int32_t len)
 {
     a_status_t status = A_STATUS_OK;
@@ -8309,9 +8104,9 @@ atd_tgt_get_mac_address(void *ctx, a_uint16_t cmdid,
     union  iwreq_data iwreq = {{0}};
     struct sockaddr *sa;
 	a_uint8_t i = 0;
-    
+
     atd_trace(ATD_DEBUG_FUNCTRACE, ("cmd %d    ", cmdid));
-  
+
     atdhdr     = (atd_hdr_t *)buffer;
 
     atd_trace(ATD_DEBUG_FUNCTRACE, (" radio %d vap %d ",
@@ -8337,11 +8132,11 @@ atd_tgt_get_mac_address(void *ctx, a_uint16_t cmdid,
     iwreq.data.flags = 0;
     iwreq.data.pointer = (uint8_t *)sa;
 
-    status = netdev_wext_handler(vap->vap_netdev, IEEE80211_IOCTL_GET_MACADDR, 
+    status = netdev_wext_handler(vap->vap_netdev, IEEE80211_IOCTL_GET_MACADDR,
                                     &info, (void *)&iwreq, iwreq.data.pointer);
 	for (i = 0; i < iwreq.data.length; i++) {
 		memcpy(mac_list.macaddr[i], sa[0].sa_data, ACFG_MACADDR_LEN);
-	}	
+	}
 
     mac_list.num = htonl(iwreq.data.length);
 
@@ -8351,22 +8146,21 @@ atd_tgt_get_mac_address(void *ctx, a_uint16_t cmdid,
     atd_trace(ATD_DEBUG_FUNCTRACE,("acl mac list %d\n", iwreq.data.length));
 
 fail:
-    wmi_cmd_rsp(atsc->wmi_handle, cmdid, status, (uint8_t *)&mac_list, 
+    wmi_cmd_rsp(atsc->wmi_handle, cmdid, status, (uint8_t *)&mac_list,
 							sizeof(atd_macacl_t));
 
 }
 
-
-/** 
+/**
  * @brief Get P2P param
- * 
+ *
  * @param ctx
  * @param cmdid
  * @param buffer
  * @param len
  */
-void 
-atd_tgt_get_p2p_param(void *ctx, a_uint16_t cmdid, 
+void
+atd_tgt_get_p2p_param(void *ctx, a_uint16_t cmdid,
                   a_uint8_t *buffer, a_int32_t len)
 {
     a_status_t status = A_STATUS_OK;
@@ -8377,11 +8171,11 @@ atd_tgt_get_p2p_param(void *ctx, a_uint16_t cmdid,
     uint32_t length = 0, param = 0;
     struct iwreq iwr = {{{0}}};
     void *resp_buf = NULL;
-    
+
     atd_trace(ATD_DEBUG_FUNCTRACE, ("cmd %d    ", cmdid));
 
     atd_assert(len >= (sizeof(atd_hdr_t) + 2 * sizeof(a_uint32_t)));
-  
+
     atdhdr     = (atd_hdr_t *)buffer;
     length     = ntohl(*(uint32_t *)(buffer + sizeof(atd_hdr_t)));
     param      = ntohl(*(uint32_t *)(buffer + sizeof(atd_hdr_t) + sizeof(uint32_t)));
@@ -8408,7 +8202,7 @@ atd_tgt_get_p2p_param(void *ctx, a_uint16_t cmdid,
     iwr.u.data.flags = param;
     iwr.u.data.pointer = (uint8_t *)resp_buf + sizeof(uint32_t);
 
-    status = netdev_ioctl(vap->vap_netdev, (struct ifreq *)&iwr, 
+    status = netdev_ioctl(vap->vap_netdev, (struct ifreq *)&iwr,
                                         IEEE80211_IOCTL_P2P_BIG_PARAM);
 
     ((uint32_t *)resp_buf)[0] = htonl(iwr.u.data.length);
@@ -8416,36 +8210,6 @@ atd_tgt_get_p2p_param(void *ctx, a_uint16_t cmdid,
     length += sizeof(uint32_t);
 
     switch (param) {
-        case IEEE80211_IOC_P2P_FIND_BEST_CHANNEL:
-        {
-            int i;
-            acfg_best_freq_t *f = (acfg_best_freq_t *)iwr.u.data.pointer;
-            for (i = 0; i < ACFG_MAX_BEST_CHANS; i++)
-                f->freq[i] = htonl(f->freq[i]);
-        }
-        break;
-
-        case IEEE80211_IOC_P2P_FETCH_FRAME:
-        {
-            acfg_rx_frame_t *fr = (acfg_rx_frame_t *)iwr.u.data.pointer;
-            fr->freq = htonl(fr->freq);
-            fr->type = htonl(fr->type);
-        }
-        break;
-
-        case IEEE80211_IOC_P2P_NOA_INFO:
-        {
-             int i;
-             acfg_noa_info_t *noa = (acfg_noa_info_t *)iwr.u.data.pointer;
-             noa->tsf = htonl(noa->tsf);
-             for (i = 0; i < ACFG_MAX_NOA_DESCS; i++) {
-                 noa->desc[i].type_count = htonl(noa->desc[i].type_count);
-                 noa->desc[i].duration = htonl(noa->desc[i].duration);
-                 noa->desc[i].interval = htonl(noa->desc[i].interval);
-                 noa->desc[i].start_time = htonl(noa->desc[i].start_time);
-             }
-        }
-        break;
     }
 
     atd_trace(ATD_DEBUG_FUNCTRACE,("p2p get generic %d\n", iwr.u.data.length));
@@ -8458,16 +8222,16 @@ fail:
 }
 
 
-/** 
+/**
  * @brief Set P2P param
- * 
+ *
  * @param ctx
  * @param cmdid
  * @param buffer
  * @param len
  */
-void 
-atd_tgt_set_p2p_param(void *ctx, a_uint16_t cmdid, 
+void
+atd_tgt_set_p2p_param(void *ctx, a_uint16_t cmdid,
                   a_uint8_t *buffer, a_int32_t len)
 {
     a_status_t status = A_STATUS_OK;
@@ -8477,11 +8241,11 @@ atd_tgt_set_p2p_param(void *ctx, a_uint16_t cmdid,
     atd_hdr_t *atdhdr;
     uint32_t length = 0, param = 0;
     struct iwreq iwr = {{{0}}};
-    
+
     atd_trace(ATD_DEBUG_FUNCTRACE, ("cmd %d    ", cmdid));
 
     atd_assert(len >= (sizeof(atd_hdr_t) + sizeof(uint32_t) * 2));
-  
+
     atdhdr     = (atd_hdr_t *)buffer;
     length     = ntohl(*(uint32_t *)(buffer + sizeof(atd_hdr_t)));
     param      = ntohl(*(uint32_t *)(buffer + sizeof(atd_hdr_t) + sizeof(uint32_t)));
@@ -8501,22 +8265,6 @@ atd_tgt_set_p2p_param(void *ctx, a_uint16_t cmdid,
     iwr.u.data.pointer = buffer + sizeof(atd_hdr_t) + (2 * sizeof(uint32_t));
 
     switch (param) {
-        case IEEE80211_IOC_P2P_SET_CHANNEL:
-        {
-            acfg_set_chan_t *set_chan = (acfg_set_chan_t *)iwr.u.data.pointer;
-            set_chan->freq = ntohl(set_chan->freq);
-            set_chan->req_id = ntohl(set_chan->req_id);
-            set_chan->time = ntohl(set_chan->time);
-        }
-        break;
-
-        case IEEE80211_IOC_P2P_SEND_ACTION:
-        {
-            acfg_send_act_t *act = (acfg_send_act_t *)iwr.u.data.pointer;
-            act->freq = ntohl(act->freq);
-        }
-        break;
-
         case IEEE80211_IOC_SCAN_REQ:
         {
             int i;
@@ -8526,37 +8274,20 @@ atd_tgt_set_p2p_param(void *ctx, a_uint16_t cmdid,
             scan->len = ntohs(scan->len);
         }
         break;
-
-        case IEEE80211_IOC_P2P_GO_NOA:
-        {
-            int i, num;
-            uint16_t tmp;
-            acfg_noa_req_t *noa = (acfg_noa_req_t *)iwr.u.data.pointer;
-            num = length / sizeof(*noa);
-            for (i = 0; i < num && i < ACFG_MAX_NOA_REQ; i++) {
-                memcpy(&tmp, noa[i].offset_next_tbtt, sizeof(tmp));
-                tmp = ntohs(tmp);
-                memcpy(noa[i].offset_next_tbtt, &tmp, sizeof(tmp));
-                memcpy(&tmp, noa[i].duration, sizeof(tmp));
-                tmp = ntohs(tmp);
-                memcpy(noa[i].duration, &tmp, sizeof(tmp));
-            }
-        }
-        break;
     }
 
-    status = netdev_ioctl(vap->vap_netdev, (struct ifreq *)&iwr, 
+    status = netdev_ioctl(vap->vap_netdev, (struct ifreq *)&iwr,
                                         IEEE80211_IOCTL_P2P_BIG_PARAM);
 
     atd_trace(ATD_DEBUG_FUNCTRACE,("p2p set param %d\n", iwr.u.data.length));
 
 fail:
-    wmi_cmd_rsp(atsc->wmi_handle, cmdid, status, NULL, 0); 
+    wmi_cmd_rsp(atsc->wmi_handle, cmdid, status, NULL, 0);
 }
 
 
-void 
-atd_tgt_acl_addmac(void *ctx, a_uint16_t cmdid, 
+void
+atd_tgt_acl_addmac(void *ctx, a_uint16_t cmdid,
                   a_uint8_t *buffer, a_int32_t len)
 {
 	a_status_t status = A_STATUS_OK;
@@ -8608,8 +8339,8 @@ fail:
 }
 
 
-void 
-atd_tgt_acl_delmac(void *ctx, a_uint16_t cmdid, 
+void
+atd_tgt_acl_delmac(void *ctx, a_uint16_t cmdid,
                   a_uint8_t *buffer, a_int32_t len)
 {
 	a_status_t status = A_STATUS_OK;
@@ -8765,7 +8496,7 @@ fail:
     wmi_cmd_rsp(atsc->wmi_handle, cmdid, status, NULL, 0);
 }
 
-void 
+void
 atd_tgt_convert_profile(struct ieee80211_profile *profile,
 						atd_radio_vap_info_t *atd_profile)
 {
@@ -8780,7 +8511,7 @@ atd_tgt_convert_profile(struct ieee80211_profile *profile,
 		strncpy(atd_profile->vap_info[i].vap_name,
                                     profile->vap_profile[i].name,
                                     IFNAMSIZ);
-		atd_profile->vap_info[i].phymode = 
+		atd_profile->vap_info[i].phymode =
 									htonl(profile->vap_profile[i].phymode);
 		memcpy(atd_profile->vap_info[i].vap_mac,
                 profile->vap_profile[i].vap_mac,
@@ -8849,7 +8580,7 @@ atd_tgt_convert_profile(struct ieee80211_profile *profile,
 			}
 		}
 	}
-	atd_profile->num_vaps = profile->num_vaps;		
+	atd_profile->num_vaps = profile->num_vaps;
 }
 
 void atd_convert_ad_hton(void *out, void *in, int ad_id)
@@ -9003,8 +8734,8 @@ atd_tgt_phyerr(void *ctx, a_uint16_t cmdid,
         atd_convert_ad_hton(atd_outdata, ath_diag.ad_out_data, ath_diag.ad_id);
 
 fail:
-    wmi_cmd_rsp(atsc->wmi_handle, cmdid, status, 
-            atd_outdata, 
+    wmi_cmd_rsp(atsc->wmi_handle, cmdid, status,
+            atd_outdata,
             ath_diag.ad_out_size);
 
     if (indata)
@@ -9018,7 +8749,7 @@ fail:
 }
 
 void
-atd_tgt_get_profile(void *ctx, a_uint16_t cmdid, 
+atd_tgt_get_profile(void *ctx, a_uint16_t cmdid,
                   a_uint8_t *buffer, a_int32_t len)
 {
 	a_status_t status = A_STATUS_OK;
@@ -9033,7 +8764,7 @@ atd_tgt_get_profile(void *ctx, a_uint16_t cmdid,
 
     atdhdr  = (atd_hdr_t *) buffer;
 	wifisc = atsc->wifi_list[atdhdr->wifi_index];
-	memset(&result, 0, sizeof (atd_radio_vap_info_t));	
+	memset(&result, 0, sizeof (atd_radio_vap_info_t));
 	profile = (struct ieee80211_profile *)kmalloc (
                         sizeof (struct ieee80211_profile), GFP_KERNEL);
     if (profile == NULL) {
@@ -9050,12 +8781,12 @@ atd_tgt_get_profile(void *ctx, a_uint16_t cmdid,
     }
 
 	atd_tgt_convert_profile(profile, &result);
-	
+
 fail:
 	if (profile != NULL) {
         kfree(profile);
     }
-    wmi_cmd_rsp(atsc->wmi_handle, cmdid, status, (a_uint8_t *)&result , 
+    wmi_cmd_rsp(atsc->wmi_handle, cmdid, status, (a_uint8_t *)&result ,
                 sizeof (atd_radio_vap_info_t));
 }
 
@@ -9100,7 +8831,7 @@ static void atd_tgt_set_chnwidthswitch (void *ctx, a_uint16_t cmdid,
     iwreq.data.flags = 0 ;
     iwreq.data.pointer = (a_uint32_t *)chwidthswitch->setchnwidth;
 
-    status = netdev_wext_handler(vap->vap_netdev, IEEE80211_IOCTL_CHN_WIDTHSWITCH, 
+    status = netdev_wext_handler(vap->vap_netdev, IEEE80211_IOCTL_CHN_WIDTHSWITCH,
                     &info,(void *)&iwreq, (char *)chwidthswitch->setchnwidth);
 
    if(status != A_STATUS_OK){
@@ -9264,7 +8995,7 @@ static void atd_tgt_set_country (void *ctx, a_uint16_t cmdid,
 fail:
     wmi_cmd_rsp(atsc->wmi_handle, cmdid, status, NULL, 0);
 
-}                                                                     
+}
 
 
 
diff --git a/target/linux/thin_driver/atd/atd_dev.c b/target/linux/thin_driver/atd/atd_dev.c
index 822954f..595edcd 100644
--- a/target/linux/thin_driver/atd/atd_dev.c
+++ b/target/linux/thin_driver/atd/atd_dev.c
@@ -27,6 +27,10 @@
 #include <hif_api.h>
 #include <htc_api.h>
 #include <wmi_api.h>
+
+#include <ieee80211_external_config.h>
+#define EXTERNAL_USE_ONLY
+
 #include <atd_wsupp.h>
 #include <atd_hdr.h>
 #include <atd_cmd.h>
@@ -78,7 +82,14 @@ static void      atd_tgt_htc_recv_message(void *ServiceCtx,
 static a_int32_t atd_tgt_device_detect( hif_handle_t hif_handle);
 static a_int32_t atd_tgt_device_disconnect( void * context);
 
-
+void atd_event_handler(struct net_device     *dev, unsigned int  cmd,
+                       union iwreq_data      *wreq, char *extra);
+void atd_proxy_arp_send(struct sk_buff *wbuf);
+void atd_spectral_msg_send(struct net_device *dev,
+                       void *msg, a_uint16_t msg_len);
+void atd_bsteer_event_send(struct net_device *dev,
+        struct ath_netlink_bsteering_event *event,
+                           a_uint16_t msg_len);
 
 static a_int32_t 
 atd_tgt_module_init( void )
@@ -135,14 +146,6 @@ atd_tgt_device_detect( hif_handle_t hif_handle)
 
     atd_tgt_wmi_init(atsc);
 
-    /* register wsupp message helper */
-    atsc->wsupp_handle = atd_tgt_wsupp_helper_init(atsc, atsc->htc_handle);
-    if (atsc->wsupp_handle == NULL) {
-        printk("wsupp helper init failed\n");
-        status  =   A_STATUS_FAILED;
-        goto fail;
-    }
-
     register_netdevice_notifier(&atd_netdev_notify);
 
     atsc->appbr_handle  =   atd_tgt_appbr_init(atsc, APPBR_NETLINK_NUM);
@@ -426,8 +429,6 @@ atd_tgt_vap_unref(atd_tgt_vap_t     *vap)
 void atd_tgt_module_exit(void )
 {
     printk("%s \n",__func__);
-    if (g_atd_dev->wsupp_handle)
-        atd_tgt_wsupp_helper_cleanup(g_atd_dev->wsupp_handle);
 
     if (g_atd_dev->byp_handle)
         atd_tgt_byp_cleanup(g_atd_dev->byp_handle);
@@ -548,8 +549,9 @@ atd_tgt_find_vap(atd_tgt_dev_t *atsc, struct net_device * dev)
     atd_tgt_wifi_t *wifi;
     uint8_t vap_index=dev->irq & 0x3f;
 
-    if(!atsc->wifi_cnt)
+    if(!atsc->wifi_cnt) {
 	return NULL;
+    }
 
     if(dev->irq & 0x80)
          wifi=atsc->wifi_list[1];	
@@ -558,8 +560,9 @@ atd_tgt_find_vap(atd_tgt_dev_t *atsc, struct net_device * dev)
 	
     vap=wifi->vap_list[vap_index];
 
-    if(vap && (vap->vap_netdev == dev))
-        return vap; 
+    if(vap && (vap->vap_netdev == dev)) {
+        return vap;
+    }
 
     return NULL;
 }
@@ -787,6 +790,10 @@ atd_tgt_htc_set_stopflag(a_uint8_t val)
 
 EXPORT_SYMBOL(atd_rx_from_wlan);
 EXPORT_SYMBOL(atd_tgt_htc_set_stopflag);
+EXPORT_SYMBOL(atd_event_handler);
+EXPORT_SYMBOL(atd_proxy_arp_send);
+EXPORT_SYMBOL(atd_spectral_msg_send);
+EXPORT_SYMBOL(atd_bsteer_event_send);
 
 
 /*----------------------------------------------------------------*/
diff --git a/target/linux/thin_driver/atd/atd_internal.h b/target/linux/thin_driver/atd/atd_internal.h
index 7cac9e2..e24fc20 100644
--- a/target/linux/thin_driver/atd/atd_internal.h
+++ b/target/linux/thin_driver/atd/atd_internal.h
@@ -124,9 +124,9 @@ atd_dump_ether_header(struct sk_buff  *skb)
 
 #else
 
-#define atd_print_mac_addr(x, str)  (0)
+#define atd_print_mac_addr(x, str)  
 
-#define atd_dump_ether_header(buf)  (0)
+#define atd_dump_ether_header(buf) 
 
 #endif
 
diff --git a/target/linux/thin_driver/atd/atd_netlink.c b/target/linux/thin_driver/atd/atd_netlink.c
index 9a18bf9..fd6e380 100644
--- a/target/linux/thin_driver/atd/atd_netlink.c
+++ b/target/linux/thin_driver/atd/atd_netlink.c
@@ -30,6 +30,10 @@
 #include <hif_api.h>
 #include <htc_api.h>
 #include <wmi_api.h>
+
+#include <ieee80211_external_config.h>
+#define EXTERNAL_USE_ONLY
+
 #include <atd_wsupp.h>
 #include <atd_wsupp_msg.h>
 #include <atd_hdr.h>
diff --git a/target/linux/thin_driver/atd/atd_wsupp.c b/target/linux/thin_driver/atd/atd_wsupp.c
index ab10de5..2e52e4a 100644
--- a/target/linux/thin_driver/atd/atd_wsupp.c
+++ b/target/linux/thin_driver/atd/atd_wsupp.c
@@ -29,6 +29,10 @@
 #include <hif_api.h>
 #include <htc_api.h>
 #include <wmi_api.h>
+
+#include <ieee80211_external_config.h>
+#define EXTERNAL_USE_ONLY
+
 #include <atd_wsupp.h>
 #include <atd_wsupp_msg.h>
 #include <atd_hdr.h>
diff --git a/target/linux/thin_driver/htc/htc.c b/target/linux/thin_driver/htc/htc.c
index 0987df3..445caa8 100644
--- a/target/linux/thin_driver/htc/htc.c
+++ b/target/linux/thin_driver/htc/htc.c
@@ -17,6 +17,7 @@
 #include <a_base_types.h>
 #include <linux/skbuff.h>
 #include <linux/netdevice.h>
+#include <linux/module.h>
 #include <htc_api.h>
 #include <htc_internal.h>
 #include <atd_trc.h>
-- 
2.1.4

