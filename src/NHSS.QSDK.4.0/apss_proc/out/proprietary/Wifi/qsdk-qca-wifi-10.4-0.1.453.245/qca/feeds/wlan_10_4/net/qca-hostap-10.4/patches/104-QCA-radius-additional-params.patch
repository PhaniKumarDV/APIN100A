diff --git a/hostapd/config_file.c b/hostapd/config_file.c
index 9800ab2..4db787a 100644
--- a/hostapd/config_file.c
+++ b/hostapd/config_file.c
@@ -2291,6 +2291,20 @@ static int hostapd_config_fill(struct hostapd_config *conf,
 		bss->radius->acct_server->shared_secret_len = len;
 	} else if (os_strcmp(buf, "radius_retry_primary_interval") == 0) {
 		bss->radius->retry_primary_interval = atoi(pos);
+	} else if (os_strcmp(buf, "radius_server_retries") == 0) {
+		bss->radius->radius_server_retries = atoi(pos);
+		if((bss->radius->radius_server_retries < 0 ) || (bss->radius->radius_server_retries > 10 )){
+			wpa_printf(MSG_ERROR, "Line %d: radius->radius_server_retries '%d'",
+				line,bss->radius->radius_server_retries);
+			return 1;
+		}
+	}else if (os_strcmp(buf, "radius_max_retry_wait") == 0) {
+		bss->radius->radius_max_retry_wait = atoi(pos);
+		if((bss->radius->radius_max_retry_wait < 1 ) || (bss->radius->radius_max_retry_wait > 120 )){
+			wpa_printf(MSG_ERROR, "Line %d: radius->radius_max_retry_wait '%d'",
+				line,bss->radius->radius_max_retry_wait);
+			return 1;
+		}
 	} else if (os_strcmp(buf, "radius_acct_interim_interval") == 0) {
 		bss->acct_interim_interval = atoi(pos);
 	} else if (os_strcmp(buf, "radius_request_cui") == 0) {
@@ -2447,6 +2461,13 @@ static int hostapd_config_fill(struct hostapd_config *conf,
 	} else if (os_strcmp(buf, "peerkey") == 0) {
 		bss->peerkey = atoi(pos);
 #endif /* CONFIG_PEERKEY */
+	} else if (os_strcmp(buf, "identity_request_retry_interval") == 0) {
+		bss->identity_request_retry_interval = atoi(pos);
+		if((bss->identity_request_retry_interval < 0 ) || (bss->identity_request_retry_interval > 200 )){
+			wpa_printf(MSG_ERROR, "Line %d: Invalid identity_request_retry_interval '%d'",
+				line,bss->identity_request_retry_interval);
+			return 1;
+		}
 #ifdef CONFIG_IEEE80211R
 	} else if (os_strcmp(buf, "mobility_domain") == 0) {
 		if (os_strlen(pos) != 2 * MOBILITY_DOMAIN_ID_LEN ||
diff --git a/src/ap/ap_config.c b/src/ap/ap_config.c
index 455013a..f107323 100644
--- a/src/ap/ap_config.c
+++ b/src/ap/ap_config.c
@@ -19,6 +19,8 @@
 #include "sta_info.h"
 #include "ap_config.h"
 
+#define RADIUS_CLIENT_MAX_RETRIES 10
+#define RADIUS_CLIENT_MAX_WAIT 120
 
 static void hostapd_config_free_vlan(struct hostapd_bss_config *bss)
 {
@@ -84,6 +86,7 @@ void hostapd_config_defaults_bss(struct hostapd_bss_config *bss)
 
 	/* Set to -1 as defaults depends on HT in setup */
 	bss->wmm_enabled = -1;
+	bss->identity_request_retry_interval = 0;
 
 #ifdef CONFIG_IEEE80211R
 	bss->ft_over_ds = 1;
@@ -92,6 +95,8 @@ void hostapd_config_defaults_bss(struct hostapd_bss_config *bss)
 	bss->radius_das_time_window = 300;
 
 	bss->sae_anti_clogging_threshold = 5;
+	bss->radius->radius_server_retries = RADIUS_CLIENT_MAX_RETRIES;
+	bss->radius->radius_max_retry_wait = RADIUS_CLIENT_MAX_WAIT;
 }
 
 
diff --git a/src/ap/ap_config.h b/src/ap/ap_config.h
index c3573a4..a34df35 100644
--- a/src/ap/ap_config.h
+++ b/src/ap/ap_config.h
@@ -308,6 +308,7 @@ struct hostapd_bss_config {
 	int rsn_preauth;
 	char *rsn_preauth_interfaces;
 	int peerkey;
+	int identity_request_retry_interval;
 
 #ifdef CONFIG_IEEE80211R
 	/* IEEE 802.11r - Fast BSS Transition */
diff --git a/src/ap/ieee802_1x.c b/src/ap/ieee802_1x.c
index ef26834..6c4c76c 100644
--- a/src/ap/ieee802_1x.c
+++ b/src/ap/ieee802_1x.c
@@ -2108,6 +2108,10 @@ int ieee802_1x_init(struct hostapd_data *hapd)
 	conf.fragment_size = hapd->conf->fragment_size;
 	conf.pwd_group = hapd->conf->pwd_group;
 	conf.pbc_in_m1 = hapd->conf->pbc_in_m1;
+	if ( hapd->conf->identity_request_retry_interval ) {
+		conf.identity_request_retry_interval= hapd->conf->identity_request_retry_interval;
+	}
+
 	if (hapd->conf->server_id) {
 		conf.server_id = (const u8 *) hapd->conf->server_id;
 		conf.server_id_len = os_strlen(hapd->conf->server_id);
diff --git a/src/ap/wpa_auth.h b/src/ap/wpa_auth.h
index e747806..d1b9340 100644
--- a/src/ap/wpa_auth.h
+++ b/src/ap/wpa_auth.h
@@ -137,6 +137,7 @@ struct wpa_auth_config {
 	int rsn_preauth;
 	int eapol_version;
 	int peerkey;
+	int identity_request_retry_interval;
 	int wmm_enabled;
 	int wmm_uapsd;
 	int disable_pmksa_caching;
diff --git a/src/ap/wpa_auth_glue.c b/src/ap/wpa_auth_glue.c
index 7cd0b6c..75e6180 100644
--- a/src/ap/wpa_auth_glue.c
+++ b/src/ap/wpa_auth_glue.c
@@ -48,6 +48,7 @@ static void hostapd_wpa_auth_conf(struct hostapd_bss_config *conf,
 	wconf->wmm_uapsd = conf->wmm_uapsd;
 	wconf->disable_pmksa_caching = conf->disable_pmksa_caching;
 	wconf->okc = conf->okc;
+	wconf->identity_request_retry_interval= conf->identity_request_retry_interval;
 #ifdef CONFIG_IEEE80211W
 	wconf->ieee80211w = conf->ieee80211w;
 	wconf->group_mgmt_cipher = conf->group_mgmt_cipher;
diff --git a/src/ap/wpa_auth_i.h b/src/ap/wpa_auth_i.h
index 57b098f..28eb4ec 100644
--- a/src/ap/wpa_auth_i.h
+++ b/src/ap/wpa_auth_i.h
@@ -137,6 +137,7 @@ struct wpa_state_machine {
 #ifdef CONFIG_P2P
 	u8 ip_addr[4];
 #endif /* CONFIG_P2P */
+	int identity_request_retry_interval;
 };
 
 
diff --git a/src/ap/wpa_auth_ie.c b/src/ap/wpa_auth_ie.c
index cf2a712..86bc304 100644
--- a/src/ap/wpa_auth_ie.c
+++ b/src/ap/wpa_auth_ie.c
@@ -711,6 +711,9 @@ int wpa_validate_wpa_ie(struct wpa_authenticator *wpa_auth,
 	}
 	os_memcpy(sm->wpa_ie, wpa_ie, wpa_ie_len);
 	sm->wpa_ie_len = wpa_ie_len;
+	if(wpa_auth->conf.identity_request_retry_interval){
+		sm->identity_request_retry_interval = wpa_auth->conf.identity_request_retry_interval; 
+	}
 
 	return WPA_IE_OK;
 }
diff --git a/src/eap_peer/eap_i.h b/src/eap_peer/eap_i.h
index 5f8b5fa..6ae6770 100644
--- a/src/eap_peer/eap_i.h
+++ b/src/eap_peer/eap_i.h
@@ -368,6 +368,8 @@ struct eap_sm {
 	unsigned int expected_failure:1;
 
 	struct dl_list erp_keys; /* struct eap_erp_key */
+	int identity_request_retry_interval;
+
 };
 
 const u8 * eap_get_config_identity(struct eap_sm *sm, size_t *len);
diff --git a/src/eap_server/eap.h b/src/eap_server/eap.h
index 09be581..4dd421c 100644
--- a/src/eap_server/eap.h
+++ b/src/eap_server/eap.h
@@ -131,6 +131,7 @@ struct eap_config {
 	size_t server_id_len;
 	int erp;
	unsigned int tls_session_lifetime;
+	int identity_request_retry_interval;
 
 #ifdef CONFIG_TESTING_OPTIONS
 	u32 tls_test_flags;
diff --git a/src/eap_server/eap_i.h b/src/eap_server/eap_i.h
index 978c879..ce6a4aa 100644
--- a/src/eap_server/eap_i.h
+++ b/src/eap_server/eap_i.h
@@ -210,6 +210,7 @@ struct eap_sm {
 	Boolean try_initiate_reauth;
 	int erp;
	unsigned int tls_session_lifetime;
+	int identity_request_retry_interval;
 
 #ifdef CONFIG_TESTING_OPTIONS
 	u32 tls_test_flags;
diff --git a/src/eap_server/eap_server.c b/src/eap_server/eap_server.c
index 1f38d78..718a147 100644
--- a/src/eap_server/eap_server.c
+++ b/src/eap_server/eap_server.c
@@ -310,9 +310,14 @@ SM_STATE(EAP, IDLE)
 {
 	SM_ENTRY(EAP, IDLE);
 
-	sm->eap_if.retransWhile = eap_sm_calculateTimeout(
-		sm, sm->retransCount, sm->eap_if.eapSRTT, sm->eap_if.eapRTTVAR,
-		sm->methodTimeout);
+	if(sm->identity_request_retry_interval) {
+		sm->eap_if.retransWhile = sm->identity_request_retry_interval ;
+	} else { 
+		sm->eap_if.retransWhile = eap_sm_calculateTimeout(
+			sm, sm->retransCount, sm->eap_if.eapSRTT, sm->eap_if.eapRTTVAR,
+			sm->methodTimeout);
+	}
+	wpa_printf(MSG_DEBUG, "identity_request_retry_interval (%d) ",sm->eap_if.retransWhile);
 }
 
 
@@ -993,9 +998,14 @@ SM_STATE(EAP, IDLE2)
 {
 	SM_ENTRY(EAP, IDLE2);
 
-	sm->eap_if.retransWhile = eap_sm_calculateTimeout(
-		sm, sm->retransCount, sm->eap_if.eapSRTT, sm->eap_if.eapRTTVAR,
-		sm->methodTimeout);
+	if(sm->identity_request_retry_interval) {
+		sm->eap_if.retransWhile = sm->identity_request_retry_interval ;
+	} else { 
+		sm->eap_if.retransWhile = eap_sm_calculateTimeout(
+			sm, sm->retransCount, sm->eap_if.eapSRTT, sm->eap_if.eapRTTVAR,
+			sm->methodTimeout);
+	}
+	wpa_printf(MSG_DEBUG, "identity_request_retry_interval (%d) ",sm->eap_if.retransWhile);
 }
 
 
@@ -1853,6 +1863,10 @@ struct eap_sm * eap_server_sm_init(void *eapol_ctx,
 	sm->server_id_len = conf->server_id_len;
 	sm->erp = conf->erp;
	sm->tls_session_lifetime = conf->tls_session_lifetime;
+	if ( conf->identity_request_retry_interval ) {
+		sm->identity_request_retry_interval = conf->identity_request_retry_interval ;
+	}
+
 
 #ifdef CONFIG_TESTING_OPTIONS
 	sm->tls_test_flags = conf->tls_test_flags;
diff --git a/src/eapol_auth/eapol_auth_sm.c b/src/eapol_auth/eapol_auth_sm.c
index 3b0c2e4..e1691c3 100644
--- a/src/eapol_auth/eapol_auth_sm.c
+++ b/src/eapol_auth/eapol_auth_sm.c
@@ -835,6 +835,9 @@ eapol_auth_alloc(struct eapol_authenticator *eapol, const u8 *addr,
 	eap_conf.server_id_len = eapol->conf.server_id_len;
 	eap_conf.erp = eapol->conf.erp;
	eap_conf.tls_session_lifetime = eapol->conf.tls_session_lifetime;
+	if(eapol->conf.identity_request_retry_interval) {
+		eap_conf.identity_request_retry_interval = eapol->conf.identity_request_retry_interval;
+	}
 	sm->eap = eap_server_sm_init(sm, &eapol_cb, &eap_conf);
 	if (sm->eap == NULL) {
 		eapol_auth_free(sm);
@@ -1137,6 +1140,7 @@ static int eapol_auth_conf_clone(struct eapol_auth_config *dst,
 	dst->tnc = src->tnc;
 	dst->wps = src->wps;
 	dst->fragment_size = src->fragment_size;
+        dst->identity_request_retry_interval= src->identity_request_retry_interval;
 
 	os_free(dst->erp_domain);
 	if (src->erp_domain) {
diff --git a/src/eapol_auth/eapol_auth_sm.h b/src/eapol_auth/eapol_auth_sm.h
index ebed19a..36d3d9f 100644
--- a/src/eapol_auth/eapol_auth_sm.h
+++ b/src/eapol_auth/eapol_auth_sm.h
@@ -42,6 +42,7 @@ struct eapol_auth_config {
 	int pbc_in_m1;
 	const u8 *server_id;
 	size_t server_id_len;
+        int identity_request_retry_interval;
 
 	/* Opaque context pointer to owner data for callback functions */
 	void *ctx;
diff --git a/src/radius/radius_client.c b/src/radius/radius_client.c
index 693f61e..e7e8039 100644
--- a/src/radius/radius_client.c
+++ b/src/radius/radius_client.c
@@ -393,9 +393,12 @@ static int radius_client_retransmit(struct radius_client_data *radius,
 
 	entry->next_try = now + entry->next_wait;
 	entry->next_wait *= 2;
-	if (entry->next_wait > RADIUS_CLIENT_MAX_WAIT)
-		entry->next_wait = RADIUS_CLIENT_MAX_WAIT;
-	if (entry->attempts >= RADIUS_CLIENT_MAX_RETRIES) {
+	if (entry->next_wait > conf->radius_max_retry_wait){
+		entry->next_wait = conf->radius_max_retry_wait;
+		entry->next_try = now + entry->next_wait;
+	}
+	wpa_printf(MSG_INFO, "RADIUS: Retry attempts :%d Maximum retry attempts :%d ",entry->attempts,conf->radius_server_retries);
+	if (entry->attempts >= conf->radius_server_retries) {
 		wpa_printf(MSG_INFO, "RADIUS: Removing un-ACKed message due to too many failed retransmit attempts");
 		return 1;
 	}
diff --git a/src/radius/radius_client.h b/src/radius/radius_client.h
index 3db16aa..a5f1618 100644
--- a/src/radius/radius_client.h
+++ b/src/radius/radius_client.h
@@ -174,6 +174,9 @@ struct hostapd_radius_servers {
 	 * force_client_addr - Whether to force client (local) address
 	 */
 	int force_client_addr;
+
+        int radius_server_retries;
+        int radius_max_retry_wait;
 };
 
 
