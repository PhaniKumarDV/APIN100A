/*
 * Copyright (c) 2015 Qualcomm Atheros, Inc.
 * All Rights Reserved.
 * Qualcomm Atheros Confidential and Proprietary.
 */


#ifndef __RX_DESC_INTERNAL_H
#define __RX_DESC_INTERNAL_H

#include <a_types.h>
#include <wal_rx_desc.h>

struct fw_rx_desc {
    union {
        struct fw_rx_desc_base val;
        A_UINT32 dummy_pad; /* make sure it is DOWRD aligned */
    } u;
};

/*
 *  * This struct defines the basic descriptor information used by host,
 *   * which is written either by the 11ac HW MAC into the host Rx data
 *    * buffer ring directly or generated by FW and copied from Rx indication
 *     */
#define RX_HDR_STATUS_LEN 64
struct rx_desc_base {
    struct fw_rx_desc    fw_desc;
    struct rx_attention  attention;
    struct rx_frag_info  frag_info;
    struct rx_mpdu_start mpdu_start;
    struct rx_msdu_start msdu_start;
    struct rx_msdu_end   msdu_end;
    struct rx_mpdu_end   mpdu_end;
    struct rx_ppdu_start ppdu_start;
    struct rx_ppdu_end   ppdu_end;
    char rx_hdr_status[RX_HDR_STATUS_LEN];
};

#define RX_STD_DESC_SIZE (sizeof(struct rx_desc_base))

typedef struct {
    u_int16_t   ip_offset         : 6,
                tcp_udp_offset    : 7,
                tcp_proto         : 1,
                ipv6_proto        : 1,
                tcp_only_ack      : 1;

    u_int32_t   flow_id_crc;

    u_int16_t   lro_eligible      : 1,
                reserved          : 15;

    u_int16_t   tcp_udp_cksum;
}lro_info_t;

#define RX_DESC_ALIGN_MASK 7 /* 8-byte alignment */
#ifndef RX_DESC_ALIGN_RESERVED
#define RX_DESC_ALIGN_RESERVED 0
#endif
#if (QCA_PARTNER_DIRECTLINK_RX || QCA_PARTNER_CBM_DIRECTPATH)
/* declare direct link specific API for rx desc processing */
#define QCA_PARTNER_DIRECTLINK_RX_DESC_INTERNAL 1
#include "ath_carr_pltfrm.h"
#undef QCA_PARTNER_DIRECTLINK_RX_DESC_INTERNAL
#endif
static inline
struct rx_desc_base *
ar_rx_desc(qdf_nbuf_t msdu)
{
#if (QCA_PARTNER_DIRECTLINK_RX || QCA_PARTNER_CBM_DIRECTPATH)
    if(is_partner_buffer(msdu))
    {
        return (struct rx_desc_base *)
            ((((size_t) (qdf_nbuf_head(msdu) + NBUF_HEADER_RESERVED_PARTNER + RX_DESC_ALIGN_MASK)) &
            ~RX_DESC_ALIGN_MASK) + RX_DESC_ALIGN_RESERVED);
    }
#endif
    return
        (struct rx_desc_base *)
        ((((size_t) (qdf_nbuf_head(msdu) + RX_DESC_ALIGN_MASK)) &
          ~RX_DESC_ALIGN_MASK) + RX_DESC_ALIGN_RESERVED);
}

#define MASK_BYTE3 0xff000000
#define SHIFT_BYTE3 24
#define RX_DESC_PREAMBLE_OFFSET 5
#define RX_DESC_MASK_LSIG_SEL  0x00000010
#define RX_DESC_MASK_LSIG_RATE 0x0000000f
#define RX_DESC_HT_RATE_OFFSET 6
#define RX_DESC_HT_MCS_MASK 0x7f
#define RX_DESC_VHT_RATE_OFFSET 7
#define RX_DESC_VHT_MCS_MASK 0xf
#define RX_DESC_VHT_NSS_MASK 0x7
#define RX_DESC_VHT_BW_MASK 3
#define RX_DESC_VHT_SGI_MASK 1

static inline
qdf_nbuf_t
rx_adf_noclone_buf(qdf_nbuf_t buf)
{
    return buf;
}

#endif //__RX_DESC_INTERNAL_H
